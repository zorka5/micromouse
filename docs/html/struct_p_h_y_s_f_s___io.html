<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>micromouse: PHYSFS_Io Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">micromouse
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('struct_p_h_y_s_f_s___io.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="struct_p_h_y_s_f_s___io-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">PHYSFS_Io Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An abstract i/o interface.  
 <a href="struct_p_h_y_s_f_s___io.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="physfs_8h_source.html">physfs.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aeeacb84ee2afaa3ef4012d54ecef7273" id="r_aeeacb84ee2afaa3ef4012d54ecef7273"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___io.html#aeeacb84ee2afaa3ef4012d54ecef7273">version</a></td></tr>
<tr class="memdesc:aeeacb84ee2afaa3ef4012d54ecef7273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary compatibility information.  <br /></td></tr>
<tr class="separator:aeeacb84ee2afaa3ef4012d54ecef7273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5feb5c1c53823a89e339832961e76fa" id="r_ad5feb5c1c53823a89e339832961e76fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___io.html#ad5feb5c1c53823a89e339832961e76fa">opaque</a></td></tr>
<tr class="memdesc:ad5feb5c1c53823a89e339832961e76fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instance data for this struct.  <br /></td></tr>
<tr class="separator:ad5feb5c1c53823a89e339832961e76fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec94416bfe259ef747c2fe09ac110c0" id="r_aaec94416bfe259ef747c2fe09ac110c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___io.html#aaec94416bfe259ef747c2fe09ac110c0">read</a> )(struct <a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *io, <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *buf, <a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> len)</td></tr>
<tr class="memdesc:aaec94416bfe259ef747c2fe09ac110c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read more data.  <br /></td></tr>
<tr class="separator:aaec94416bfe259ef747c2fe09ac110c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d2faf6a0c7e5f0f40d2d15be9ebb23" id="r_a19d2faf6a0c7e5f0f40d2d15be9ebb23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___io.html#a19d2faf6a0c7e5f0f40d2d15be9ebb23">write</a> )(struct <a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *io, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *buffer, <a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> len)</td></tr>
<tr class="memdesc:a19d2faf6a0c7e5f0f40d2d15be9ebb23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write more data.  <br /></td></tr>
<tr class="separator:a19d2faf6a0c7e5f0f40d2d15be9ebb23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e63ce07597ac7899c562cdbcb26aac4" id="r_a2e63ce07597ac7899c562cdbcb26aac4"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___io.html#a2e63ce07597ac7899c562cdbcb26aac4">seek</a> )(struct <a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *io, <a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> offset)</td></tr>
<tr class="memdesc:a2e63ce07597ac7899c562cdbcb26aac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move i/o position to a given byte offset from start.  <br /></td></tr>
<tr class="separator:a2e63ce07597ac7899c562cdbcb26aac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f3c06a280033c3db6d416dd080345c" id="r_a56f3c06a280033c3db6d416dd080345c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___io.html#a56f3c06a280033c3db6d416dd080345c">tell</a> )(struct <a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *io)</td></tr>
<tr class="memdesc:a56f3c06a280033c3db6d416dd080345c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report current i/o position.  <br /></td></tr>
<tr class="separator:a56f3c06a280033c3db6d416dd080345c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193b2182d7101533d68afd4ba385e2b8" id="r_a193b2182d7101533d68afd4ba385e2b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___io.html#a193b2182d7101533d68afd4ba385e2b8">length</a> )(struct <a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *io)</td></tr>
<tr class="memdesc:a193b2182d7101533d68afd4ba385e2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine size of the i/o instance's dataset.  <br /></td></tr>
<tr class="separator:a193b2182d7101533d68afd4ba385e2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d164b0e04bab83de1fc34a79c2a34f" id="r_a68d164b0e04bab83de1fc34a79c2a34f"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___io.html#a68d164b0e04bab83de1fc34a79c2a34f">duplicate</a> )(struct <a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *io)</td></tr>
<tr class="memdesc:a68d164b0e04bab83de1fc34a79c2a34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate this i/o instance.  <br /></td></tr>
<tr class="separator:a68d164b0e04bab83de1fc34a79c2a34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf157fcf4bd5d9c7a738d1b8964688cd" id="r_adf157fcf4bd5d9c7a738d1b8964688cd"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___io.html#adf157fcf4bd5d9c7a738d1b8964688cd">flush</a> )(struct <a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *io)</td></tr>
<tr class="memdesc:adf157fcf4bd5d9c7a738d1b8964688cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush resources to media, or wherever.  <br /></td></tr>
<tr class="separator:adf157fcf4bd5d9c7a738d1b8964688cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c444d656db5b0a5fe61b9476d0643f7" id="r_a7c444d656db5b0a5fe61b9476d0643f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___io.html#a7c444d656db5b0a5fe61b9476d0643f7">destroy</a> )(struct <a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *io)</td></tr>
<tr class="memdesc:a7c444d656db5b0a5fe61b9476d0643f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup and deallocate i/o instance.  <br /></td></tr>
<tr class="separator:a7c444d656db5b0a5fe61b9476d0643f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An abstract i/o interface. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is advanced, hardcore stuff. You don't need this unless you really know what you're doing. Most apps will not need this.</dd></dl>
<p>Historically, PhysicsFS provided access to the physical filesystem and archives within that filesystem. However, sometimes you need more power than this. Perhaps you need to provide an archive that is entirely contained in RAM, or you need to bridge some other file i/o API to PhysicsFS, or you need to translate the bits (perhaps you have a a standard .zip file that's encrypted, and you need to decrypt on the fly for the unsuspecting zip archiver).</p>
<p>A <a class="el" href="struct_p_h_y_s_f_s___io.html" title="An abstract i/o interface.">PHYSFS_Io</a> is the interface that Archivers use to get archive data. Historically, this has mapped to file i/o to the physical filesystem, but as of PhysicsFS 2.1, applications can provide their own i/o implementations at runtime.</p>
<p>This interface isn't necessarily a good universal fit for i/o. There are a few requirements of note:</p>
<ul>
<li>They only do blocking i/o (at least, for now).</li>
<li>They need to be able to duplicate. If you have a file handle from fopen(), you need to be able to create a unique clone of it (so we have two handles to the same file that can both seek/read/etc without stepping on each other).</li>
<li>They need to know the size of their entire data set.</li>
<li>They need to be able to seek and rewind on demand.</li>
</ul>
<p>...in short, you're probably not going to write an HTTP implementation.</p>
<p>Thread safety: <a class="el" href="struct_p_h_y_s_f_s___io.html" title="An abstract i/o interface.">PHYSFS_Io</a> implementations are not guaranteed to be thread safe in themselves. Under the hood where PhysicsFS uses them, the library provides its own locks. If you plan to use them directly from separate threads, you should either use mutexes to protect them, or don't use the same <a class="el" href="struct_p_h_y_s_f_s___io.html" title="An abstract i/o interface.">PHYSFS_Io</a> from two threads at the same time.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a7ac107cf895f50f0d2219cdf44b8b758" title="Add an archive, built on a PHYSFS_Io, to the search path.">PHYSFS_mountIo</a> </dd></dl>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a id="a7c444d656db5b0a5fe61b9476d0643f7" name="a7c444d656db5b0a5fe61b9476d0643f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c444d656db5b0a5fe61b9476d0643f7">&#9670;&#160;</a></span>destroy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>(* PHYSFS_Io::destroy) (struct <a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *io)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleanup and deallocate i/o instance. </p>
<p>Free associated resources, including (opaque) if applicable.</p>
<p>This function must always succeed: as such, it returns void. The system may call your <a class="el" href="struct_p_h_y_s_f_s___io.html#adf157fcf4bd5d9c7a738d1b8964688cd" title="Flush resources to media, or wherever.">flush()</a> method before this. You may report failure there if necessary. This method may still be called if <a class="el" href="struct_p_h_y_s_f_s___io.html#adf157fcf4bd5d9c7a738d1b8964688cd" title="Flush resources to media, or wherever.">flush()</a> fails, in which case you'll have to abandon unflushed data and other failing conditions and clean up.</p>
<p>Once this method is called for a given instance, the system will assume it is unsafe to touch that instance again and will discard any references to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The i/o instance to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68d164b0e04bab83de1fc34a79c2a34f" name="a68d164b0e04bab83de1fc34a79c2a34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d164b0e04bab83de1fc34a79c2a34f">&#9670;&#160;</a></span>duplicate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *(* PHYSFS_Io::duplicate) (struct <a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *io)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate this i/o instance. </p>
<p>This needs to result in a full copy of this <a class="el" href="struct_p_h_y_s_f_s___io.html" title="An abstract i/o interface.">PHYSFS_Io</a>, that can live completely independently. The copy needs to be able to perform all its operations without altering the original, including either object being destroyed separately (so, for example: they can't share a file handle; they each need their own).</p>
<p>If you can't duplicate a handle, it's legal to return NULL, but you almost certainly need this functionality if you want to use this to <a class="el" href="struct_p_h_y_s_f_s___io.html" title="An abstract i/o interface.">PHYSFS_Io</a> to back an archive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The i/o instance to duplicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new value for a stream's (opaque) field, or NULL on error. </dd></dl>

</div>
</div>
<a id="adf157fcf4bd5d9c7a738d1b8964688cd" name="adf157fcf4bd5d9c7a738d1b8964688cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf157fcf4bd5d9c7a738d1b8964688cd">&#9670;&#160;</a></span>flush</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* PHYSFS_Io::flush) (struct <a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *io)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush resources to media, or wherever. </p>
<p>This is the chance to report failure for writes that had claimed success earlier, but still had a chance to actually fail. This method can be NULL if flushing isn't necessary.</p>
<p>This function may be called before <a class="el" href="struct_p_h_y_s_f_s___io.html#a7c444d656db5b0a5fe61b9476d0643f7" title="Cleanup and deallocate i/o instance.">destroy()</a>, as it can report failure and <a class="el" href="struct_p_h_y_s_f_s___io.html#a7c444d656db5b0a5fe61b9476d0643f7" title="Cleanup and deallocate i/o instance.">destroy()</a> can not. It may be called at other times, too.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The i/o instance to flush. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on error, non-zero on success. </dd></dl>

</div>
</div>
<a id="a193b2182d7101533d68afd4ba385e2b8" name="a193b2182d7101533d68afd4ba385e2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193b2182d7101533d68afd4ba385e2b8">&#9670;&#160;</a></span>length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a>(* PHYSFS_Io::length) (struct <a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *io)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine size of the i/o instance's dataset. </p>
<p>Return number of bytes available in the file, or -1 if you aren't able to determine. A failure will almost certainly be fatal to further use of this stream, so you may not leave this unimplemented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The i/o instance to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total size, in bytes, of the dataset. </dd></dl>

</div>
</div>
<a id="ad5feb5c1c53823a89e339832961e76fa" name="ad5feb5c1c53823a89e339832961e76fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5feb5c1c53823a89e339832961e76fa">&#9670;&#160;</a></span>opaque</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>* PHYSFS_Io::opaque</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instance data for this struct. </p>
<p>Each instance has a pointer associated with it that can be used to store anything it likes. This pointer is per-instance of the stream, so presumably it will change when calling <a class="el" href="struct_p_h_y_s_f_s___io.html#a68d164b0e04bab83de1fc34a79c2a34f" title="Duplicate this i/o instance.">duplicate()</a>. This can be deallocated during the <a class="el" href="struct_p_h_y_s_f_s___io.html#a7c444d656db5b0a5fe61b9476d0643f7" title="Cleanup and deallocate i/o instance.">destroy()</a> method. </p>

</div>
</div>
<a id="aaec94416bfe259ef747c2fe09ac110c0" name="aaec94416bfe259ef747c2fe09ac110c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec94416bfe259ef747c2fe09ac110c0">&#9670;&#160;</a></span>read</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a>(* PHYSFS_Io::read) (struct <a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *io, <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *buf, <a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read more data. </p>
<p>Read (len) bytes from the interface, at the current i/o position, and store them in (buffer). The current i/o position should move ahead by the number of bytes successfully read.</p>
<p>You don't have to implement this; set it to NULL if not implemented. This will only be used if the file is opened for reading. If set to NULL, a default implementation that immediately reports failure will be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The i/o instance to read from. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer to store data into. It must be at least (len) bytes long and can't be NULL. </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes to read from the interface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read from file, 0 on EOF, -1 if complete failure. </dd></dl>

</div>
</div>
<a id="a2e63ce07597ac7899c562cdbcb26aac4" name="a2e63ce07597ac7899c562cdbcb26aac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e63ce07597ac7899c562cdbcb26aac4">&#9670;&#160;</a></span>seek</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* PHYSFS_Io::seek) (struct <a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *io, <a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> offset)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move i/o position to a given byte offset from start. </p>
<p>This method moves the i/o position, so the next read/write will be of the byte at (offset) offset. Seeks past the end of file should be treated as an error condition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The i/o instance to seek. </td></tr>
    <tr><td class="paramname">offset</td><td>The new byte offset for the i/o position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero on success, zero on error. </dd></dl>

</div>
</div>
<a id="a56f3c06a280033c3db6d416dd080345c" name="a56f3c06a280033c3db6d416dd080345c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56f3c06a280033c3db6d416dd080345c">&#9670;&#160;</a></span>tell</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a>(* PHYSFS_Io::tell) (struct <a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *io)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report current i/o position. </p>
<p>Return bytes offset, or -1 if you aren't able to determine. A failure will almost certainly be fatal to further use of this stream, so you may not leave this unimplemented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The i/o instance to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current byte offset for the i/o position, -1 if unknown. </dd></dl>

</div>
</div>
<a id="aeeacb84ee2afaa3ef4012d54ecef7273" name="aeeacb84ee2afaa3ef4012d54ecef7273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeacb84ee2afaa3ef4012d54ecef7273">&#9670;&#160;</a></span>version</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a> PHYSFS_Io::version</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary compatibility information. </p>
<p>This must be set to zero at this time. Future versions of this struct will increment this field, so we know what a given implementation supports. We'll presumably keep supporting older versions as we offer new features, though. </p>

</div>
</div>
<a id="a19d2faf6a0c7e5f0f40d2d15be9ebb23" name="a19d2faf6a0c7e5f0f40d2d15be9ebb23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d2faf6a0c7e5f0f40d2d15be9ebb23">&#9670;&#160;</a></span>write</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a>(* PHYSFS_Io::write) (struct <a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *io, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *buffer, <a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write more data. </p>
<p>Write (len) bytes from (buffer) to the interface at the current i/o position. The current i/o position should move ahead by the number of bytes successfully written.</p>
<p>You don't have to implement this; set it to NULL if not implemented. This will only be used if the file is opened for writing. If set to NULL, a default implementation that immediately reports failure will be used.</p>
<p>You are allowed to buffer; a write can succeed here and then later fail when flushing. Note that <a class="el" href="physfs_8h.html#aede5de47197e1a613d2091802befc886" title="Set up buffering for a PhysicsFS file handle.">PHYSFS_setBuffer()</a> may be operating a level above your i/o, so you should usually not implement your own buffering routines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The i/o instance to write to. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer to read data from. It must be at least (len) bytes long and can't be NULL. </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes to read from (buffer). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written to file, -1 if complete failure. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
