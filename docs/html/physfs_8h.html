<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>micromouse: packages/AllegroDeps.1.13.0/build/native/include/physfs.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">micromouse
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('physfs_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">physfs.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Main header file for PhysicsFS.  
<a href="#details">More...</a></p>

<p><a href="physfs_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A PhysicsFS file handle.  <a href="struct_p_h_y_s_f_s___file.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___archive_info.html">PHYSFS_ArchiveInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information on various PhysicsFS-supported archives.  <a href="struct_p_h_y_s_f_s___archive_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___version.html">PHYSFS_Version</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information the version of PhysicsFS in use.  <a href="struct_p_h_y_s_f_s___version.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___allocator.html">PHYSFS_Allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PhysicsFS allocation function pointers.  <a href="struct_p_h_y_s_f_s___allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___stat.html">PHYSFS_Stat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta data for a file or directory.  <a href="struct_p_h_y_s_f_s___stat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract i/o interface.  <a href="struct_p_h_y_s_f_s___io.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___archiver.html">PHYSFS_Archiver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface to provide support for user-defined archives.  <a href="struct_p_h_y_s_f_s___archiver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a7c7073ec1126c2f7661a9fde8f67f8b8" id="r_a7c7073ec1126c2f7661a9fde8f67f8b8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a></td></tr>
<tr class="separator:a7c7073ec1126c2f7661a9fde8f67f8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5067c1fd0aa1cef18bc92b908a1348" id="r_aee5067c1fd0aa1cef18bc92b908a1348"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#aee5067c1fd0aa1cef18bc92b908a1348">PHYSFS_DEPRECATED</a></td></tr>
<tr class="separator:aee5067c1fd0aa1cef18bc92b908a1348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2e28137976625c89ae24b2778567e3" id="r_acc2e28137976625c89ae24b2778567e3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#acc2e28137976625c89ae24b2778567e3">PHYSFS_COMPILE_TIME_ASSERT</a>(name,  <a class="el" href="fmaths_8inl.html#a7ba8ab2f1e8f362163e17da3f15a5db9">x</a>)&#160;&#160;&#160;       typedef int PHYSFS_compile_time_assert_##name[(<a class="el" href="fmaths_8inl.html#a7ba8ab2f1e8f362163e17da3f15a5db9">x</a>) * 2 - 1]</td></tr>
<tr class="separator:acc2e28137976625c89ae24b2778567e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32c738a1a111f0d3f29e4637633bfd1" id="r_ad32c738a1a111f0d3f29e4637633bfd1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#ad32c738a1a111f0d3f29e4637633bfd1">PHYSFS_file</a>&#160;&#160;&#160;<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a></td></tr>
<tr class="memdesc:ad32c738a1a111f0d3f29e4637633bfd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">1.0 API compatibility define.  <br /></td></tr>
<tr class="separator:ad32c738a1a111f0d3f29e4637633bfd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0b94a8f06bc69bd18d741b3e66dfa4" id="r_abc0b94a8f06bc69bd18d741b3e66dfa4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#abc0b94a8f06bc69bd18d741b3e66dfa4">PHYSFS_VER_MAJOR</a>&#160;&#160;&#160;3</td></tr>
<tr class="separator:abc0b94a8f06bc69bd18d741b3e66dfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f53f1b74ad284d3e7e56d270e449ba" id="r_a30f53f1b74ad284d3e7e56d270e449ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a30f53f1b74ad284d3e7e56d270e449ba">PHYSFS_VER_MINOR</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a30f53f1b74ad284d3e7e56d270e449ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9cc71df9b5802460d7b9bb08c3b5fe" id="r_a0c9cc71df9b5802460d7b9bb08c3b5fe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a0c9cc71df9b5802460d7b9bb08c3b5fe">PHYSFS_VER_PATCH</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a0c9cc71df9b5802460d7b9bb08c3b5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb77c1f8f70028add43b9f81eef1ed78" id="r_acb77c1f8f70028add43b9f81eef1ed78"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#acb77c1f8f70028add43b9f81eef1ed78">PHYSFS_VERSION</a>(<a class="el" href="fmaths_8inl.html#a7ba8ab2f1e8f362163e17da3f15a5db9">x</a>)</td></tr>
<tr class="memdesc:acb77c1f8f70028add43b9f81eef1ed78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to determine PhysicsFS version program was compiled against.  <br /></td></tr>
<tr class="separator:acb77c1f8f70028add43b9f81eef1ed78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abb348466106a912e03cf63f494a30356" id="r_abb348466106a912e03cf63f494a30356"><td class="memItemLeft" align="right" valign="top">typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#abb348466106a912e03cf63f494a30356">PHYSFS_uint8</a></td></tr>
<tr class="memdesc:abb348466106a912e03cf63f494a30356"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unsigned, 8-bit integer type.  <br /></td></tr>
<tr class="separator:abb348466106a912e03cf63f494a30356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76505754bb5c7f8f5e964e1a4d1a2571" id="r_a76505754bb5c7f8f5e964e1a4d1a2571"><td class="memItemLeft" align="right" valign="top">typedef signed char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a76505754bb5c7f8f5e964e1a4d1a2571">PHYSFS_sint8</a></td></tr>
<tr class="memdesc:a76505754bb5c7f8f5e964e1a4d1a2571"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signed, 8-bit integer type.  <br /></td></tr>
<tr class="separator:a76505754bb5c7f8f5e964e1a4d1a2571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d1c74e276b04ef993530a405553574" id="r_ac4d1c74e276b04ef993530a405553574"><td class="memItemLeft" align="right" valign="top">typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a></td></tr>
<tr class="memdesc:ac4d1c74e276b04ef993530a405553574"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unsigned, 16-bit integer type.  <br /></td></tr>
<tr class="separator:ac4d1c74e276b04ef993530a405553574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed97311e1294c0b42648f99d331e5a0" id="r_aeed97311e1294c0b42648f99d331e5a0"><td class="memItemLeft" align="right" valign="top">typedef signed short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#aeed97311e1294c0b42648f99d331e5a0">PHYSFS_sint16</a></td></tr>
<tr class="memdesc:aeed97311e1294c0b42648f99d331e5a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signed, 16-bit integer type.  <br /></td></tr>
<tr class="separator:aeed97311e1294c0b42648f99d331e5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae011b45ebd619edb193fe196e1f5f74" id="r_aae011b45ebd619edb193fe196e1f5f74"><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a></td></tr>
<tr class="memdesc:aae011b45ebd619edb193fe196e1f5f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unsigned, 32-bit integer type.  <br /></td></tr>
<tr class="separator:aae011b45ebd619edb193fe196e1f5f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0264996863470a315e29d5a740a0f36" id="r_ae0264996863470a315e29d5a740a0f36"><td class="memItemLeft" align="right" valign="top">typedef signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#ae0264996863470a315e29d5a740a0f36">PHYSFS_sint32</a></td></tr>
<tr class="memdesc:ae0264996863470a315e29d5a740a0f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signed, 32-bit integer type.  <br /></td></tr>
<tr class="separator:ae0264996863470a315e29d5a740a0f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632ba02500231e5f6f6df2e4cb71c818" id="r_a632ba02500231e5f6f6df2e4cb71c818"><td class="memItemLeft" align="right" valign="top">typedef unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a></td></tr>
<tr class="memdesc:a632ba02500231e5f6f6df2e4cb71c818"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unsigned, 64-bit integer type.  <br /></td></tr>
<tr class="separator:a632ba02500231e5f6f6df2e4cb71c818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c5f1d7b088888c729b22644651c9f5" id="r_a88c5f1d7b088888c729b22644651c9f5"><td class="memItemLeft" align="right" valign="top">typedef signed long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a></td></tr>
<tr class="memdesc:a88c5f1d7b088888c729b22644651c9f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signed, 64-bit integer type.  <br /></td></tr>
<tr class="separator:a88c5f1d7b088888c729b22644651c9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb19ab3e6ff04a43ef335e22c77f148e" id="r_abb19ab3e6ff04a43ef335e22c77f148e"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#abb19ab3e6ff04a43ef335e22c77f148e">PHYSFS_File</a></td></tr>
<tr class="separator:abb19ab3e6ff04a43ef335e22c77f148e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4205d2b4f7fb274a3c9a6e37dc8d9bd5" id="r_a4205d2b4f7fb274a3c9a6e37dc8d9bd5"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_p_h_y_s_f_s___archive_info.html">PHYSFS_ArchiveInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a4205d2b4f7fb274a3c9a6e37dc8d9bd5">PHYSFS_ArchiveInfo</a></td></tr>
<tr class="separator:a4205d2b4f7fb274a3c9a6e37dc8d9bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b883c2a3d58820281a314742bb1b63" id="r_af5b883c2a3d58820281a314742bb1b63"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_p_h_y_s_f_s___version.html">PHYSFS_Version</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#af5b883c2a3d58820281a314742bb1b63">PHYSFS_Version</a></td></tr>
<tr class="separator:af5b883c2a3d58820281a314742bb1b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217365fb44c681e0eb6eddb852f5f979" id="r_a217365fb44c681e0eb6eddb852f5f979"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_p_h_y_s_f_s___allocator.html">PHYSFS_Allocator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a217365fb44c681e0eb6eddb852f5f979">PHYSFS_Allocator</a></td></tr>
<tr class="separator:a217365fb44c681e0eb6eddb852f5f979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6331ac65f8e0d32288f8597e48188a4f" id="r_a6331ac65f8e0d32288f8597e48188a4f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a6331ac65f8e0d32288f8597e48188a4f">PHYSFS_StringCallback</a>) (<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *str)</td></tr>
<tr class="memdesc:a6331ac65f8e0d32288f8597e48188a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function signature for callbacks that report strings.  <br /></td></tr>
<tr class="separator:a6331ac65f8e0d32288f8597e48188a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c1e0145502aeaf080973d308d33c6a" id="r_a51c1e0145502aeaf080973d308d33c6a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a51c1e0145502aeaf080973d308d33c6a">PHYSFS_EnumFilesCallback</a>) (<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *origdir, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *fname)</td></tr>
<tr class="memdesc:a51c1e0145502aeaf080973d308d33c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function signature for callbacks that enumerate files.  <br /></td></tr>
<tr class="separator:a51c1e0145502aeaf080973d308d33c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f00758603989637229ab5f1503b4cd4" id="r_a9f00758603989637229ab5f1503b4cd4"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="physfs_8h.html#aa11a2522c5f699b00d19802b721e73d4">PHYSFS_EnumerateCallbackResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a9f00758603989637229ab5f1503b4cd4">PHYSFS_EnumerateCallbackResult</a></td></tr>
<tr class="separator:a9f00758603989637229ab5f1503b4cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e72dbc92c0decdca218c8a9a658e788" id="r_a1e72dbc92c0decdca218c8a9a658e788"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="physfs_8h.html#aa11a2522c5f699b00d19802b721e73d4">PHYSFS_EnumerateCallbackResult</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a1e72dbc92c0decdca218c8a9a658e788">PHYSFS_EnumerateCallback</a>) (<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *origdir, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *fname)</td></tr>
<tr class="memdesc:a1e72dbc92c0decdca218c8a9a658e788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible return values from PHYSFS_EnumerateCallback.  <br /></td></tr>
<tr class="separator:a1e72dbc92c0decdca218c8a9a658e788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d98655e86dfaee90747a238421ebed" id="r_ad6d98655e86dfaee90747a238421ebed"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="physfs_8h.html#ac83274ef7d83801a80563476516bfa15">PHYSFS_FileType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#ad6d98655e86dfaee90747a238421ebed">PHYSFS_FileType</a></td></tr>
<tr class="separator:ad6d98655e86dfaee90747a238421ebed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff64e61b04713ef4264ba9e74b3a29a" id="r_a0ff64e61b04713ef4264ba9e74b3a29a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_p_h_y_s_f_s___stat.html">PHYSFS_Stat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a0ff64e61b04713ef4264ba9e74b3a29a">PHYSFS_Stat</a></td></tr>
<tr class="separator:a0ff64e61b04713ef4264ba9e74b3a29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75501e493c6831f2dfa930143b887ce8" id="r_a75501e493c6831f2dfa930143b887ce8"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a75501e493c6831f2dfa930143b887ce8">PHYSFS_Io</a></td></tr>
<tr class="separator:a75501e493c6831f2dfa930143b887ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af546184cb93c10ffe23db24ee1b75f8d" id="r_af546184cb93c10ffe23db24ee1b75f8d"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afed">PHYSFS_ErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#af546184cb93c10ffe23db24ee1b75f8d">PHYSFS_ErrorCode</a></td></tr>
<tr class="separator:af546184cb93c10ffe23db24ee1b75f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79850057f06c98bf3fcb1365a76ca212" id="r_a79850057f06c98bf3fcb1365a76ca212"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_p_h_y_s_f_s___archiver.html">PHYSFS_Archiver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a79850057f06c98bf3fcb1365a76ca212">PHYSFS_Archiver</a></td></tr>
<tr class="separator:a79850057f06c98bf3fcb1365a76ca212"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa11a2522c5f699b00d19802b721e73d4" id="r_aa11a2522c5f699b00d19802b721e73d4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#aa11a2522c5f699b00d19802b721e73d4">PHYSFS_EnumerateCallbackResult</a> { <a class="el" href="physfs_8h.html#aa11a2522c5f699b00d19802b721e73d4a709ef5541f2471dc606a204bded733e1">PHYSFS_ENUM_ERROR</a> = -1
, <a class="el" href="physfs_8h.html#aa11a2522c5f699b00d19802b721e73d4a793f45e661a94768c0826b6ea1e93aa3">PHYSFS_ENUM_STOP</a> = 0
, <a class="el" href="physfs_8h.html#aa11a2522c5f699b00d19802b721e73d4ac8d05f52332e6b6452dc52e58f0bfdfe">PHYSFS_ENUM_OK</a> = 1
 }</td></tr>
<tr class="separator:aa11a2522c5f699b00d19802b721e73d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83274ef7d83801a80563476516bfa15" id="r_ac83274ef7d83801a80563476516bfa15"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#ac83274ef7d83801a80563476516bfa15">PHYSFS_FileType</a> { <a class="el" href="physfs_8h.html#ac83274ef7d83801a80563476516bfa15ae99e7a2bad864791c680eac138d9fb3a">PHYSFS_FILETYPE_REGULAR</a>
, <a class="el" href="physfs_8h.html#ac83274ef7d83801a80563476516bfa15a3ca9b647070a1b72496940026649bd02">PHYSFS_FILETYPE_DIRECTORY</a>
, <a class="el" href="physfs_8h.html#ac83274ef7d83801a80563476516bfa15a98794e6fd60557ce50623f81e86e7663">PHYSFS_FILETYPE_SYMLINK</a>
, <a class="el" href="physfs_8h.html#ac83274ef7d83801a80563476516bfa15a83e202bbeee9274a8e746dde9ab5fef8">PHYSFS_FILETYPE_OTHER</a>
 }</td></tr>
<tr class="memdesc:ac83274ef7d83801a80563476516bfa15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a File.  <a href="physfs_8h.html#ac83274ef7d83801a80563476516bfa15">More...</a><br /></td></tr>
<tr class="separator:ac83274ef7d83801a80563476516bfa15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50dba13af51214897c867a123f74afed" id="r_a50dba13af51214897c867a123f74afed"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afed">PHYSFS_ErrorCode</a> { <br />
&#160;&#160;<a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afeda350a0311fc19d8b9b5ec06f312e703ce">PHYSFS_ERR_OK</a>
, <a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afedaf6bd49755fa19f8c94f326d1dd45bc60">PHYSFS_ERR_OTHER_ERROR</a>
, <a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afeda3cad5fa8b3b9fdd5d898ec0c49468842">PHYSFS_ERR_OUT_OF_MEMORY</a>
, <a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afedaf162fd97734c33e5daea378f8ad8f700">PHYSFS_ERR_NOT_INITIALIZED</a>
, <br />
&#160;&#160;<a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afedae05bb5fb7bf20246c93010f32f1506dd">PHYSFS_ERR_IS_INITIALIZED</a>
, <a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afedad241a62d7f79e0604bdd7ae580381cf6">PHYSFS_ERR_ARGV0_IS_NULL</a>
, <a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afeda734e86036e56e76ece258cfd07fc607c">PHYSFS_ERR_UNSUPPORTED</a>
, <a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afeda6cfa14f636960665f071b615086ccb57">PHYSFS_ERR_PAST_EOF</a>
, <br />
&#160;&#160;<a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afeda339879ed2ed7aa5710b0db495a60df86">PHYSFS_ERR_FILES_STILL_OPEN</a>
, <a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afedaafe411479f6f10a74bd04a601cdea8e1">PHYSFS_ERR_INVALID_ARGUMENT</a>
, <a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afeda1c124b069747e079a1714de93656385b">PHYSFS_ERR_NOT_MOUNTED</a>
, <a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afeda426ece1b73ffc73afed87ed2203b84f4">PHYSFS_ERR_NOT_FOUND</a>
, <br />
&#160;&#160;<a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afeda52883f3495052d538b935d1d67b820c3">PHYSFS_ERR_SYMLINK_FORBIDDEN</a>
, <a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afeda78a43f3de727ea7594a9a143ed252e52">PHYSFS_ERR_NO_WRITE_DIR</a>
, <a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afeda30dc0b5b61c31ce2e5c15a995b7d03a8">PHYSFS_ERR_OPEN_FOR_READING</a>
, <a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afeda56c0a5de581b0981376e2df0d77b995f">PHYSFS_ERR_OPEN_FOR_WRITING</a>
, <br />
&#160;&#160;<a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afedac7308d464cbdeae33b3b46ef477380a4">PHYSFS_ERR_NOT_A_FILE</a>
, <a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afeda02204e5c7d56d8097ac926a0e3ed011b">PHYSFS_ERR_READ_ONLY</a>
, <a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afedadf796cd23b55fc711b50fc903526d02b">PHYSFS_ERR_CORRUPT</a>
, <a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afedac799c795f6aca95e170c3cb7ff145b2c">PHYSFS_ERR_SYMLINK_LOOP</a>
, <br />
&#160;&#160;<a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afeda18a8f0827d6fb21cecd5404cff88cab5">PHYSFS_ERR_IO</a>
, <a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afedacc1abade7a5838284ad6959fe486199c">PHYSFS_ERR_PERMISSION</a>
, <a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afedac1dced0099f8acd28c529883cf2cd894">PHYSFS_ERR_NO_SPACE</a>
, <a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afedaa9cabd98b57c1d0c6f28f008070d8b34">PHYSFS_ERR_BAD_FILENAME</a>
, <br />
&#160;&#160;<a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afeda81cb4cfda88fdac43ca6ec748f8eb380">PHYSFS_ERR_BUSY</a>
, <a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afeda2ef70542e659b8393e217923c762922f">PHYSFS_ERR_DIR_NOT_EMPTY</a>
, <a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afedaab8102396aff3f07f975320a78e3be13">PHYSFS_ERR_OS_ERROR</a>
, <a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afedaf089c21761b1142e0f215843d2dceaa7">PHYSFS_ERR_DUPLICATE</a>
, <br />
&#160;&#160;<a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afeda1782515d1d7babfb7201c2dbc59b507f">PHYSFS_ERR_BAD_PASSWORD</a>
, <a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afeda6161bfc88154640b7fc9bb950111f7ad">PHYSFS_ERR_APP_CALLBACK</a>
<br />
 }</td></tr>
<tr class="memdesc:a50dba13af51214897c867a123f74afed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values that represent specific causes of failure.  <a href="physfs_8h.html#a50dba13af51214897c867a123f74afed">More...</a><br /></td></tr>
<tr class="separator:a50dba13af51214897c867a123f74afed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa2207071ffb05b44519e759b4606aac7" id="r_aa2207071ffb05b44519e759b4606aac7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#aa2207071ffb05b44519e759b4606aac7">PHYSFS_COMPILE_TIME_ASSERT</a> (uint8IsOneByte, sizeof(<a class="el" href="physfs_8h.html#abb348466106a912e03cf63f494a30356">PHYSFS_uint8</a>)==1)</td></tr>
<tr class="separator:aa2207071ffb05b44519e759b4606aac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8b4671d4729beebbe69b425d73c28e" id="r_a4e8b4671d4729beebbe69b425d73c28e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a4e8b4671d4729beebbe69b425d73c28e">PHYSFS_COMPILE_TIME_ASSERT</a> (sint8IsOneByte, sizeof(<a class="el" href="physfs_8h.html#a76505754bb5c7f8f5e964e1a4d1a2571">PHYSFS_sint8</a>)==1)</td></tr>
<tr class="separator:a4e8b4671d4729beebbe69b425d73c28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9a890eada2dde221e43b25cfd04e4d" id="r_a7b9a890eada2dde221e43b25cfd04e4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a7b9a890eada2dde221e43b25cfd04e4d">PHYSFS_COMPILE_TIME_ASSERT</a> (uint16IsTwoBytes, sizeof(<a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a>)==2)</td></tr>
<tr class="separator:a7b9a890eada2dde221e43b25cfd04e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6eea864894b2642bf4c87d1bc170b8" id="r_a3c6eea864894b2642bf4c87d1bc170b8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a3c6eea864894b2642bf4c87d1bc170b8">PHYSFS_COMPILE_TIME_ASSERT</a> (sint16IsTwoBytes, sizeof(<a class="el" href="physfs_8h.html#aeed97311e1294c0b42648f99d331e5a0">PHYSFS_sint16</a>)==2)</td></tr>
<tr class="separator:a3c6eea864894b2642bf4c87d1bc170b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bedb25e0b7e5e39a51110439b26c5c" id="r_af1bedb25e0b7e5e39a51110439b26c5c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#af1bedb25e0b7e5e39a51110439b26c5c">PHYSFS_COMPILE_TIME_ASSERT</a> (uint32IsFourBytes, sizeof(<a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a>)==4)</td></tr>
<tr class="separator:af1bedb25e0b7e5e39a51110439b26c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba190e4aeacce406f8041be470e151a" id="r_aaba190e4aeacce406f8041be470e151a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#aaba190e4aeacce406f8041be470e151a">PHYSFS_COMPILE_TIME_ASSERT</a> (sint32IsFourBytes, sizeof(<a class="el" href="physfs_8h.html#ae0264996863470a315e29d5a740a0f36">PHYSFS_sint32</a>)==4)</td></tr>
<tr class="separator:aaba190e4aeacce406f8041be470e151a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ba0e406bde32f7e522584f88862420" id="r_ac0ba0e406bde32f7e522584f88862420"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#ac0ba0e406bde32f7e522584f88862420">PHYSFS_COMPILE_TIME_ASSERT</a> (uint64IsEightBytes, sizeof(<a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a>)==8)</td></tr>
<tr class="separator:ac0ba0e406bde32f7e522584f88862420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f82b6510bb1229d36f40a3c48e14f8" id="r_a33f82b6510bb1229d36f40a3c48e14f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a33f82b6510bb1229d36f40a3c48e14f8">PHYSFS_COMPILE_TIME_ASSERT</a> (sint64IsEightBytes, sizeof(<a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a>)==8)</td></tr>
<tr class="separator:a33f82b6510bb1229d36f40a3c48e14f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8977d0ba0a2301256e823532479f1a05" id="r_a8977d0ba0a2301256e823532479f1a05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a8977d0ba0a2301256e823532479f1a05">PHYSFS_getLinkedVersion</a> (<a class="el" href="struct_p_h_y_s_f_s___version.html">PHYSFS_Version</a> *ver)</td></tr>
<tr class="memdesc:a8977d0ba0a2301256e823532479f1a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the version of PhysicsFS that is linked against your program.  <br /></td></tr>
<tr class="separator:a8977d0ba0a2301256e823532479f1a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b94cac8e65267afb8a5f2344e60dd1" id="r_a61b94cac8e65267afb8a5f2344e60dd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a61b94cac8e65267afb8a5f2344e60dd1">PHYSFS_init</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *argv0)</td></tr>
<tr class="memdesc:a61b94cac8e65267afb8a5f2344e60dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the PhysicsFS library.  <br /></td></tr>
<tr class="separator:a61b94cac8e65267afb8a5f2344e60dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa465c9b58e5020f503085d433a413b5b" id="r_aa465c9b58e5020f503085d433a413b5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#aa465c9b58e5020f503085d433a413b5b">PHYSFS_deinit</a> (<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>)</td></tr>
<tr class="memdesc:aa465c9b58e5020f503085d433a413b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitialize the PhysicsFS library.  <br /></td></tr>
<tr class="separator:aa465c9b58e5020f503085d433a413b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca65fbaa485d68113912bbbd70bd19e" id="r_a4ca65fbaa485d68113912bbbd70bd19e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="struct_p_h_y_s_f_s___archive_info.html">PHYSFS_ArchiveInfo</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a4ca65fbaa485d68113912bbbd70bd19e">PHYSFS_supportedArchiveTypes</a> (<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>)</td></tr>
<tr class="memdesc:a4ca65fbaa485d68113912bbbd70bd19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of supported archive types.  <br /></td></tr>
<tr class="separator:a4ca65fbaa485d68113912bbbd70bd19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6aeb2ffdcee44f02cf380da62462b05" id="r_af6aeb2ffdcee44f02cf380da62462b05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#af6aeb2ffdcee44f02cf380da62462b05">PHYSFS_freeList</a> (<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *listVar)</td></tr>
<tr class="memdesc:af6aeb2ffdcee44f02cf380da62462b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate resources of lists returned by PhysicsFS.  <br /></td></tr>
<tr class="separator:af6aeb2ffdcee44f02cf380da62462b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619e0a12b15035f8def90f4ba40ec5d5" id="r_a619e0a12b15035f8def90f4ba40ec5d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a619e0a12b15035f8def90f4ba40ec5d5">PHYSFS_getLastError</a> (<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>) <a class="el" href="physfs_8h.html#aee5067c1fd0aa1cef18bc92b908a1348">PHYSFS_DEPRECATED</a></td></tr>
<tr class="memdesc:a619e0a12b15035f8def90f4ba40ec5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get human-readable error information.  <br /></td></tr>
<tr class="separator:a619e0a12b15035f8def90f4ba40ec5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1dc17d387c45e9155d1f0c348a7cbcc" id="r_ad1dc17d387c45e9155d1f0c348a7cbcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#ad1dc17d387c45e9155d1f0c348a7cbcc">PHYSFS_getDirSeparator</a> (<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>)</td></tr>
<tr class="memdesc:ad1dc17d387c45e9155d1f0c348a7cbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get platform-dependent dir separator string.  <br /></td></tr>
<tr class="separator:ad1dc17d387c45e9155d1f0c348a7cbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad451d9b3f46f627a1be8caee2eef9b7" id="r_aad451d9b3f46f627a1be8caee2eef9b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#aad451d9b3f46f627a1be8caee2eef9b7">PHYSFS_permitSymbolicLinks</a> (int allow)</td></tr>
<tr class="memdesc:aad451d9b3f46f627a1be8caee2eef9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable following of symbolic links.  <br /></td></tr>
<tr class="separator:aad451d9b3f46f627a1be8caee2eef9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a9674a36f7c96ed7813f9db06eefed" id="r_af9a9674a36f7c96ed7813f9db06eefed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#af9a9674a36f7c96ed7813f9db06eefed">PHYSFS_getCdRomDirs</a> (<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>)</td></tr>
<tr class="memdesc:af9a9674a36f7c96ed7813f9db06eefed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an array of paths to available CD-ROM drives.  <br /></td></tr>
<tr class="separator:af9a9674a36f7c96ed7813f9db06eefed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0034c327dfb381a1c95deb80878bcede" id="r_a0034c327dfb381a1c95deb80878bcede"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a0034c327dfb381a1c95deb80878bcede">PHYSFS_getBaseDir</a> (<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>)</td></tr>
<tr class="memdesc:a0034c327dfb381a1c95deb80878bcede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the path where the application resides.  <br /></td></tr>
<tr class="separator:a0034c327dfb381a1c95deb80878bcede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea627ea1124ae42ec8e8d60401d86fd" id="r_a4ea627ea1124ae42ec8e8d60401d86fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a4ea627ea1124ae42ec8e8d60401d86fd">PHYSFS_getUserDir</a> (<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>) <a class="el" href="physfs_8h.html#aee5067c1fd0aa1cef18bc92b908a1348">PHYSFS_DEPRECATED</a></td></tr>
<tr class="memdesc:a4ea627ea1124ae42ec8e8d60401d86fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the path where user's home directory resides.  <br /></td></tr>
<tr class="separator:a4ea627ea1124ae42ec8e8d60401d86fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6533ff91180a4c8abfe24d458f6b9915" id="r_a6533ff91180a4c8abfe24d458f6b9915"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a6533ff91180a4c8abfe24d458f6b9915">PHYSFS_getWriteDir</a> (<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>)</td></tr>
<tr class="memdesc:a6533ff91180a4c8abfe24d458f6b9915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get path where PhysicsFS will allow file writing.  <br /></td></tr>
<tr class="separator:a6533ff91180a4c8abfe24d458f6b9915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c408d40b3a93c8f9fc02a16c02e430" id="r_a36c408d40b3a93c8f9fc02a16c02e430"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a36c408d40b3a93c8f9fc02a16c02e430">PHYSFS_setWriteDir</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *newDir)</td></tr>
<tr class="memdesc:a36c408d40b3a93c8f9fc02a16c02e430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell PhysicsFS where it may write files.  <br /></td></tr>
<tr class="separator:a36c408d40b3a93c8f9fc02a16c02e430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a677c869257742cbe5417dec9b3cee" id="r_ae9a677c869257742cbe5417dec9b3cee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#ae9a677c869257742cbe5417dec9b3cee">PHYSFS_addToSearchPath</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *newDir, int appendToPath) <a class="el" href="physfs_8h.html#aee5067c1fd0aa1cef18bc92b908a1348">PHYSFS_DEPRECATED</a></td></tr>
<tr class="memdesc:ae9a677c869257742cbe5417dec9b3cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an archive or directory to the search path.  <br /></td></tr>
<tr class="separator:ae9a677c869257742cbe5417dec9b3cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555ee86816418ed3a99e10243c5db7b8" id="r_a555ee86816418ed3a99e10243c5db7b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a555ee86816418ed3a99e10243c5db7b8">PHYSFS_removeFromSearchPath</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *oldDir) <a class="el" href="physfs_8h.html#aee5067c1fd0aa1cef18bc92b908a1348">PHYSFS_DEPRECATED</a></td></tr>
<tr class="memdesc:a555ee86816418ed3a99e10243c5db7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a directory or archive from the search path.  <br /></td></tr>
<tr class="separator:a555ee86816418ed3a99e10243c5db7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac738531e9c7e5ca3797b64985c103cf4" id="r_ac738531e9c7e5ca3797b64985c103cf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#ac738531e9c7e5ca3797b64985c103cf4">PHYSFS_getSearchPath</a> (<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>)</td></tr>
<tr class="memdesc:ac738531e9c7e5ca3797b64985c103cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current search path.  <br /></td></tr>
<tr class="separator:ac738531e9c7e5ca3797b64985c103cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef8700f714b6800ff688372c540bfe2" id="r_afef8700f714b6800ff688372c540bfe2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#afef8700f714b6800ff688372c540bfe2">PHYSFS_setSaneConfig</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *organization, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *appName, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *archiveExt, int includeCdRoms, int archivesFirst)</td></tr>
<tr class="memdesc:afef8700f714b6800ff688372c540bfe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up sane, default paths.  <br /></td></tr>
<tr class="separator:afef8700f714b6800ff688372c540bfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11fb98bf8c08a2e028f52ac9a728aa9" id="r_ae11fb98bf8c08a2e028f52ac9a728aa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#ae11fb98bf8c08a2e028f52ac9a728aa9">PHYSFS_mkdir</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *dirName)</td></tr>
<tr class="memdesc:ae11fb98bf8c08a2e028f52ac9a728aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a directory.  <br /></td></tr>
<tr class="separator:ae11fb98bf8c08a2e028f52ac9a728aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a939bce4c1132bacdfcb3d3cc29e37" id="r_a27a939bce4c1132bacdfcb3d3cc29e37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a27a939bce4c1132bacdfcb3d3cc29e37">PHYSFS_delete</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *filename)</td></tr>
<tr class="memdesc:a27a939bce4c1132bacdfcb3d3cc29e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a file or directory.  <br /></td></tr>
<tr class="separator:a27a939bce4c1132bacdfcb3d3cc29e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539bcf0ebde6271e3e4a90dd287ca975" id="r_a539bcf0ebde6271e3e4a90dd287ca975"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a539bcf0ebde6271e3e4a90dd287ca975">PHYSFS_getRealDir</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *filename)</td></tr>
<tr class="memdesc:a539bcf0ebde6271e3e4a90dd287ca975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Figure out where in the search path a file resides.  <br /></td></tr>
<tr class="separator:a539bcf0ebde6271e3e4a90dd287ca975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4ae950c2dae0735a91263ddd20fbf4" id="r_a0f4ae950c2dae0735a91263ddd20fbf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a0f4ae950c2dae0735a91263ddd20fbf4">PHYSFS_enumerateFiles</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *dir)</td></tr>
<tr class="memdesc:a0f4ae950c2dae0735a91263ddd20fbf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a file listing of a search path's directory.  <br /></td></tr>
<tr class="separator:a0f4ae950c2dae0735a91263ddd20fbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd31941b636ff153d328aebf72048c7" id="r_accd31941b636ff153d328aebf72048c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#accd31941b636ff153d328aebf72048c7">PHYSFS_exists</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *fname)</td></tr>
<tr class="memdesc:accd31941b636ff153d328aebf72048c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a file exists in the search path.  <br /></td></tr>
<tr class="separator:accd31941b636ff153d328aebf72048c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d98fb3544e0c554598d222efa74d4a" id="r_a50d98fb3544e0c554598d222efa74d4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a50d98fb3544e0c554598d222efa74d4a">PHYSFS_isDirectory</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *fname) <a class="el" href="physfs_8h.html#aee5067c1fd0aa1cef18bc92b908a1348">PHYSFS_DEPRECATED</a></td></tr>
<tr class="memdesc:a50d98fb3544e0c554598d222efa74d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a file in the search path is really a directory.  <br /></td></tr>
<tr class="separator:a50d98fb3544e0c554598d222efa74d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03e201cf5f91645cb5c4fda380295ff" id="r_ae03e201cf5f91645cb5c4fda380295ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#ae03e201cf5f91645cb5c4fda380295ff">PHYSFS_isSymbolicLink</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *fname) <a class="el" href="physfs_8h.html#aee5067c1fd0aa1cef18bc92b908a1348">PHYSFS_DEPRECATED</a></td></tr>
<tr class="memdesc:ae03e201cf5f91645cb5c4fda380295ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a file in the search path is really a symbolic link.  <br /></td></tr>
<tr class="separator:ae03e201cf5f91645cb5c4fda380295ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1023468c3de4be1cf24760b54dd9768" id="r_ae1023468c3de4be1cf24760b54dd9768"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#ae1023468c3de4be1cf24760b54dd9768">PHYSFS_getLastModTime</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *filename) <a class="el" href="physfs_8h.html#aee5067c1fd0aa1cef18bc92b908a1348">PHYSFS_DEPRECATED</a></td></tr>
<tr class="memdesc:ae1023468c3de4be1cf24760b54dd9768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last modification time of a file.  <br /></td></tr>
<tr class="separator:ae1023468c3de4be1cf24760b54dd9768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf92d66c6cb82d0ede969aa2c964fba" id="r_abbf92d66c6cb82d0ede969aa2c964fba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#abbf92d66c6cb82d0ede969aa2c964fba">PHYSFS_openWrite</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *filename)</td></tr>
<tr class="memdesc:abbf92d66c6cb82d0ede969aa2c964fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file for writing.  <br /></td></tr>
<tr class="separator:abbf92d66c6cb82d0ede969aa2c964fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeeca12e2fe7c5f68cbd67e2e5cafa3d" id="r_abeeca12e2fe7c5f68cbd67e2e5cafa3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#abeeca12e2fe7c5f68cbd67e2e5cafa3d">PHYSFS_openAppend</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *filename)</td></tr>
<tr class="memdesc:abeeca12e2fe7c5f68cbd67e2e5cafa3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file for appending.  <br /></td></tr>
<tr class="separator:abeeca12e2fe7c5f68cbd67e2e5cafa3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e38a425bb0b44c09ec25b105f770c63" id="r_a5e38a425bb0b44c09ec25b105f770c63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a5e38a425bb0b44c09ec25b105f770c63">PHYSFS_openRead</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *filename)</td></tr>
<tr class="memdesc:a5e38a425bb0b44c09ec25b105f770c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file for reading.  <br /></td></tr>
<tr class="separator:a5e38a425bb0b44c09ec25b105f770c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6822f8ff10073e855a1c3a6485b882f2" id="r_a6822f8ff10073e855a1c3a6485b882f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a6822f8ff10073e855a1c3a6485b882f2">PHYSFS_close</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *handle)</td></tr>
<tr class="memdesc:a6822f8ff10073e855a1c3a6485b882f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a PhysicsFS filehandle.  <br /></td></tr>
<tr class="separator:a6822f8ff10073e855a1c3a6485b882f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde67ddefb36e3b780cfd796d47c253d" id="r_abde67ddefb36e3b780cfd796d47c253d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#abde67ddefb36e3b780cfd796d47c253d">PHYSFS_read</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *handle, <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *buffer, <a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a> objSize, <a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a> objCount) <a class="el" href="physfs_8h.html#aee5067c1fd0aa1cef18bc92b908a1348">PHYSFS_DEPRECATED</a></td></tr>
<tr class="memdesc:abde67ddefb36e3b780cfd796d47c253d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from a PhysicsFS filehandle.  <br /></td></tr>
<tr class="separator:abde67ddefb36e3b780cfd796d47c253d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7bb76d39dadff2b72f9e4753139a62" id="r_aae7bb76d39dadff2b72f9e4753139a62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#aae7bb76d39dadff2b72f9e4753139a62">PHYSFS_write</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *handle, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *buffer, <a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a> objSize, <a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a> objCount) <a class="el" href="physfs_8h.html#aee5067c1fd0aa1cef18bc92b908a1348">PHYSFS_DEPRECATED</a></td></tr>
<tr class="memdesc:aae7bb76d39dadff2b72f9e4753139a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to a PhysicsFS filehandle.  <br /></td></tr>
<tr class="separator:aae7bb76d39dadff2b72f9e4753139a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7ac838797951323072060392645dbe" id="r_a6d7ac838797951323072060392645dbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a6d7ac838797951323072060392645dbe">PHYSFS_eof</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *handle)</td></tr>
<tr class="memdesc:a6d7ac838797951323072060392645dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for end-of-file state on a PhysicsFS filehandle.  <br /></td></tr>
<tr class="separator:a6d7ac838797951323072060392645dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d481bdd4cf32ed1a41540ee59840c24" id="r_a0d481bdd4cf32ed1a41540ee59840c24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a0d481bdd4cf32ed1a41540ee59840c24">PHYSFS_tell</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *handle)</td></tr>
<tr class="memdesc:a0d481bdd4cf32ed1a41540ee59840c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine current position within a PhysicsFS filehandle.  <br /></td></tr>
<tr class="separator:a0d481bdd4cf32ed1a41540ee59840c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae562b45b1e1b02505ce1d82ad785f04a" id="r_ae562b45b1e1b02505ce1d82ad785f04a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#ae562b45b1e1b02505ce1d82ad785f04a">PHYSFS_seek</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *handle, <a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> pos)</td></tr>
<tr class="memdesc:ae562b45b1e1b02505ce1d82ad785f04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek to a new position within a PhysicsFS filehandle.  <br /></td></tr>
<tr class="separator:ae562b45b1e1b02505ce1d82ad785f04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1d8b415d37d8040ca423ed29536fde" id="r_a3f1d8b415d37d8040ca423ed29536fde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a3f1d8b415d37d8040ca423ed29536fde">PHYSFS_fileLength</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *handle)</td></tr>
<tr class="memdesc:a3f1d8b415d37d8040ca423ed29536fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get total length of a file in bytes.  <br /></td></tr>
<tr class="separator:a3f1d8b415d37d8040ca423ed29536fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede5de47197e1a613d2091802befc886" id="r_aede5de47197e1a613d2091802befc886"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#aede5de47197e1a613d2091802befc886">PHYSFS_setBuffer</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *handle, <a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> bufsize)</td></tr>
<tr class="memdesc:aede5de47197e1a613d2091802befc886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up buffering for a PhysicsFS file handle.  <br /></td></tr>
<tr class="separator:aede5de47197e1a613d2091802befc886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd8f9cfdfd09f4fb778a386d8e97e8a" id="r_a3fd8f9cfdfd09f4fb778a386d8e97e8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a3fd8f9cfdfd09f4fb778a386d8e97e8a">PHYSFS_flush</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *handle)</td></tr>
<tr class="memdesc:a3fd8f9cfdfd09f4fb778a386d8e97e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush a buffered PhysicsFS file handle.  <br /></td></tr>
<tr class="separator:a3fd8f9cfdfd09f4fb778a386d8e97e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f900bb3ed3a2df81cf7c12b83b0fd4" id="r_a73f900bb3ed3a2df81cf7c12b83b0fd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="physfs_8h.html#aeed97311e1294c0b42648f99d331e5a0">PHYSFS_sint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a73f900bb3ed3a2df81cf7c12b83b0fd4">PHYSFS_swapSLE16</a> (<a class="el" href="physfs_8h.html#aeed97311e1294c0b42648f99d331e5a0">PHYSFS_sint16</a> <a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:a73f900bb3ed3a2df81cf7c12b83b0fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap littleendian signed 16 to platform's native byte order.  <br /></td></tr>
<tr class="separator:a73f900bb3ed3a2df81cf7c12b83b0fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9b90e29f097f4feaa4568ec405db01" id="r_acb9b90e29f097f4feaa4568ec405db01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#acb9b90e29f097f4feaa4568ec405db01">PHYSFS_swapULE16</a> (<a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a> <a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:acb9b90e29f097f4feaa4568ec405db01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap littleendian unsigned 16 to platform's native byte order.  <br /></td></tr>
<tr class="separator:acb9b90e29f097f4feaa4568ec405db01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b59892fb2846084a272c1bfc4aade4e" id="r_a9b59892fb2846084a272c1bfc4aade4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="physfs_8h.html#ae0264996863470a315e29d5a740a0f36">PHYSFS_sint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a9b59892fb2846084a272c1bfc4aade4e">PHYSFS_swapSLE32</a> (<a class="el" href="physfs_8h.html#ae0264996863470a315e29d5a740a0f36">PHYSFS_sint32</a> <a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:a9b59892fb2846084a272c1bfc4aade4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap littleendian signed 32 to platform's native byte order.  <br /></td></tr>
<tr class="separator:a9b59892fb2846084a272c1bfc4aade4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e86a4c1461dc47784e3f68034ad97c9" id="r_a6e86a4c1461dc47784e3f68034ad97c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a6e86a4c1461dc47784e3f68034ad97c9">PHYSFS_swapULE32</a> (<a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a> <a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:a6e86a4c1461dc47784e3f68034ad97c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap littleendian unsigned 32 to platform's native byte order.  <br /></td></tr>
<tr class="separator:a6e86a4c1461dc47784e3f68034ad97c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af032bd8e6116b2b3b6de279cb05b98a8" id="r_af032bd8e6116b2b3b6de279cb05b98a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#af032bd8e6116b2b3b6de279cb05b98a8">PHYSFS_swapSLE64</a> (<a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a> <a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:af032bd8e6116b2b3b6de279cb05b98a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap littleendian signed 64 to platform's native byte order.  <br /></td></tr>
<tr class="separator:af032bd8e6116b2b3b6de279cb05b98a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7249bf3cae48f1e04d99505011f280" id="r_a4b7249bf3cae48f1e04d99505011f280"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a4b7249bf3cae48f1e04d99505011f280">PHYSFS_swapULE64</a> (<a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> <a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:a4b7249bf3cae48f1e04d99505011f280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap littleendian unsigned 64 to platform's native byte order.  <br /></td></tr>
<tr class="separator:a4b7249bf3cae48f1e04d99505011f280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc8e4b9696316e25e3f6422910726c6" id="r_a5fc8e4b9696316e25e3f6422910726c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="physfs_8h.html#aeed97311e1294c0b42648f99d331e5a0">PHYSFS_sint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a5fc8e4b9696316e25e3f6422910726c6">PHYSFS_swapSBE16</a> (<a class="el" href="physfs_8h.html#aeed97311e1294c0b42648f99d331e5a0">PHYSFS_sint16</a> <a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:a5fc8e4b9696316e25e3f6422910726c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap bigendian signed 16 to platform's native byte order.  <br /></td></tr>
<tr class="separator:a5fc8e4b9696316e25e3f6422910726c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056321eea71215938431ad4501c2cf9c" id="r_a056321eea71215938431ad4501c2cf9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a056321eea71215938431ad4501c2cf9c">PHYSFS_swapUBE16</a> (<a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a> <a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:a056321eea71215938431ad4501c2cf9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap bigendian unsigned 16 to platform's native byte order.  <br /></td></tr>
<tr class="separator:a056321eea71215938431ad4501c2cf9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8908fb655aa60f0feb2f1662c93c8a0e" id="r_a8908fb655aa60f0feb2f1662c93c8a0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="physfs_8h.html#ae0264996863470a315e29d5a740a0f36">PHYSFS_sint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a8908fb655aa60f0feb2f1662c93c8a0e">PHYSFS_swapSBE32</a> (<a class="el" href="physfs_8h.html#ae0264996863470a315e29d5a740a0f36">PHYSFS_sint32</a> <a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:a8908fb655aa60f0feb2f1662c93c8a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap bigendian signed 32 to platform's native byte order.  <br /></td></tr>
<tr class="separator:a8908fb655aa60f0feb2f1662c93c8a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464ba8bc7f121e7f31423ad5d2ec6ed2" id="r_a464ba8bc7f121e7f31423ad5d2ec6ed2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a464ba8bc7f121e7f31423ad5d2ec6ed2">PHYSFS_swapUBE32</a> (<a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a> <a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:a464ba8bc7f121e7f31423ad5d2ec6ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap bigendian unsigned 32 to platform's native byte order.  <br /></td></tr>
<tr class="separator:a464ba8bc7f121e7f31423ad5d2ec6ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974af7dedc1125735efd9b14e23f20e6" id="r_a974af7dedc1125735efd9b14e23f20e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a974af7dedc1125735efd9b14e23f20e6">PHYSFS_swapSBE64</a> (<a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a> <a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:a974af7dedc1125735efd9b14e23f20e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap bigendian signed 64 to platform's native byte order.  <br /></td></tr>
<tr class="separator:a974af7dedc1125735efd9b14e23f20e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9b62d93cd121039c00554cb627a425" id="r_a6c9b62d93cd121039c00554cb627a425"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a6c9b62d93cd121039c00554cb627a425">PHYSFS_swapUBE64</a> (<a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> <a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:a6c9b62d93cd121039c00554cb627a425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap bigendian unsigned 64 to platform's native byte order.  <br /></td></tr>
<tr class="separator:a6c9b62d93cd121039c00554cb627a425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0959e10405416c139aad78dbc21617a0" id="r_a0959e10405416c139aad78dbc21617a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a0959e10405416c139aad78dbc21617a0">PHYSFS_readSLE16</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *file, <a class="el" href="physfs_8h.html#aeed97311e1294c0b42648f99d331e5a0">PHYSFS_sint16</a> *<a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:a0959e10405416c139aad78dbc21617a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and convert a signed 16-bit littleendian value.  <br /></td></tr>
<tr class="separator:a0959e10405416c139aad78dbc21617a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13248f4af186eda3983831dd8632da1" id="r_af13248f4af186eda3983831dd8632da1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#af13248f4af186eda3983831dd8632da1">PHYSFS_readULE16</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *file, <a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a> *<a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:af13248f4af186eda3983831dd8632da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and convert an unsigned 16-bit littleendian value.  <br /></td></tr>
<tr class="separator:af13248f4af186eda3983831dd8632da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad524c869540cc428264c318330a89144" id="r_ad524c869540cc428264c318330a89144"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#ad524c869540cc428264c318330a89144">PHYSFS_readSBE16</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *file, <a class="el" href="physfs_8h.html#aeed97311e1294c0b42648f99d331e5a0">PHYSFS_sint16</a> *<a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:ad524c869540cc428264c318330a89144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and convert a signed 16-bit bigendian value.  <br /></td></tr>
<tr class="separator:ad524c869540cc428264c318330a89144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083c97d848b89e08f6529c31cd7dba67" id="r_a083c97d848b89e08f6529c31cd7dba67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a083c97d848b89e08f6529c31cd7dba67">PHYSFS_readUBE16</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *file, <a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a> *<a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:a083c97d848b89e08f6529c31cd7dba67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and convert an unsigned 16-bit bigendian value.  <br /></td></tr>
<tr class="separator:a083c97d848b89e08f6529c31cd7dba67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2bfb4e8204c99f75642c4833e18566" id="r_a2e2bfb4e8204c99f75642c4833e18566"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a2e2bfb4e8204c99f75642c4833e18566">PHYSFS_readSLE32</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *file, <a class="el" href="physfs_8h.html#ae0264996863470a315e29d5a740a0f36">PHYSFS_sint32</a> *<a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:a2e2bfb4e8204c99f75642c4833e18566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and convert a signed 32-bit littleendian value.  <br /></td></tr>
<tr class="separator:a2e2bfb4e8204c99f75642c4833e18566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef7cf2fb6311b0bc9d39634b4088545" id="r_adef7cf2fb6311b0bc9d39634b4088545"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#adef7cf2fb6311b0bc9d39634b4088545">PHYSFS_readULE32</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *file, <a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a> *<a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:adef7cf2fb6311b0bc9d39634b4088545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and convert an unsigned 32-bit littleendian value.  <br /></td></tr>
<tr class="separator:adef7cf2fb6311b0bc9d39634b4088545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2bc016ea5dbe2a91479045576e644d" id="r_aab2bc016ea5dbe2a91479045576e644d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#aab2bc016ea5dbe2a91479045576e644d">PHYSFS_readSBE32</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *file, <a class="el" href="physfs_8h.html#ae0264996863470a315e29d5a740a0f36">PHYSFS_sint32</a> *<a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:aab2bc016ea5dbe2a91479045576e644d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and convert a signed 32-bit bigendian value.  <br /></td></tr>
<tr class="separator:aab2bc016ea5dbe2a91479045576e644d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357b5757a9483ef893977761d7d3fc1e" id="r_a357b5757a9483ef893977761d7d3fc1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a357b5757a9483ef893977761d7d3fc1e">PHYSFS_readUBE32</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *file, <a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a> *<a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:a357b5757a9483ef893977761d7d3fc1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and convert an unsigned 32-bit bigendian value.  <br /></td></tr>
<tr class="separator:a357b5757a9483ef893977761d7d3fc1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae916644039fad7ae4cb7d81440150d35" id="r_ae916644039fad7ae4cb7d81440150d35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#ae916644039fad7ae4cb7d81440150d35">PHYSFS_readSLE64</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *file, <a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a> *<a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:ae916644039fad7ae4cb7d81440150d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and convert a signed 64-bit littleendian value.  <br /></td></tr>
<tr class="separator:ae916644039fad7ae4cb7d81440150d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72ad9e14404add23d432838f4e9f35a" id="r_ae72ad9e14404add23d432838f4e9f35a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#ae72ad9e14404add23d432838f4e9f35a">PHYSFS_readULE64</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *file, <a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> *<a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:ae72ad9e14404add23d432838f4e9f35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and convert an unsigned 64-bit littleendian value.  <br /></td></tr>
<tr class="separator:ae72ad9e14404add23d432838f4e9f35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04eabd9e8da4265ede4018b24d4a39b1" id="r_a04eabd9e8da4265ede4018b24d4a39b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a04eabd9e8da4265ede4018b24d4a39b1">PHYSFS_readSBE64</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *file, <a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a> *<a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:a04eabd9e8da4265ede4018b24d4a39b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and convert a signed 64-bit bigendian value.  <br /></td></tr>
<tr class="separator:a04eabd9e8da4265ede4018b24d4a39b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380430eda70acd8728930a2f1256c071" id="r_a380430eda70acd8728930a2f1256c071"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a380430eda70acd8728930a2f1256c071">PHYSFS_readUBE64</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *file, <a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> *<a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:a380430eda70acd8728930a2f1256c071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and convert an unsigned 64-bit bigendian value.  <br /></td></tr>
<tr class="separator:a380430eda70acd8728930a2f1256c071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaee4b15c4d683a1996ffc72d1d2a6aa" id="r_aeaee4b15c4d683a1996ffc72d1d2a6aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#aeaee4b15c4d683a1996ffc72d1d2a6aa">PHYSFS_writeSLE16</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *file, <a class="el" href="physfs_8h.html#aeed97311e1294c0b42648f99d331e5a0">PHYSFS_sint16</a> <a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:aeaee4b15c4d683a1996ffc72d1d2a6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and write a signed 16-bit littleendian value.  <br /></td></tr>
<tr class="separator:aeaee4b15c4d683a1996ffc72d1d2a6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6bdd5da0e7466b2bace0c914bcf3ac" id="r_add6bdd5da0e7466b2bace0c914bcf3ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#add6bdd5da0e7466b2bace0c914bcf3ac">PHYSFS_writeULE16</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *file, <a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a> <a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:add6bdd5da0e7466b2bace0c914bcf3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and write an unsigned 16-bit littleendian value.  <br /></td></tr>
<tr class="separator:add6bdd5da0e7466b2bace0c914bcf3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621ed6d4cb61f9f31efb58acbe3090e3" id="r_a621ed6d4cb61f9f31efb58acbe3090e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a621ed6d4cb61f9f31efb58acbe3090e3">PHYSFS_writeSBE16</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *file, <a class="el" href="physfs_8h.html#aeed97311e1294c0b42648f99d331e5a0">PHYSFS_sint16</a> <a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:a621ed6d4cb61f9f31efb58acbe3090e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and write a signed 16-bit bigendian value.  <br /></td></tr>
<tr class="separator:a621ed6d4cb61f9f31efb58acbe3090e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a392f7637bb2ad4c3e395e1a71c54e" id="r_a66a392f7637bb2ad4c3e395e1a71c54e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a66a392f7637bb2ad4c3e395e1a71c54e">PHYSFS_writeUBE16</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *file, <a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a> <a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:a66a392f7637bb2ad4c3e395e1a71c54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and write an unsigned 16-bit bigendian value.  <br /></td></tr>
<tr class="separator:a66a392f7637bb2ad4c3e395e1a71c54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a702d04d16b0fa732905b0e7daab407" id="r_a3a702d04d16b0fa732905b0e7daab407"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a3a702d04d16b0fa732905b0e7daab407">PHYSFS_writeSLE32</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *file, <a class="el" href="physfs_8h.html#ae0264996863470a315e29d5a740a0f36">PHYSFS_sint32</a> <a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:a3a702d04d16b0fa732905b0e7daab407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and write a signed 32-bit littleendian value.  <br /></td></tr>
<tr class="separator:a3a702d04d16b0fa732905b0e7daab407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9566e5d04e793b851dc7b9c26f3b23cb" id="r_a9566e5d04e793b851dc7b9c26f3b23cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a9566e5d04e793b851dc7b9c26f3b23cb">PHYSFS_writeULE32</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *file, <a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a> <a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:a9566e5d04e793b851dc7b9c26f3b23cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and write an unsigned 32-bit littleendian value.  <br /></td></tr>
<tr class="separator:a9566e5d04e793b851dc7b9c26f3b23cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065910571b8d1bc82eb6ef8e93936028" id="r_a065910571b8d1bc82eb6ef8e93936028"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a065910571b8d1bc82eb6ef8e93936028">PHYSFS_writeSBE32</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *file, <a class="el" href="physfs_8h.html#ae0264996863470a315e29d5a740a0f36">PHYSFS_sint32</a> <a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:a065910571b8d1bc82eb6ef8e93936028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and write a signed 32-bit bigendian value.  <br /></td></tr>
<tr class="separator:a065910571b8d1bc82eb6ef8e93936028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a497bc47cb177fe1bf835abe28baad" id="r_a98a497bc47cb177fe1bf835abe28baad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a98a497bc47cb177fe1bf835abe28baad">PHYSFS_writeUBE32</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *file, <a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a> <a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:a98a497bc47cb177fe1bf835abe28baad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and write an unsigned 32-bit bigendian value.  <br /></td></tr>
<tr class="separator:a98a497bc47cb177fe1bf835abe28baad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48f7be67e4d68315709e7b3fa48f34b" id="r_ab48f7be67e4d68315709e7b3fa48f34b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#ab48f7be67e4d68315709e7b3fa48f34b">PHYSFS_writeSLE64</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *file, <a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a> <a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:ab48f7be67e4d68315709e7b3fa48f34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and write a signed 64-bit littleendian value.  <br /></td></tr>
<tr class="separator:ab48f7be67e4d68315709e7b3fa48f34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb795dbdde0fb87fbc8b92471fb85ab" id="r_aaeb795dbdde0fb87fbc8b92471fb85ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#aaeb795dbdde0fb87fbc8b92471fb85ab">PHYSFS_writeULE64</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *file, <a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> <a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:aaeb795dbdde0fb87fbc8b92471fb85ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and write an unsigned 64-bit littleendian value.  <br /></td></tr>
<tr class="separator:aaeb795dbdde0fb87fbc8b92471fb85ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f40bbc37733f52fde58e7a5bc55341" id="r_ab5f40bbc37733f52fde58e7a5bc55341"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#ab5f40bbc37733f52fde58e7a5bc55341">PHYSFS_writeSBE64</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *file, <a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a> <a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:ab5f40bbc37733f52fde58e7a5bc55341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and write a signed 64-bit bigending value.  <br /></td></tr>
<tr class="separator:ab5f40bbc37733f52fde58e7a5bc55341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03fc124e5dfd2801361eeefcee7d1ff7" id="r_a03fc124e5dfd2801361eeefcee7d1ff7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a03fc124e5dfd2801361eeefcee7d1ff7">PHYSFS_writeUBE64</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *file, <a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> <a class="el" href="jpeglib_8h.html#aa0ccb5ee6d882ee3605ff47745c6467b">val</a>)</td></tr>
<tr class="memdesc:a03fc124e5dfd2801361eeefcee7d1ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and write an unsigned 64-bit bigendian value.  <br /></td></tr>
<tr class="separator:a03fc124e5dfd2801361eeefcee7d1ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6154be7bfa5d924476356a9fbd0d8223" id="r_a6154be7bfa5d924476356a9fbd0d8223"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a6154be7bfa5d924476356a9fbd0d8223">PHYSFS_isInit</a> (<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>)</td></tr>
<tr class="memdesc:a6154be7bfa5d924476356a9fbd0d8223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the PhysicsFS library is initialized.  <br /></td></tr>
<tr class="separator:a6154be7bfa5d924476356a9fbd0d8223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5223ccbe06246dd5379d6a57d6cd0d87" id="r_a5223ccbe06246dd5379d6a57d6cd0d87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a5223ccbe06246dd5379d6a57d6cd0d87">PHYSFS_symbolicLinksPermitted</a> (<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>)</td></tr>
<tr class="memdesc:a5223ccbe06246dd5379d6a57d6cd0d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the symbolic links are permitted.  <br /></td></tr>
<tr class="separator:a5223ccbe06246dd5379d6a57d6cd0d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6297d1ae7755b9236b01950bfbb0ef1" id="r_ae6297d1ae7755b9236b01950bfbb0ef1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#ae6297d1ae7755b9236b01950bfbb0ef1">PHYSFS_setAllocator</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="struct_p_h_y_s_f_s___allocator.html">PHYSFS_Allocator</a> *allocator)</td></tr>
<tr class="memdesc:ae6297d1ae7755b9236b01950bfbb0ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook your own allocation routines into PhysicsFS.  <br /></td></tr>
<tr class="separator:ae6297d1ae7755b9236b01950bfbb0ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb320e9af03dcdb4c05bbff3ea604d4" id="r_a8eb320e9af03dcdb4c05bbff3ea604d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a8eb320e9af03dcdb4c05bbff3ea604d4">PHYSFS_mount</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *newDir, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *mountPoint, int appendToPath)</td></tr>
<tr class="memdesc:a8eb320e9af03dcdb4c05bbff3ea604d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an archive or directory to the search path.  <br /></td></tr>
<tr class="separator:a8eb320e9af03dcdb4c05bbff3ea604d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365aee0c326b0e6bfbba5c039f7c4b5b" id="r_a365aee0c326b0e6bfbba5c039f7c4b5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a365aee0c326b0e6bfbba5c039f7c4b5b">PHYSFS_getMountPoint</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *dir)</td></tr>
<tr class="memdesc:a365aee0c326b0e6bfbba5c039f7c4b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine a mounted archive's mountpoint.  <br /></td></tr>
<tr class="separator:a365aee0c326b0e6bfbba5c039f7c4b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace04dfd0654ce55a81a85f57f56c7410" id="r_ace04dfd0654ce55a81a85f57f56c7410"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#ace04dfd0654ce55a81a85f57f56c7410">PHYSFS_getCdRomDirsCallback</a> (<a class="el" href="physfs_8h.html#a6331ac65f8e0d32288f8597e48188a4f">PHYSFS_StringCallback</a> c, <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *d)</td></tr>
<tr class="memdesc:ace04dfd0654ce55a81a85f57f56c7410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate CD-ROM directories, using an application-defined callback.  <br /></td></tr>
<tr class="separator:ace04dfd0654ce55a81a85f57f56c7410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5f7188ab27722b0651e7503c6a737a" id="r_abd5f7188ab27722b0651e7503c6a737a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#abd5f7188ab27722b0651e7503c6a737a">PHYSFS_getSearchPathCallback</a> (<a class="el" href="physfs_8h.html#a6331ac65f8e0d32288f8597e48188a4f">PHYSFS_StringCallback</a> c, <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *d)</td></tr>
<tr class="memdesc:abd5f7188ab27722b0651e7503c6a737a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate the search path, using an application-defined callback.  <br /></td></tr>
<tr class="separator:abd5f7188ab27722b0651e7503c6a737a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fefcc5c7d198db415007a842a8eae5" id="r_a56fefcc5c7d198db415007a842a8eae5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a56fefcc5c7d198db415007a842a8eae5">PHYSFS_enumerateFilesCallback</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *dir, <a class="el" href="physfs_8h.html#a51c1e0145502aeaf080973d308d33c6a">PHYSFS_EnumFilesCallback</a> c, <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *d) <a class="el" href="physfs_8h.html#aee5067c1fd0aa1cef18bc92b908a1348">PHYSFS_DEPRECATED</a></td></tr>
<tr class="memdesc:a56fefcc5c7d198db415007a842a8eae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a file listing of a search path's directory, using an application-defined callback.  <br /></td></tr>
<tr class="separator:a56fefcc5c7d198db415007a842a8eae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18c9c45db1be6fd26be19d0f4d25a60" id="r_ac18c9c45db1be6fd26be19d0f4d25a60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#ac18c9c45db1be6fd26be19d0f4d25a60">PHYSFS_utf8FromUcs4</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a> *src, char *dst, <a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> len)</td></tr>
<tr class="memdesc:ac18c9c45db1be6fd26be19d0f4d25a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a UCS-4 string to a UTF-8 string.  <br /></td></tr>
<tr class="separator:ac18c9c45db1be6fd26be19d0f4d25a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff1045e71cd4c14607973da7bfc41e5" id="r_a3ff1045e71cd4c14607973da7bfc41e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a3ff1045e71cd4c14607973da7bfc41e5">PHYSFS_utf8ToUcs4</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *src, <a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a> *dst, <a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> len)</td></tr>
<tr class="memdesc:a3ff1045e71cd4c14607973da7bfc41e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a UTF-8 string to a UCS-4 string.  <br /></td></tr>
<tr class="separator:a3ff1045e71cd4c14607973da7bfc41e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4fdac7e09fb03ccdccdeed997f09c1a" id="r_ac4fdac7e09fb03ccdccdeed997f09c1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#ac4fdac7e09fb03ccdccdeed997f09c1a">PHYSFS_utf8FromUcs2</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a> *src, char *dst, <a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> len)</td></tr>
<tr class="memdesc:ac4fdac7e09fb03ccdccdeed997f09c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a UCS-2 string to a UTF-8 string.  <br /></td></tr>
<tr class="separator:ac4fdac7e09fb03ccdccdeed997f09c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab51c265f7ca4e8218d6c74b4f43401" id="r_a0ab51c265f7ca4e8218d6c74b4f43401"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a0ab51c265f7ca4e8218d6c74b4f43401">PHYSFS_utf8ToUcs2</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *src, <a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a> *dst, <a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> len)</td></tr>
<tr class="memdesc:a0ab51c265f7ca4e8218d6c74b4f43401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a UTF-8 string to a UCS-2 string.  <br /></td></tr>
<tr class="separator:a0ab51c265f7ca4e8218d6c74b4f43401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2838ad1240439afd3a21109ea7138014" id="r_a2838ad1240439afd3a21109ea7138014"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a2838ad1240439afd3a21109ea7138014">PHYSFS_utf8FromLatin1</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *src, char *dst, <a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> len)</td></tr>
<tr class="memdesc:a2838ad1240439afd3a21109ea7138014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a UTF-8 string to a Latin1 string.  <br /></td></tr>
<tr class="separator:a2838ad1240439afd3a21109ea7138014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3845b57434e52e82f6ae8b6a0fe13f26" id="r_a3845b57434e52e82f6ae8b6a0fe13f26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a3845b57434e52e82f6ae8b6a0fe13f26">PHYSFS_caseFold</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a> from, <a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a> *to)</td></tr>
<tr class="memdesc:a3845b57434e52e82f6ae8b6a0fe13f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Fold" a Unicode codepoint to a lowercase equivalent.  <br /></td></tr>
<tr class="separator:a3845b57434e52e82f6ae8b6a0fe13f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84e68e54bb3b4df8161ea10d03db182" id="r_aa84e68e54bb3b4df8161ea10d03db182"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#aa84e68e54bb3b4df8161ea10d03db182">PHYSFS_utf8stricmp</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *str1, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *str2)</td></tr>
<tr class="memdesc:aa84e68e54bb3b4df8161ea10d03db182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Case-insensitive compare of two UTF-8 strings.  <br /></td></tr>
<tr class="separator:aa84e68e54bb3b4df8161ea10d03db182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103f6e35c87cd635d5082b6cffd7974b" id="r_a103f6e35c87cd635d5082b6cffd7974b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a103f6e35c87cd635d5082b6cffd7974b">PHYSFS_utf16stricmp</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a> *str1, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a> *str2)</td></tr>
<tr class="memdesc:a103f6e35c87cd635d5082b6cffd7974b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Case-insensitive compare of two UTF-16 strings.  <br /></td></tr>
<tr class="separator:a103f6e35c87cd635d5082b6cffd7974b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3753f0ac8e6a57ac438912ac68e97aa" id="r_ad3753f0ac8e6a57ac438912ac68e97aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#ad3753f0ac8e6a57ac438912ac68e97aa">PHYSFS_ucs4stricmp</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a> *str1, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a> *str2)</td></tr>
<tr class="memdesc:ad3753f0ac8e6a57ac438912ac68e97aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Case-insensitive compare of two UCS-4 strings.  <br /></td></tr>
<tr class="separator:ad3753f0ac8e6a57ac438912ac68e97aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33085cbbf18ba7eb659cf2a43d6793ba" id="r_a33085cbbf18ba7eb659cf2a43d6793ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a33085cbbf18ba7eb659cf2a43d6793ba">PHYSFS_enumerate</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *dir, <a class="el" href="physfs_8h.html#a1e72dbc92c0decdca218c8a9a658e788">PHYSFS_EnumerateCallback</a> c, <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *d)</td></tr>
<tr class="memdesc:a33085cbbf18ba7eb659cf2a43d6793ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a file listing of a search path's directory, using an application-defined callback, with errors reported.  <br /></td></tr>
<tr class="separator:a33085cbbf18ba7eb659cf2a43d6793ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0e2ba90aa918b2ee1ed7c40293b442" id="r_aab0e2ba90aa918b2ee1ed7c40293b442"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#aab0e2ba90aa918b2ee1ed7c40293b442">PHYSFS_unmount</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *oldDir)</td></tr>
<tr class="memdesc:aab0e2ba90aa918b2ee1ed7c40293b442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a directory or archive from the search path.  <br /></td></tr>
<tr class="separator:aab0e2ba90aa918b2ee1ed7c40293b442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1ce4636c87fdb6e080b1376fd7b25e" id="r_aaa1ce4636c87fdb6e080b1376fd7b25e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="struct_p_h_y_s_f_s___allocator.html">PHYSFS_Allocator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#aaa1ce4636c87fdb6e080b1376fd7b25e">PHYSFS_getAllocator</a> (<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>)</td></tr>
<tr class="memdesc:aaa1ce4636c87fdb6e080b1376fd7b25e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_discover.html">Discover</a> the current allocator.  <br /></td></tr>
<tr class="separator:aaa1ce4636c87fdb6e080b1376fd7b25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5e23675c50ffe51ad00cceb5a65348" id="r_a7f5e23675c50ffe51ad00cceb5a65348"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a7f5e23675c50ffe51ad00cceb5a65348">PHYSFS_stat</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *fname, <a class="el" href="struct_p_h_y_s_f_s___stat.html">PHYSFS_Stat</a> *stat)</td></tr>
<tr class="memdesc:a7f5e23675c50ffe51ad00cceb5a65348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get various information about a directory or a file.  <br /></td></tr>
<tr class="separator:a7f5e23675c50ffe51ad00cceb5a65348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad1e7ea73fb2108e136fc043d9c4b30" id="r_abad1e7ea73fb2108e136fc043d9c4b30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#abad1e7ea73fb2108e136fc043d9c4b30">PHYSFS_utf8FromUtf16</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a> *src, char *dst, <a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> len)</td></tr>
<tr class="memdesc:abad1e7ea73fb2108e136fc043d9c4b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a UTF-16 string to a UTF-8 string.  <br /></td></tr>
<tr class="separator:abad1e7ea73fb2108e136fc043d9c4b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adebf3f8244318c47e061f780ca8882f9" id="r_adebf3f8244318c47e061f780ca8882f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#adebf3f8244318c47e061f780ca8882f9">PHYSFS_utf8ToUtf16</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *src, <a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a> *dst, <a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> len)</td></tr>
<tr class="memdesc:adebf3f8244318c47e061f780ca8882f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a UTF-8 string to a UTF-16 string.  <br /></td></tr>
<tr class="separator:adebf3f8244318c47e061f780ca8882f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ac40ecdb3f9b91e6ee309bdbad0ce8" id="r_a63ac40ecdb3f9b91e6ee309bdbad0ce8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a63ac40ecdb3f9b91e6ee309bdbad0ce8">PHYSFS_readBytes</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *handle, <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *buffer, <a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> len)</td></tr>
<tr class="memdesc:a63ac40ecdb3f9b91e6ee309bdbad0ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bytes from a PhysicsFS filehandle.  <br /></td></tr>
<tr class="separator:a63ac40ecdb3f9b91e6ee309bdbad0ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192ae4f946656ae2aef5e16e438f94e1" id="r_a192ae4f946656ae2aef5e16e438f94e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a192ae4f946656ae2aef5e16e438f94e1">PHYSFS_writeBytes</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *handle, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *buffer, <a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> len)</td></tr>
<tr class="memdesc:a192ae4f946656ae2aef5e16e438f94e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to a PhysicsFS filehandle.  <br /></td></tr>
<tr class="separator:a192ae4f946656ae2aef5e16e438f94e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac107cf895f50f0d2219cdf44b8b758" id="r_a7ac107cf895f50f0d2219cdf44b8b758"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a7ac107cf895f50f0d2219cdf44b8b758">PHYSFS_mountIo</a> (<a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *io, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *newDir, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *mountPoint, int appendToPath)</td></tr>
<tr class="memdesc:a7ac107cf895f50f0d2219cdf44b8b758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an archive, built on a <a class="el" href="struct_p_h_y_s_f_s___io.html" title="An abstract i/o interface.">PHYSFS_Io</a>, to the search path.  <br /></td></tr>
<tr class="separator:a7ac107cf895f50f0d2219cdf44b8b758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a977d04da585859e132ba4700df5d3a" id="r_a0a977d04da585859e132ba4700df5d3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a0a977d04da585859e132ba4700df5d3a">PHYSFS_mountMemory</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *buf, <a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> len, <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>(*del)(<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *), <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *newDir, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *mountPoint, int appendToPath)</td></tr>
<tr class="memdesc:a0a977d04da585859e132ba4700df5d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an archive, contained in a memory buffer, to the search path.  <br /></td></tr>
<tr class="separator:a0a977d04da585859e132ba4700df5d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05407734c567ced1cffce64c6b1f0e93" id="r_a05407734c567ced1cffce64c6b1f0e93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a05407734c567ced1cffce64c6b1f0e93">PHYSFS_mountHandle</a> (<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *file, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *newDir, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *mountPoint, int appendToPath)</td></tr>
<tr class="memdesc:a05407734c567ced1cffce64c6b1f0e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an archive, contained in a <a class="el" href="struct_p_h_y_s_f_s___file.html" title="A PhysicsFS file handle.">PHYSFS_File</a> handle, to the search path.  <br /></td></tr>
<tr class="separator:a05407734c567ced1cffce64c6b1f0e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae916a873aae2cf6b6e09d733cd1b3f4b" id="r_ae916a873aae2cf6b6e09d733cd1b3f4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afed">PHYSFS_ErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b">PHYSFS_getLastErrorCode</a> (<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>)</td></tr>
<tr class="memdesc:ae916a873aae2cf6b6e09d733cd1b3f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get machine-readable error information.  <br /></td></tr>
<tr class="separator:ae916a873aae2cf6b6e09d733cd1b3f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545f6b5ba97faa19441932dffb65c3be" id="r_a545f6b5ba97faa19441932dffb65c3be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#a545f6b5ba97faa19441932dffb65c3be">PHYSFS_getErrorByCode</a> (<a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afed">PHYSFS_ErrorCode</a> code)</td></tr>
<tr class="memdesc:a545f6b5ba97faa19441932dffb65c3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get human-readable description string for a given error code.  <br /></td></tr>
<tr class="separator:a545f6b5ba97faa19441932dffb65c3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2c854542c68abc2015649fadd3a623" id="r_ade2c854542c68abc2015649fadd3a623"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#ade2c854542c68abc2015649fadd3a623">PHYSFS_setErrorCode</a> (<a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afed">PHYSFS_ErrorCode</a> code)</td></tr>
<tr class="memdesc:ade2c854542c68abc2015649fadd3a623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current thread's error code.  <br /></td></tr>
<tr class="separator:ade2c854542c68abc2015649fadd3a623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd87392d234d070695303521bb8052a5" id="r_acd87392d234d070695303521bb8052a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#acd87392d234d070695303521bb8052a5">PHYSFS_getPrefDir</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *org, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *app)</td></tr>
<tr class="memdesc:acd87392d234d070695303521bb8052a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the user-and-app-specific path where files can be written.  <br /></td></tr>
<tr class="separator:acd87392d234d070695303521bb8052a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0ecda857dc622e2d005af02972237d" id="r_ace0ecda857dc622e2d005af02972237d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#ace0ecda857dc622e2d005af02972237d">PHYSFS_registerArchiver</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="struct_p_h_y_s_f_s___archiver.html">PHYSFS_Archiver</a> *archiver)</td></tr>
<tr class="memdesc:ace0ecda857dc622e2d005af02972237d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new archiver to the system.  <br /></td></tr>
<tr class="separator:ace0ecda857dc622e2d005af02972237d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc7cce9112c5ddc2f3a9ad5d0edf6e0" id="r_abbc7cce9112c5ddc2f3a9ad5d0edf6e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#a7c7073ec1126c2f7661a9fde8f67f8b8">PHYSFS_DECL</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="physfs_8h.html#abbc7cce9112c5ddc2f3a9ad5d0edf6e0">PHYSFS_deregisterArchiver</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *ext)</td></tr>
<tr class="memdesc:abbc7cce9112c5ddc2f3a9ad5d0edf6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an archiver from the system.  <br /></td></tr>
<tr class="separator:abbc7cce9112c5ddc2f3a9ad5d0edf6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main header file for PhysicsFS. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="acc2e28137976625c89ae24b2778567e3" name="acc2e28137976625c89ae24b2778567e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2e28137976625c89ae24b2778567e3">&#9670;&#160;</a></span>PHYSFS_COMPILE_TIME_ASSERT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PHYSFS_COMPILE_TIME_ASSERT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="fmaths_8inl.html#a7ba8ab2f1e8f362163e17da3f15a5db9">x</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;       typedef int PHYSFS_compile_time_assert_##name[(<a class="el" href="fmaths_8inl.html#a7ba8ab2f1e8f362163e17da3f15a5db9">x</a>) * 2 - 1]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c7073ec1126c2f7661a9fde8f67f8b8" name="a7c7073ec1126c2f7661a9fde8f67f8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7073ec1126c2f7661a9fde8f67f8b8">&#9670;&#160;</a></span>PHYSFS_DECL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PHYSFS_DECL</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee5067c1fd0aa1cef18bc92b908a1348" name="aee5067c1fd0aa1cef18bc92b908a1348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee5067c1fd0aa1cef18bc92b908a1348">&#9670;&#160;</a></span>PHYSFS_DEPRECATED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PHYSFS_DEPRECATED</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad32c738a1a111f0d3f29e4637633bfd1" name="ad32c738a1a111f0d3f29e4637633bfd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32c738a1a111f0d3f29e4637633bfd1">&#9670;&#160;</a></span>PHYSFS_file</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PHYSFS_file&#160;&#160;&#160;<a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1.0 API compatibility define. </p>
<p>PHYSFS_file is identical to <a class="el" href="struct_p_h_y_s_f_s___file.html" title="A PhysicsFS file handle.">PHYSFS_File</a>. This #define is here for backwards compatibility with the 1.0 API, which had an inconsistent capitalization convention in this case. New code should use <a class="el" href="struct_p_h_y_s_f_s___file.html" title="A PhysicsFS file handle.">PHYSFS_File</a>, as this #define may go away someday.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_p_h_y_s_f_s___file.html" title="A PhysicsFS file handle.">PHYSFS_File</a> </dd></dl>

</div>
</div>
<a id="abc0b94a8f06bc69bd18d741b3e66dfa4" name="abc0b94a8f06bc69bd18d741b3e66dfa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc0b94a8f06bc69bd18d741b3e66dfa4">&#9670;&#160;</a></span>PHYSFS_VER_MAJOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PHYSFS_VER_MAJOR&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30f53f1b74ad284d3e7e56d270e449ba" name="a30f53f1b74ad284d3e7e56d270e449ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f53f1b74ad284d3e7e56d270e449ba">&#9670;&#160;</a></span>PHYSFS_VER_MINOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PHYSFS_VER_MINOR&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c9cc71df9b5802460d7b9bb08c3b5fe" name="a0c9cc71df9b5802460d7b9bb08c3b5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9cc71df9b5802460d7b9bb08c3b5fe">&#9670;&#160;</a></span>PHYSFS_VER_PATCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PHYSFS_VER_PATCH&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb77c1f8f70028add43b9f81eef1ed78" name="acb77c1f8f70028add43b9f81eef1ed78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb77c1f8f70028add43b9f81eef1ed78">&#9670;&#160;</a></span>PHYSFS_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PHYSFS_VERSION</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="fmaths_8inl.html#a7ba8ab2f1e8f362163e17da3f15a5db9">x</a></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ \</div>
<div class="line">    (<a class="code hl_variable" href="fmaths_8inl.html#a7ba8ab2f1e8f362163e17da3f15a5db9">x</a>)-&gt;major = <a class="code hl_define" href="physfs_8h.html#abc0b94a8f06bc69bd18d741b3e66dfa4">PHYSFS_VER_MAJOR</a>; \</div>
<div class="line">    (<a class="code hl_variable" href="fmaths_8inl.html#a7ba8ab2f1e8f362163e17da3f15a5db9">x</a>)-&gt;minor = <a class="code hl_define" href="physfs_8h.html#a30f53f1b74ad284d3e7e56d270e449ba">PHYSFS_VER_MINOR</a>; \</div>
<div class="line">    (<a class="code hl_variable" href="fmaths_8inl.html#a7ba8ab2f1e8f362163e17da3f15a5db9">x</a>)-&gt;patch = <a class="code hl_define" href="physfs_8h.html#a0c9cc71df9b5802460d7b9bb08c3b5fe">PHYSFS_VER_PATCH</a>; \</div>
<div class="line">}</div>
<div class="ttc" id="afmaths_8inl_html_a7ba8ab2f1e8f362163e17da3f15a5db9"><div class="ttname"><a href="fmaths_8inl.html#a7ba8ab2f1e8f362163e17da3f15a5db9">x</a></div><div class="ttdeci">al_fixed x</div><div class="ttdef"><b>Definition</b> fmaths.inl:46</div></div>
<div class="ttc" id="aphysfs_8h_html_a0c9cc71df9b5802460d7b9bb08c3b5fe"><div class="ttname"><a href="physfs_8h.html#a0c9cc71df9b5802460d7b9bb08c3b5fe">PHYSFS_VER_PATCH</a></div><div class="ttdeci">#define PHYSFS_VER_PATCH</div><div class="ttdef"><b>Definition</b> physfs.h:437</div></div>
<div class="ttc" id="aphysfs_8h_html_a30f53f1b74ad284d3e7e56d270e449ba"><div class="ttname"><a href="physfs_8h.html#a30f53f1b74ad284d3e7e56d270e449ba">PHYSFS_VER_MINOR</a></div><div class="ttdeci">#define PHYSFS_VER_MINOR</div><div class="ttdef"><b>Definition</b> physfs.h:436</div></div>
<div class="ttc" id="aphysfs_8h_html_abc0b94a8f06bc69bd18d741b3e66dfa4"><div class="ttname"><a href="physfs_8h.html#abc0b94a8f06bc69bd18d741b3e66dfa4">PHYSFS_VER_MAJOR</a></div><div class="ttdeci">#define PHYSFS_VER_MAJOR</div><div class="ttdef"><b>Definition</b> physfs.h:435</div></div>
</div><!-- fragment -->
<p>Macro to determine PhysicsFS version program was compiled against. </p>
<p>This macro fills in a <a class="el" href="struct_p_h_y_s_f_s___version.html" title="Information the version of PhysicsFS in use.">PHYSFS_Version</a> structure with the version of the library you compiled against. This is determined by what header the compiler uses. Note that if you dynamically linked the library, you might have a slightly newer or older version at runtime. That version can be determined with <a class="el" href="physfs_8h.html#a8977d0ba0a2301256e823532479f1a05" title="Get the version of PhysicsFS that is linked against your program.">PHYSFS_getLinkedVersion()</a>, which, unlike PHYSFS_VERSION, is not a macro.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A pointer to a <a class="el" href="struct_p_h_y_s_f_s___version.html" title="Information the version of PhysicsFS in use.">PHYSFS_Version</a> struct to initialize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_p_h_y_s_f_s___version.html" title="Information the version of PhysicsFS in use.">PHYSFS_Version</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a8977d0ba0a2301256e823532479f1a05" title="Get the version of PhysicsFS that is linked against your program.">PHYSFS_getLinkedVersion</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a217365fb44c681e0eb6eddb852f5f979" name="a217365fb44c681e0eb6eddb852f5f979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a217365fb44c681e0eb6eddb852f5f979">&#9670;&#160;</a></span>PHYSFS_Allocator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_p_h_y_s_f_s___allocator.html">PHYSFS_Allocator</a> <a class="el" href="struct_p_h_y_s_f_s___allocator.html">PHYSFS_Allocator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4205d2b4f7fb274a3c9a6e37dc8d9bd5" name="a4205d2b4f7fb274a3c9a6e37dc8d9bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4205d2b4f7fb274a3c9a6e37dc8d9bd5">&#9670;&#160;</a></span>PHYSFS_ArchiveInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_p_h_y_s_f_s___archive_info.html">PHYSFS_ArchiveInfo</a> <a class="el" href="struct_p_h_y_s_f_s___archive_info.html">PHYSFS_ArchiveInfo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79850057f06c98bf3fcb1365a76ca212" name="a79850057f06c98bf3fcb1365a76ca212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79850057f06c98bf3fcb1365a76ca212">&#9670;&#160;</a></span>PHYSFS_Archiver</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_p_h_y_s_f_s___archiver.html">PHYSFS_Archiver</a> <a class="el" href="struct_p_h_y_s_f_s___archiver.html">PHYSFS_Archiver</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e72dbc92c0decdca218c8a9a658e788" name="a1e72dbc92c0decdca218c8a9a658e788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e72dbc92c0decdca218c8a9a658e788">&#9670;&#160;</a></span>PHYSFS_EnumerateCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PHYSFS_EnumerateCallback</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Possible return values from PHYSFS_EnumerateCallback. </p>
<p>Function signature for callbacks that enumerate and return results.</p>
<p>These values dictate if an enumeration callback should continue to fire, or stop (and why it is stopping).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a1e72dbc92c0decdca218c8a9a658e788" title="Possible return values from PHYSFS_EnumerateCallback.">PHYSFS_EnumerateCallback</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a33085cbbf18ba7eb659cf2a43d6793ba" title="Get a file listing of a search path&#39;s directory, using an application-defined callback,...">PHYSFS_enumerate</a></dd></dl>
<p>This is the same thing as PHYSFS_EnumFilesCallback from PhysicsFS 2.0, except it can return a result from the callback: namely: if you're looking for something specific, once you find it, you can tell PhysicsFS to stop enumerating further. This is used with <a class="el" href="physfs_8h.html#a33085cbbf18ba7eb659cf2a43d6793ba" title="Get a file listing of a search path&#39;s directory, using an application-defined callback,...">PHYSFS_enumerate()</a>, which we hopefully got right this time. :)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>User-defined data pointer, passed through from the API that eventually called the callback. </td></tr>
    <tr><td class="paramname">origdir</td><td>A string containing the full path, in platform-independent notation, of the directory containing this file. In most cases, this is the directory on which you requested enumeration, passed in the callback for your convenience. </td></tr>
    <tr><td class="paramname">fname</td><td>The filename that is being enumerated. It may not be in alphabetical order compared to other callbacks that have fired, and it will not contain the full path. You can recreate the fullpath with $origdir/$fname ... The file can be a subdirectory, a file, a symlink, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from PHYSFS_EnumerateCallbackResult. All other values are (currently) undefined; don't use them.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a33085cbbf18ba7eb659cf2a43d6793ba" title="Get a file listing of a search path&#39;s directory, using an application-defined callback,...">PHYSFS_enumerate</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#aa11a2522c5f699b00d19802b721e73d4">PHYSFS_EnumerateCallbackResult</a> </dd></dl>

</div>
</div>
<a id="a9f00758603989637229ab5f1503b4cd4" name="a9f00758603989637229ab5f1503b4cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f00758603989637229ab5f1503b4cd4">&#9670;&#160;</a></span>PHYSFS_EnumerateCallbackResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="physfs_8h.html#aa11a2522c5f699b00d19802b721e73d4">PHYSFS_EnumerateCallbackResult</a> <a class="el" href="physfs_8h.html#aa11a2522c5f699b00d19802b721e73d4">PHYSFS_EnumerateCallbackResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a51c1e0145502aeaf080973d308d33c6a" name="a51c1e0145502aeaf080973d308d33c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c1e0145502aeaf080973d308d33c6a">&#9670;&#160;</a></span>PHYSFS_EnumFilesCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PHYSFS_EnumFilesCallback</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function signature for callbacks that enumerate files. </p>
<dl class="section warning"><dt>Warning</dt><dd>As of PhysicsFS 2.1, Use PHYSFS_EnumerateCallback with <a class="el" href="physfs_8h.html#a33085cbbf18ba7eb659cf2a43d6793ba" title="Get a file listing of a search path&#39;s directory, using an application-defined callback,...">PHYSFS_enumerate()</a> instead; it gives you more control over the process.</dd></dl>
<p>These are used to report a list of directory entries to an original caller, one file/dir/symlink per callback. All strings are UTF-8 encoded. Functions should not try to modify or free any string's memory.</p>
<p>These callbacks are used, starting in PhysicsFS 1.1, as an alternative to functions that would return lists that need to be cleaned up with <a class="el" href="physfs_8h.html#af6aeb2ffdcee44f02cf380da62462b05" title="Deallocate resources of lists returned by PhysicsFS.">PHYSFS_freeList()</a>. The callback means that the library doesn't need to allocate an entire list and all the strings up front.</p>
<p>Be aware that promised data ordering in the list versions are not necessarily so in the callback versions. Check the documentation on specific APIs, but strings may not be sorted as you expect and you might get duplicate strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>User-defined data pointer, passed through from the API that eventually called the callback. </td></tr>
    <tr><td class="paramname">origdir</td><td>A string containing the full path, in platform-independent notation, of the directory containing this file. In most cases, this is the directory on which you requested enumeration, passed in the callback for your convenience. </td></tr>
    <tr><td class="paramname">fname</td><td>The filename that is being enumerated. It may not be in alphabetical order compared to other callbacks that have fired, and it will not contain the full path. You can recreate the fullpath with $origdir/$fname ... The file can be a subdirectory, a file, a symlink, etc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a56fefcc5c7d198db415007a842a8eae5" title="Get a file listing of a search path&#39;s directory, using an application-defined callback.">PHYSFS_enumerateFilesCallback</a> </dd></dl>

</div>
</div>
<a id="af546184cb93c10ffe23db24ee1b75f8d" name="af546184cb93c10ffe23db24ee1b75f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af546184cb93c10ffe23db24ee1b75f8d">&#9670;&#160;</a></span>PHYSFS_ErrorCode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afed">PHYSFS_ErrorCode</a> <a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afed">PHYSFS_ErrorCode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb19ab3e6ff04a43ef335e22c77f148e" name="abb19ab3e6ff04a43ef335e22c77f148e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb19ab3e6ff04a43ef335e22c77f148e">&#9670;&#160;</a></span>PHYSFS_File</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> <a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6d98655e86dfaee90747a238421ebed" name="ad6d98655e86dfaee90747a238421ebed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d98655e86dfaee90747a238421ebed">&#9670;&#160;</a></span>PHYSFS_FileType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="physfs_8h.html#ac83274ef7d83801a80563476516bfa15">PHYSFS_FileType</a> <a class="el" href="physfs_8h.html#ac83274ef7d83801a80563476516bfa15">PHYSFS_FileType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a75501e493c6831f2dfa930143b887ce8" name="a75501e493c6831f2dfa930143b887ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75501e493c6831f2dfa930143b887ce8">&#9670;&#160;</a></span>PHYSFS_Io</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> <a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeed97311e1294c0b42648f99d331e5a0" name="aeed97311e1294c0b42648f99d331e5a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed97311e1294c0b42648f99d331e5a0">&#9670;&#160;</a></span>PHYSFS_sint16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#aeed97311e1294c0b42648f99d331e5a0">PHYSFS_sint16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A signed, 16-bit integer type. </p>

</div>
</div>
<a id="ae0264996863470a315e29d5a740a0f36" name="ae0264996863470a315e29d5a740a0f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0264996863470a315e29d5a740a0f36">&#9670;&#160;</a></span>PHYSFS_sint32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#ae0264996863470a315e29d5a740a0f36">PHYSFS_sint32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A signed, 32-bit integer type. </p>

</div>
</div>
<a id="a88c5f1d7b088888c729b22644651c9f5" name="a88c5f1d7b088888c729b22644651c9f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c5f1d7b088888c729b22644651c9f5">&#9670;&#160;</a></span>PHYSFS_sint64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A signed, 64-bit integer type. </p>
<dl class="section warning"><dt>Warning</dt><dd>on platforms without any sort of 64-bit datatype, this is equivalent to PHYSFS_sint32! </dd></dl>

</div>
</div>
<a id="a76505754bb5c7f8f5e964e1a4d1a2571" name="a76505754bb5c7f8f5e964e1a4d1a2571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76505754bb5c7f8f5e964e1a4d1a2571">&#9670;&#160;</a></span>PHYSFS_sint8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#a76505754bb5c7f8f5e964e1a4d1a2571">PHYSFS_sint8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A signed, 8-bit integer type. </p>

</div>
</div>
<a id="a0ff64e61b04713ef4264ba9e74b3a29a" name="a0ff64e61b04713ef4264ba9e74b3a29a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff64e61b04713ef4264ba9e74b3a29a">&#9670;&#160;</a></span>PHYSFS_Stat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_p_h_y_s_f_s___stat.html">PHYSFS_Stat</a> <a class="el" href="struct_p_h_y_s_f_s___stat.html">PHYSFS_Stat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6331ac65f8e0d32288f8597e48188a4f" name="a6331ac65f8e0d32288f8597e48188a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6331ac65f8e0d32288f8597e48188a4f">&#9670;&#160;</a></span>PHYSFS_StringCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PHYSFS_StringCallback</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function signature for callbacks that report strings. </p>
<p>These are used to report a list of strings to an original caller, one string per callback. All strings are UTF-8 encoded. Functions should not try to modify or free the string's memory.</p>
<p>These callbacks are used, starting in PhysicsFS 1.1, as an alternative to functions that would return lists that need to be cleaned up with <a class="el" href="physfs_8h.html#af6aeb2ffdcee44f02cf380da62462b05" title="Deallocate resources of lists returned by PhysicsFS.">PHYSFS_freeList()</a>. The callback means that the library doesn't need to allocate an entire list and all the strings up front.</p>
<p>Be aware that promises data ordering in the list versions are not necessarily so in the callback versions. Check the documentation on specific APIs, but strings may not be sorted as you expect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>User-defined data pointer, passed through from the API that eventually called the callback. </td></tr>
    <tr><td class="paramname">str</td><td>The string data about which the callback is meant to inform.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#ace04dfd0654ce55a81a85f57f56c7410" title="Enumerate CD-ROM directories, using an application-defined callback.">PHYSFS_getCdRomDirsCallback</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#abd5f7188ab27722b0651e7503c6a737a" title="Enumerate the search path, using an application-defined callback.">PHYSFS_getSearchPathCallback</a> </dd></dl>

</div>
</div>
<a id="ac4d1c74e276b04ef993530a405553574" name="ac4d1c74e276b04ef993530a405553574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d1c74e276b04ef993530a405553574">&#9670;&#160;</a></span>PHYSFS_uint16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An unsigned, 16-bit integer type. </p>

</div>
</div>
<a id="aae011b45ebd619edb193fe196e1f5f74" name="aae011b45ebd619edb193fe196e1f5f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae011b45ebd619edb193fe196e1f5f74">&#9670;&#160;</a></span>PHYSFS_uint32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An unsigned, 32-bit integer type. </p>

</div>
</div>
<a id="a632ba02500231e5f6f6df2e4cb71c818" name="a632ba02500231e5f6f6df2e4cb71c818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a632ba02500231e5f6f6df2e4cb71c818">&#9670;&#160;</a></span>PHYSFS_uint64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An unsigned, 64-bit integer type. </p>
<dl class="section warning"><dt>Warning</dt><dd>on platforms without any sort of 64-bit datatype, this is equivalent to PHYSFS_uint32! </dd></dl>

</div>
</div>
<a id="abb348466106a912e03cf63f494a30356" name="abb348466106a912e03cf63f494a30356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb348466106a912e03cf63f494a30356">&#9670;&#160;</a></span>PHYSFS_uint8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#abb348466106a912e03cf63f494a30356">PHYSFS_uint8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An unsigned, 8-bit integer type. </p>

</div>
</div>
<a id="af5b883c2a3d58820281a314742bb1b63" name="af5b883c2a3d58820281a314742bb1b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b883c2a3d58820281a314742bb1b63">&#9670;&#160;</a></span>PHYSFS_Version</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_p_h_y_s_f_s___version.html">PHYSFS_Version</a> <a class="el" href="struct_p_h_y_s_f_s___version.html">PHYSFS_Version</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa11a2522c5f699b00d19802b721e73d4" name="aa11a2522c5f699b00d19802b721e73d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11a2522c5f699b00d19802b721e73d4">&#9670;&#160;</a></span>PHYSFS_EnumerateCallbackResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="physfs_8h.html#aa11a2522c5f699b00d19802b721e73d4">PHYSFS_EnumerateCallbackResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa11a2522c5f699b00d19802b721e73d4a709ef5541f2471dc606a204bded733e1" name="aa11a2522c5f699b00d19802b721e73d4a709ef5541f2471dc606a204bded733e1"></a>PHYSFS_ENUM_ERROR&#160;</td><td class="fielddoc"><p>Stop enumerating, report error to app. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11a2522c5f699b00d19802b721e73d4a793f45e661a94768c0826b6ea1e93aa3" name="aa11a2522c5f699b00d19802b721e73d4a793f45e661a94768c0826b6ea1e93aa3"></a>PHYSFS_ENUM_STOP&#160;</td><td class="fielddoc"><p>Stop enumerating, report success to app. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11a2522c5f699b00d19802b721e73d4ac8d05f52332e6b6452dc52e58f0bfdfe" name="aa11a2522c5f699b00d19802b721e73d4ac8d05f52332e6b6452dc52e58f0bfdfe"></a>PHYSFS_ENUM_OK&#160;</td><td class="fielddoc"><p>Keep enumerating, no problems. </p>
</td></tr>
</table>

</div>
</div>
<a id="a50dba13af51214897c867a123f74afed" name="a50dba13af51214897c867a123f74afed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50dba13af51214897c867a123f74afed">&#9670;&#160;</a></span>PHYSFS_ErrorCode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afed">PHYSFS_ErrorCode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Values that represent specific causes of failure. </p>
<p>Most of the time, you should only concern yourself with whether a given operation failed or not, but there may be occasions where you plan to handle a specific failure case gracefully, so we provide specific error codes.</p>
<p>Most of these errors are a little vague, and most aren't things you can fix...if there's a permission error, for example, all you can really do is pass that information on to the user and let them figure out how to handle it. In most these cases, your program should only care that it failed to accomplish its goals, and not care specifically why.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a545f6b5ba97faa19441932dffb65c3be" title="Get human-readable description string for a given error code.">PHYSFS_getErrorByCode</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afeda350a0311fc19d8b9b5ec06f312e703ce" name="a50dba13af51214897c867a123f74afeda350a0311fc19d8b9b5ec06f312e703ce"></a>PHYSFS_ERR_OK&#160;</td><td class="fielddoc"><p>Success; no error. </p>
<p><br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afedaf6bd49755fa19f8c94f326d1dd45bc60" name="a50dba13af51214897c867a123f74afedaf6bd49755fa19f8c94f326d1dd45bc60"></a>PHYSFS_ERR_OTHER_ERROR&#160;</td><td class="fielddoc"><p>Error not otherwise covered here. </p>
<p><br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afeda3cad5fa8b3b9fdd5d898ec0c49468842" name="a50dba13af51214897c867a123f74afeda3cad5fa8b3b9fdd5d898ec0c49468842"></a>PHYSFS_ERR_OUT_OF_MEMORY&#160;</td><td class="fielddoc"><p>Memory allocation failed. </p>
<p><br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afedaf162fd97734c33e5daea378f8ad8f700" name="a50dba13af51214897c867a123f74afedaf162fd97734c33e5daea378f8ad8f700"></a>PHYSFS_ERR_NOT_INITIALIZED&#160;</td><td class="fielddoc"><p>PhysicsFS is not initialized. </p>
<p><br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afedae05bb5fb7bf20246c93010f32f1506dd" name="a50dba13af51214897c867a123f74afedae05bb5fb7bf20246c93010f32f1506dd"></a>PHYSFS_ERR_IS_INITIALIZED&#160;</td><td class="fielddoc"><p>PhysicsFS is already initialized. </p>
<p><br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afedad241a62d7f79e0604bdd7ae580381cf6" name="a50dba13af51214897c867a123f74afedad241a62d7f79e0604bdd7ae580381cf6"></a>PHYSFS_ERR_ARGV0_IS_NULL&#160;</td><td class="fielddoc"><p>Needed argv[0], but it is NULL. </p>
<p><br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afeda734e86036e56e76ece258cfd07fc607c" name="a50dba13af51214897c867a123f74afeda734e86036e56e76ece258cfd07fc607c"></a>PHYSFS_ERR_UNSUPPORTED&#160;</td><td class="fielddoc"><p>Operation or feature unsupported. </p>
<p><br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afeda6cfa14f636960665f071b615086ccb57" name="a50dba13af51214897c867a123f74afeda6cfa14f636960665f071b615086ccb57"></a>PHYSFS_ERR_PAST_EOF&#160;</td><td class="fielddoc"><p>Attempted to access past end of file. </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afeda339879ed2ed7aa5710b0db495a60df86" name="a50dba13af51214897c867a123f74afeda339879ed2ed7aa5710b0db495a60df86"></a>PHYSFS_ERR_FILES_STILL_OPEN&#160;</td><td class="fielddoc"><p>Files still open. </p>
<p><br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afedaafe411479f6f10a74bd04a601cdea8e1" name="a50dba13af51214897c867a123f74afedaafe411479f6f10a74bd04a601cdea8e1"></a>PHYSFS_ERR_INVALID_ARGUMENT&#160;</td><td class="fielddoc"><p>Bad parameter passed to an function. </p>
<p><br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afeda1c124b069747e079a1714de93656385b" name="a50dba13af51214897c867a123f74afeda1c124b069747e079a1714de93656385b"></a>PHYSFS_ERR_NOT_MOUNTED&#160;</td><td class="fielddoc"><p>Requested archive/dir not mounted. </p>
<p><br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afeda426ece1b73ffc73afed87ed2203b84f4" name="a50dba13af51214897c867a123f74afeda426ece1b73ffc73afed87ed2203b84f4"></a>PHYSFS_ERR_NOT_FOUND&#160;</td><td class="fielddoc"><p>File (or whatever) not found. </p>
<p><br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afeda52883f3495052d538b935d1d67b820c3" name="a50dba13af51214897c867a123f74afeda52883f3495052d538b935d1d67b820c3"></a>PHYSFS_ERR_SYMLINK_FORBIDDEN&#160;</td><td class="fielddoc"><p>Symlink seen when not permitted. </p>
<p><br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afeda78a43f3de727ea7594a9a143ed252e52" name="a50dba13af51214897c867a123f74afeda78a43f3de727ea7594a9a143ed252e52"></a>PHYSFS_ERR_NO_WRITE_DIR&#160;</td><td class="fielddoc"><p>No write dir has been specified. </p>
<p><br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afeda30dc0b5b61c31ce2e5c15a995b7d03a8" name="a50dba13af51214897c867a123f74afeda30dc0b5b61c31ce2e5c15a995b7d03a8"></a>PHYSFS_ERR_OPEN_FOR_READING&#160;</td><td class="fielddoc"><p>Wrote to a file opened for reading. </p>
<p><br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afeda56c0a5de581b0981376e2df0d77b995f" name="a50dba13af51214897c867a123f74afeda56c0a5de581b0981376e2df0d77b995f"></a>PHYSFS_ERR_OPEN_FOR_WRITING&#160;</td><td class="fielddoc"><p>Read from a file opened for writing. </p>
<p><br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afedac7308d464cbdeae33b3b46ef477380a4" name="a50dba13af51214897c867a123f74afedac7308d464cbdeae33b3b46ef477380a4"></a>PHYSFS_ERR_NOT_A_FILE&#160;</td><td class="fielddoc"><p>Needed a file, got a directory (etc). </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afeda02204e5c7d56d8097ac926a0e3ed011b" name="a50dba13af51214897c867a123f74afeda02204e5c7d56d8097ac926a0e3ed011b"></a>PHYSFS_ERR_READ_ONLY&#160;</td><td class="fielddoc"><p>Wrote to a read-only filesystem. </p>
<p><br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afedadf796cd23b55fc711b50fc903526d02b" name="a50dba13af51214897c867a123f74afedadf796cd23b55fc711b50fc903526d02b"></a>PHYSFS_ERR_CORRUPT&#160;</td><td class="fielddoc"><p>Corrupted data encountered. </p>
<p><br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afedac799c795f6aca95e170c3cb7ff145b2c" name="a50dba13af51214897c867a123f74afedac799c795f6aca95e170c3cb7ff145b2c"></a>PHYSFS_ERR_SYMLINK_LOOP&#160;</td><td class="fielddoc"><p>Infinite symbolic link loop. </p>
<p><br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afeda18a8f0827d6fb21cecd5404cff88cab5" name="a50dba13af51214897c867a123f74afeda18a8f0827d6fb21cecd5404cff88cab5"></a>PHYSFS_ERR_IO&#160;</td><td class="fielddoc"><p>i/o error (hardware failure, etc). </p>
<p><br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afedacc1abade7a5838284ad6959fe486199c" name="a50dba13af51214897c867a123f74afedacc1abade7a5838284ad6959fe486199c"></a>PHYSFS_ERR_PERMISSION&#160;</td><td class="fielddoc"><p>Permission denied. </p>
<p><br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afedac1dced0099f8acd28c529883cf2cd894" name="a50dba13af51214897c867a123f74afedac1dced0099f8acd28c529883cf2cd894"></a>PHYSFS_ERR_NO_SPACE&#160;</td><td class="fielddoc"><p>No space (disk full, over quota, etc) </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afedaa9cabd98b57c1d0c6f28f008070d8b34" name="a50dba13af51214897c867a123f74afedaa9cabd98b57c1d0c6f28f008070d8b34"></a>PHYSFS_ERR_BAD_FILENAME&#160;</td><td class="fielddoc"><p>Filename is bogus/insecure. </p>
<p><br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afeda81cb4cfda88fdac43ca6ec748f8eb380" name="a50dba13af51214897c867a123f74afeda81cb4cfda88fdac43ca6ec748f8eb380"></a>PHYSFS_ERR_BUSY&#160;</td><td class="fielddoc"><p>Tried to modify a file the OS needs. </p>
<p><br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afeda2ef70542e659b8393e217923c762922f" name="a50dba13af51214897c867a123f74afeda2ef70542e659b8393e217923c762922f"></a>PHYSFS_ERR_DIR_NOT_EMPTY&#160;</td><td class="fielddoc"><p>Tried to delete dir with files in it. </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afedaab8102396aff3f07f975320a78e3be13" name="a50dba13af51214897c867a123f74afedaab8102396aff3f07f975320a78e3be13"></a>PHYSFS_ERR_OS_ERROR&#160;</td><td class="fielddoc"><p>Unspecified OS-level error. </p>
<p><br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afedaf089c21761b1142e0f215843d2dceaa7" name="a50dba13af51214897c867a123f74afedaf089c21761b1142e0f215843d2dceaa7"></a>PHYSFS_ERR_DUPLICATE&#160;</td><td class="fielddoc"><p>Duplicate entry. </p>
<p><br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afeda1782515d1d7babfb7201c2dbc59b507f" name="a50dba13af51214897c867a123f74afeda1782515d1d7babfb7201c2dbc59b507f"></a>PHYSFS_ERR_BAD_PASSWORD&#160;</td><td class="fielddoc"><p>Bad password. </p>
<p><br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dba13af51214897c867a123f74afeda6161bfc88154640b7fc9bb950111f7ad" name="a50dba13af51214897c867a123f74afeda6161bfc88154640b7fc9bb950111f7ad"></a>PHYSFS_ERR_APP_CALLBACK&#160;</td><td class="fielddoc"><p>Application callback reported error. </p>
<p><br  />
 </p>
</td></tr>
</table>

</div>
</div>
<a id="ac83274ef7d83801a80563476516bfa15" name="ac83274ef7d83801a80563476516bfa15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83274ef7d83801a80563476516bfa15">&#9670;&#160;</a></span>PHYSFS_FileType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="physfs_8h.html#ac83274ef7d83801a80563476516bfa15">PHYSFS_FileType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of a File. </p>
<p>Possible types of a file.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a7f5e23675c50ffe51ad00cceb5a65348" title="Get various information about a directory or a file.">PHYSFS_stat</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac83274ef7d83801a80563476516bfa15ae99e7a2bad864791c680eac138d9fb3a" name="ac83274ef7d83801a80563476516bfa15ae99e7a2bad864791c680eac138d9fb3a"></a>PHYSFS_FILETYPE_REGULAR&#160;</td><td class="fielddoc"><p>a normal file </p>
</td></tr>
<tr><td class="fieldname"><a id="ac83274ef7d83801a80563476516bfa15a3ca9b647070a1b72496940026649bd02" name="ac83274ef7d83801a80563476516bfa15a3ca9b647070a1b72496940026649bd02"></a>PHYSFS_FILETYPE_DIRECTORY&#160;</td><td class="fielddoc"><p>a directory </p>
</td></tr>
<tr><td class="fieldname"><a id="ac83274ef7d83801a80563476516bfa15a98794e6fd60557ce50623f81e86e7663" name="ac83274ef7d83801a80563476516bfa15a98794e6fd60557ce50623f81e86e7663"></a>PHYSFS_FILETYPE_SYMLINK&#160;</td><td class="fielddoc"><p>a symlink </p>
</td></tr>
<tr><td class="fieldname"><a id="ac83274ef7d83801a80563476516bfa15a83e202bbeee9274a8e746dde9ab5fef8" name="ac83274ef7d83801a80563476516bfa15a83e202bbeee9274a8e746dde9ab5fef8"></a>PHYSFS_FILETYPE_OTHER&#160;</td><td class="fielddoc"><p>something completely different like a device </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae9a677c869257742cbe5417dec9b3cee" name="ae9a677c869257742cbe5417dec9b3cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a677c869257742cbe5417dec9b3cee">&#9670;&#160;</a></span>PHYSFS_addToSearchPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_addToSearchPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>newDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>appendToPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an archive or directory to the search path. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>As of PhysicsFS 2.0, use <a class="el" href="physfs_8h.html#a8eb320e9af03dcdb4c05bbff3ea604d4" title="Add an archive or directory to the search path.">PHYSFS_mount()</a> instead. This function just wraps it anyhow.</dd></dl>
<p>This function is equivalent to:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="physfs_8h.html#a8eb320e9af03dcdb4c05bbff3ea604d4">PHYSFS_mount</a>(newDir, NULL, appendToPath);</div>
<div class="ttc" id="aphysfs_8h_html_a8eb320e9af03dcdb4c05bbff3ea604d4"><div class="ttname"><a href="physfs_8h.html#a8eb320e9af03dcdb4c05bbff3ea604d4">PHYSFS_mount</a></div><div class="ttdeci">PHYSFS_DECL int PHYSFS_mount(const char *newDir, const char *mountPoint, int appendToPath)</div><div class="ttdoc">Add an archive or directory to the search path.</div></div>
</div><!-- fragment --><p>You must use this and not PHYSFS_mount if binary compatibility with PhysicsFS 1.0 is important (which it may not be for many people).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a8eb320e9af03dcdb4c05bbff3ea604d4" title="Add an archive or directory to the search path.">PHYSFS_mount</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a555ee86816418ed3a99e10243c5db7b8" title="Remove a directory or archive from the search path.">PHYSFS_removeFromSearchPath</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#ac738531e9c7e5ca3797b64985c103cf4" title="Get the current search path.">PHYSFS_getSearchPath</a> </dd></dl>

</div>
</div>
<a id="a3845b57434e52e82f6ae8b6a0fe13f26" name="a3845b57434e52e82f6ae8b6a0fe13f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3845b57434e52e82f6ae8b6a0fe13f26">&#9670;&#160;</a></span>PHYSFS_caseFold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_caseFold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a> *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Fold" a Unicode codepoint to a lowercase equivalent. </p>
<p>(This is for limited, hardcore use. If you don't immediately see a need for it, you can probably ignore this forever.)</p>
<p>This will convert a Unicode codepoint into its lowercase equivalent. Bogus codepoints and codepoints without a lowercase equivalent will be returned unconverted.</p>
<p>Note that you might get multiple codepoints in return! The German Eszett, for example, will fold down to two lowercase latin 's' codepoints. The theory is that if you fold two strings, one with an Eszett and one with "SS" down, they will match.</p>
<dl class="section warning"><dt>Warning</dt><dd>Anyone that is a student of Unicode knows about the "Turkish I" problem. This API does not handle it. Assume this one letter in all of Unicode will definitely fold sort of incorrectly. If you don't know what this is about, you can probably ignore this problem for most of the planet, but perfection is impossible.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The codepoint to fold. </td></tr>
    <tr><td class="paramname">to</td><td>Buffer to store the folded codepoint values into. This should point to space for at least 3 PHYSFS_uint32 slots. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of codepoints the folding produced. Between 1 and 3. </dd></dl>

</div>
</div>
<a id="a6822f8ff10073e855a1c3a6485b882f2" name="a6822f8ff10073e855a1c3a6485b882f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6822f8ff10073e855a1c3a6485b882f2">&#9670;&#160;</a></span>PHYSFS_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a PhysicsFS filehandle. </p>
<p>This call is capable of failing if the operating system was buffering writes to the physical media, and, now forced to write those changes to physical media, can not store the data for some reason. In such a case, the filehandle stays open. A well-written program should ALWAYS check the return value from the close call in addition to every writing call!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>handle returned from PHYSFS_open*(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nonzero on success, zero on error. Use <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a> to obtain the specific error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a5e38a425bb0b44c09ec25b105f770c63" title="Open a file for reading.">PHYSFS_openRead</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#abbf92d66c6cb82d0ede969aa2c964fba" title="Open a file for writing.">PHYSFS_openWrite</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#abeeca12e2fe7c5f68cbd67e2e5cafa3d" title="Open a file for appending.">PHYSFS_openAppend</a> </dd></dl>

</div>
</div>
<a id="a3c6eea864894b2642bf4c87d1bc170b8" name="a3c6eea864894b2642bf4c87d1bc170b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c6eea864894b2642bf4c87d1bc170b8">&#9670;&#160;</a></span>PHYSFS_COMPILE_TIME_ASSERT() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PHYSFS_COMPILE_TIME_ASSERT </td>
          <td>(</td>
          <td class="paramtype">sint16IsTwoBytes&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sizeof(<a class="el" href="physfs_8h.html#aeed97311e1294c0b42648f99d331e5a0">PHYSFS_sint16</a>)&#160;</td>
          <td class="paramname"> = <code>=2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaba190e4aeacce406f8041be470e151a" name="aaba190e4aeacce406f8041be470e151a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba190e4aeacce406f8041be470e151a">&#9670;&#160;</a></span>PHYSFS_COMPILE_TIME_ASSERT() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PHYSFS_COMPILE_TIME_ASSERT </td>
          <td>(</td>
          <td class="paramtype">sint32IsFourBytes&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sizeof(<a class="el" href="physfs_8h.html#ae0264996863470a315e29d5a740a0f36">PHYSFS_sint32</a>)&#160;</td>
          <td class="paramname"> = <code>=4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a33f82b6510bb1229d36f40a3c48e14f8" name="a33f82b6510bb1229d36f40a3c48e14f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f82b6510bb1229d36f40a3c48e14f8">&#9670;&#160;</a></span>PHYSFS_COMPILE_TIME_ASSERT() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PHYSFS_COMPILE_TIME_ASSERT </td>
          <td>(</td>
          <td class="paramtype">sint64IsEightBytes&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sizeof(<a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a>)&#160;</td>
          <td class="paramname"> = <code>=8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e8b4671d4729beebbe69b425d73c28e" name="a4e8b4671d4729beebbe69b425d73c28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e8b4671d4729beebbe69b425d73c28e">&#9670;&#160;</a></span>PHYSFS_COMPILE_TIME_ASSERT() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PHYSFS_COMPILE_TIME_ASSERT </td>
          <td>(</td>
          <td class="paramtype">sint8IsOneByte&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sizeof(<a class="el" href="physfs_8h.html#a76505754bb5c7f8f5e964e1a4d1a2571">PHYSFS_sint8</a>)&#160;</td>
          <td class="paramname"> = <code>=1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b9a890eada2dde221e43b25cfd04e4d" name="a7b9a890eada2dde221e43b25cfd04e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b9a890eada2dde221e43b25cfd04e4d">&#9670;&#160;</a></span>PHYSFS_COMPILE_TIME_ASSERT() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PHYSFS_COMPILE_TIME_ASSERT </td>
          <td>(</td>
          <td class="paramtype">uint16IsTwoBytes&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sizeof(<a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a>)&#160;</td>
          <td class="paramname"> = <code>=2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af1bedb25e0b7e5e39a51110439b26c5c" name="af1bedb25e0b7e5e39a51110439b26c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1bedb25e0b7e5e39a51110439b26c5c">&#9670;&#160;</a></span>PHYSFS_COMPILE_TIME_ASSERT() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PHYSFS_COMPILE_TIME_ASSERT </td>
          <td>(</td>
          <td class="paramtype">uint32IsFourBytes&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sizeof(<a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a>)&#160;</td>
          <td class="paramname"> = <code>=4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0ba0e406bde32f7e522584f88862420" name="ac0ba0e406bde32f7e522584f88862420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ba0e406bde32f7e522584f88862420">&#9670;&#160;</a></span>PHYSFS_COMPILE_TIME_ASSERT() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PHYSFS_COMPILE_TIME_ASSERT </td>
          <td>(</td>
          <td class="paramtype">uint64IsEightBytes&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sizeof(<a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a>)&#160;</td>
          <td class="paramname"> = <code>=8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2207071ffb05b44519e759b4606aac7" name="aa2207071ffb05b44519e759b4606aac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2207071ffb05b44519e759b4606aac7">&#9670;&#160;</a></span>PHYSFS_COMPILE_TIME_ASSERT() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PHYSFS_COMPILE_TIME_ASSERT </td>
          <td>(</td>
          <td class="paramtype">uint8IsOneByte&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sizeof(<a class="el" href="physfs_8h.html#abb348466106a912e03cf63f494a30356">PHYSFS_uint8</a>)&#160;</td>
          <td class="paramname"> = <code>=1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa465c9b58e5020f503085d433a413b5b" name="aa465c9b58e5020f503085d433a413b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa465c9b58e5020f503085d433a413b5b">&#9670;&#160;</a></span>PHYSFS_deinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_deinit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deinitialize the PhysicsFS library. </p>
<p>This closes any files opened via PhysicsFS, blanks the search/write paths, frees memory, and invalidates all of your file handles.</p>
<p>Note that this call can FAIL if there's a file open for writing that refuses to close (for example, the underlying operating system was buffering writes to network filesystem, and the fileserver has crashed, or a hard drive has failed, etc). It is usually best to close all write handles yourself before calling this function, so that you can gracefully handle a specific failure.</p>
<p>Once successfully deinitialized, <a class="el" href="physfs_8h.html#a61b94cac8e65267afb8a5f2344e60dd1" title="Initialize the PhysicsFS library.">PHYSFS_init()</a> can be called again to restart the subsystem. All default API states are restored at this point, with the exception of any custom allocator you might have specified, which survives between initializations.</p>
<dl class="section return"><dt>Returns</dt><dd>nonzero on success, zero on error. Specifics of the error can be gleaned from <a class="el" href="physfs_8h.html#a619e0a12b15035f8def90f4ba40ec5d5" title="Get human-readable error information.">PHYSFS_getLastError()</a>. If failure, state of PhysFS is undefined, and probably badly screwed up.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a61b94cac8e65267afb8a5f2344e60dd1" title="Initialize the PhysicsFS library.">PHYSFS_init</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a6154be7bfa5d924476356a9fbd0d8223" title="Determine if the PhysicsFS library is initialized.">PHYSFS_isInit</a> </dd></dl>

</div>
</div>
<a id="a27a939bce4c1132bacdfcb3d3cc29e37" name="a27a939bce4c1132bacdfcb3d3cc29e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a939bce4c1132bacdfcb3d3cc29e37">&#9670;&#160;</a></span>PHYSFS_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a file or directory. </p>
<p>(filename) is specified in platform-independent notation in relation to the write dir.</p>
<p>A directory must be empty before this call can delete it.</p>
<p>Deleting a symlink will remove the link, not what it points to, regardless of whether you "permitSymLinks" or not.</p>
<p>So if you've got the write dir set to "C:\mygame\writedir" and call PHYSFS_delete("downloads/maps/level1.map") then the file "C:\mygame\writedir\downloads\maps\level1.map" is removed from the physical filesystem, if it exists and the operating system permits the deletion.</p>
<p>Note that on Unix systems, deleting a file may be successful, but the actual file won't be removed until all processes that have an open filehandle to it (including your program) close their handles.</p>
<p>Chances are, the bits that make up the file still exist, they are just made available to be written over at a later point. Don't consider this a security method or anything. :)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Filename to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nonzero on success, zero on error. Use <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a> to obtain the specific error. </dd></dl>

</div>
</div>
<a id="abbc7cce9112c5ddc2f3a9ad5d0edf6e0" name="abbc7cce9112c5ddc2f3a9ad5d0edf6e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc7cce9112c5ddc2f3a9ad5d0edf6e0">&#9670;&#160;</a></span>PHYSFS_deregisterArchiver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_deregisterArchiver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>ext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an archiver from the system. </p>
<p>If for some reason, you only need your previously-registered archiver to live for a portion of your app's lifetime, you can remove it from the system once you're done with it through this function.</p>
<p>This fails if there are any archives still open that use this archiver.</p>
<p>This function can also remove internally-supplied archivers, like .zip support or whatnot. This could be useful in some situations, like disabling support for them outright or overriding them with your own implementation. Once an internal archiver is disabled like this, PhysicsFS provides no mechanism to recover them, short of calling <a class="el" href="physfs_8h.html#aa465c9b58e5020f503085d433a413b5b" title="Deinitialize the PhysicsFS library.">PHYSFS_deinit()</a> and <a class="el" href="physfs_8h.html#a61b94cac8e65267afb8a5f2344e60dd1" title="Initialize the PhysicsFS library.">PHYSFS_init()</a> again.</p>
<p><a class="el" href="physfs_8h.html#aa465c9b58e5020f503085d433a413b5b" title="Deinitialize the PhysicsFS library.">PHYSFS_deinit()</a> will automatically deregister all archivers, so you don't need to explicitly deregister yours if you otherwise shut down cleanly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ext</td><td>Filename extension that the archiver handles. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on error, non-zero on success.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_p_h_y_s_f_s___archiver.html" title="Abstract interface to provide support for user-defined archives.">PHYSFS_Archiver</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#ace0ecda857dc622e2d005af02972237d" title="Add a new archiver to the system.">PHYSFS_registerArchiver</a> </dd></dl>

</div>
</div>
<a id="a33085cbbf18ba7eb659cf2a43d6793ba" name="a33085cbbf18ba7eb659cf2a43d6793ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33085cbbf18ba7eb659cf2a43d6793ba">&#9670;&#160;</a></span>PHYSFS_enumerate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_enumerate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a1e72dbc92c0decdca218c8a9a658e788">PHYSFS_EnumerateCallback</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a file listing of a search path's directory, using an application-defined callback, with errors reported. </p>
<p>Internally, <a class="el" href="physfs_8h.html#a0f4ae950c2dae0735a91263ddd20fbf4" title="Get a file listing of a search path&#39;s directory.">PHYSFS_enumerateFiles()</a> just calls this function and then builds a list before returning to the application, so functionality is identical except for how the information is represented to the application.</p>
<p>Unlike <a class="el" href="physfs_8h.html#a0f4ae950c2dae0735a91263ddd20fbf4" title="Get a file listing of a search path&#39;s directory.">PHYSFS_enumerateFiles()</a>, this function does not return an array. Rather, it calls a function specified by the application once per element of the search path:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> printDir(<span class="keywordtype">void</span> *<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *origdir, <span class="keyword">const</span> <span class="keywordtype">char</span> *fname)</div>
<div class="line">{</div>
<div class="line">    printf(<span class="stringliteral">&quot; * We&#39;ve got [%s] in [%s].\n&quot;</span>, fname, origdir);</div>
<div class="line">    <span class="keywordflow">return</span> 1;  <span class="comment">// give me more data, please.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><a class="code hl_function" href="physfs_8h.html#a33085cbbf18ba7eb659cf2a43d6793ba">PHYSFS_enumerate</a>(<span class="stringliteral">&quot;/some/path&quot;</span>, printDir, NULL);</div>
<div class="ttc" id="ajpeglib_8h_html_aa379dc8ae39e55ae0c431a61a7d2f2bc"><div class="ttname"><a href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a></div><div class="ttdeci">JSAMPIMAGE data</div><div class="ttdef"><b>Definition</b> jpeglib.h:964</div></div>
<div class="ttc" id="aphysfs_8h_html_a33085cbbf18ba7eb659cf2a43d6793ba"><div class="ttname"><a href="physfs_8h.html#a33085cbbf18ba7eb659cf2a43d6793ba">PHYSFS_enumerate</a></div><div class="ttdeci">PHYSFS_DECL int PHYSFS_enumerate(const char *dir, PHYSFS_EnumerateCallback c, void *d)</div><div class="ttdoc">Get a file listing of a search path's directory, using an application-defined callback,...</div></div>
</div><!-- fragment --><p>Items sent to the callback are not guaranteed to be in any order whatsoever. There is no sorting done at this level, and if you need that, you should probably use <a class="el" href="physfs_8h.html#a0f4ae950c2dae0735a91263ddd20fbf4" title="Get a file listing of a search path&#39;s directory.">PHYSFS_enumerateFiles()</a> instead, which guarantees alphabetical sorting. This form reports whatever is discovered in each archive before moving on to the next. Even within one archive, we can't guarantee what order it will discover data. <em>Any sorting you find in these callbacks is just pure luck. Do not rely on it.</em> As this walks the entire list of archives, you may receive duplicate filenames.</p>
<p>This API and the callbacks themselves are capable of reporting errors. Prior to this API, callbacks had to accept every enumerated item, even if they were only looking for a specific thing and wanted to stop after that, or had a serious error and couldn't alert anyone. Furthermore, if PhysicsFS itself had a problem (disk error or whatnot), it couldn't report it to the calling app, it would just have to skip items or stop enumerating outright, and the caller wouldn't know it had lost some data along the way.</p>
<p>Now the caller can be sure it got a complete data set, and its callback has control if it wants enumeration to stop early. See the documentation for PHYSFS_EnumerateCallback for details on how your callback should behave.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>Directory, in platform-independent notation, to enumerate. </td></tr>
    <tr><td class="paramname">c</td><td>Callback function to notify about search path elements. </td></tr>
    <tr><td class="paramname">d</td><td>Application-defined data passed to callback. Can be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero on success, zero on failure. Use <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a> to obtain the specific error. If the callback returns PHYSFS_ENUM_STOP to stop early, this will be considered success. Callbacks returning PHYSFS_ENUM_ERROR will make this function return zero and set the error code to PHYSFS_ERR_APP_CALLBACK.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a1e72dbc92c0decdca218c8a9a658e788" title="Possible return values from PHYSFS_EnumerateCallback.">PHYSFS_EnumerateCallback</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a0f4ae950c2dae0735a91263ddd20fbf4" title="Get a file listing of a search path&#39;s directory.">PHYSFS_enumerateFiles</a> </dd></dl>

</div>
</div>
<a id="a0f4ae950c2dae0735a91263ddd20fbf4" name="a0f4ae950c2dae0735a91263ddd20fbf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f4ae950c2dae0735a91263ddd20fbf4">&#9670;&#160;</a></span>PHYSFS_enumerateFiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ** PHYSFS_enumerateFiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a file listing of a search path's directory. </p>
<dl class="section warning"><dt>Warning</dt><dd>In PhysicsFS versions prior to 2.1, this function would return as many items as it could in the face of a failure condition (out of memory, disk i/o error, etc). Since this meant apps couldn't distinguish between complete success and partial failure, and since the function could always return NULL to report catastrophic failures anyway, in PhysicsFS 2.1 this function's policy changed: it will either return a list of complete results or it will return NULL for any failure of any kind, so we can guarantee that the enumeration ran to completion and has no gaps in its results.</dd></dl>
<p>Matching directories are interpolated. That is, if "C:\mydir" is in the search path and contains a directory "savegames" that contains "x.sav", "y.sav", and "z.sav", and there is also a "C:\userdir" in the search path that has a "savegames" subdirectory with "w.sav", then the following code:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> **rc = <a class="code hl_function" href="physfs_8h.html#a0f4ae950c2dae0735a91263ddd20fbf4">PHYSFS_enumerateFiles</a>(<span class="stringliteral">&quot;savegames&quot;</span>);</div>
<div class="line"><span class="keywordtype">char</span> **i;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (i = rc; *i != NULL; i++)</div>
<div class="line">    printf(<span class="stringliteral">&quot; * We&#39;ve got [%s].\n&quot;</span>, *i);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="physfs_8h.html#af6aeb2ffdcee44f02cf380da62462b05">PHYSFS_freeList</a>(rc);</div>
<div class="ttc" id="aphysfs_8h_html_a0f4ae950c2dae0735a91263ddd20fbf4"><div class="ttname"><a href="physfs_8h.html#a0f4ae950c2dae0735a91263ddd20fbf4">PHYSFS_enumerateFiles</a></div><div class="ttdeci">PHYSFS_DECL char ** PHYSFS_enumerateFiles(const char *dir)</div><div class="ttdoc">Get a file listing of a search path's directory.</div></div>
<div class="ttc" id="aphysfs_8h_html_af6aeb2ffdcee44f02cf380da62462b05"><div class="ttname"><a href="physfs_8h.html#af6aeb2ffdcee44f02cf380da62462b05">PHYSFS_freeList</a></div><div class="ttdeci">PHYSFS_DECL void PHYSFS_freeList(void *listVar)</div><div class="ttdoc">Deallocate resources of lists returned by PhysicsFS.</div></div>
</div><!-- fragment --><p>...will print:</p>
<pre class="fragment">* We've got [x.sav].
* We've got [y.sav].
* We've got [z.sav].
* We've got [w.sav].</pre><p>Feel free to sort the list however you like. However, the returned data will always contain no duplicates, and will be always sorted in alphabetic (rather: case-sensitive Unicode) order for you.</p>
<p>Don't forget to call <a class="el" href="physfs_8h.html#af6aeb2ffdcee44f02cf380da62462b05" title="Deallocate resources of lists returned by PhysicsFS.">PHYSFS_freeList()</a> with the return value from this function when you are done with it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>directory in platform-independent notation to enumerate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Null-terminated array of null-terminated strings, or NULL for failure cases.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a33085cbbf18ba7eb659cf2a43d6793ba" title="Get a file listing of a search path&#39;s directory, using an application-defined callback,...">PHYSFS_enumerate</a> </dd></dl>

</div>
</div>
<a id="a56fefcc5c7d198db415007a842a8eae5" name="a56fefcc5c7d198db415007a842a8eae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56fefcc5c7d198db415007a842a8eae5">&#9670;&#160;</a></span>PHYSFS_enumerateFilesCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> PHYSFS_enumerateFilesCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a51c1e0145502aeaf080973d308d33c6a">PHYSFS_EnumFilesCallback</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a file listing of a search path's directory, using an application-defined callback. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000010">Deprecated:</a></b></dt><dd>As of PhysicsFS 2.1, use <a class="el" href="physfs_8h.html#a33085cbbf18ba7eb659cf2a43d6793ba" title="Get a file listing of a search path&#39;s directory, using an application-defined callback,...">PHYSFS_enumerate()</a> instead. This function has no way to report errors (or to have the callback signal an error or request a stop), so if data will be lost, your callback has no way to direct the process, and your calling app has no way to know.</dd></dl>
<p>As of PhysicsFS 2.1, this function just wraps <a class="el" href="physfs_8h.html#a33085cbbf18ba7eb659cf2a43d6793ba" title="Get a file listing of a search path&#39;s directory, using an application-defined callback,...">PHYSFS_enumerate()</a> and ignores errors. Consider using <a class="el" href="physfs_8h.html#a33085cbbf18ba7eb659cf2a43d6793ba" title="Get a file listing of a search path&#39;s directory, using an application-defined callback,...">PHYSFS_enumerate()</a> or <a class="el" href="physfs_8h.html#a0f4ae950c2dae0735a91263ddd20fbf4" title="Get a file listing of a search path&#39;s directory.">PHYSFS_enumerateFiles()</a> instead.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a33085cbbf18ba7eb659cf2a43d6793ba" title="Get a file listing of a search path&#39;s directory, using an application-defined callback,...">PHYSFS_enumerate</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a0f4ae950c2dae0735a91263ddd20fbf4" title="Get a file listing of a search path&#39;s directory.">PHYSFS_enumerateFiles</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a51c1e0145502aeaf080973d308d33c6a" title="Function signature for callbacks that enumerate files.">PHYSFS_EnumFilesCallback</a> </dd></dl>

</div>
</div>
<a id="a6d7ac838797951323072060392645dbe" name="a6d7ac838797951323072060392645dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7ac838797951323072060392645dbe">&#9670;&#160;</a></span>PHYSFS_eof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_eof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for end-of-file state on a PhysicsFS filehandle. </p>
<p>Determine if the end of file has been reached in a PhysicsFS filehandle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>handle returned from <a class="el" href="physfs_8h.html#a5e38a425bb0b44c09ec25b105f770c63" title="Open a file for reading.">PHYSFS_openRead()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nonzero if EOF, zero if not.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#abde67ddefb36e3b780cfd796d47c253d" title="Read data from a PhysicsFS filehandle.">PHYSFS_read</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a0d481bdd4cf32ed1a41540ee59840c24" title="Determine current position within a PhysicsFS filehandle.">PHYSFS_tell</a> </dd></dl>

</div>
</div>
<a id="accd31941b636ff153d328aebf72048c7" name="accd31941b636ff153d328aebf72048c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd31941b636ff153d328aebf72048c7">&#9670;&#160;</a></span>PHYSFS_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_exists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a file exists in the search path. </p>
<p>Reports true if there is an entry anywhere in the search path by the name of (fname).</p>
<p>Note that entries that are symlinks are ignored if PHYSFS_permitSymbolicLinks(1) hasn't been called, so you might end up further down in the search path than expected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>filename in platform-independent notation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if filename exists. zero otherwise. </dd></dl>

</div>
</div>
<a id="a3f1d8b415d37d8040ca423ed29536fde" name="a3f1d8b415d37d8040ca423ed29536fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1d8b415d37d8040ca423ed29536fde">&#9670;&#160;</a></span>PHYSFS_fileLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a> PHYSFS_fileLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get total length of a file in bytes. </p>
<p>Note that if another process/thread is writing to this file at the same time, then the information this function supplies could be incorrect before you get it. Use with caution, or better yet, don't use at all.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>handle returned from PHYSFS_open*(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size in bytes of the file. -1 if can't be determined.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a0d481bdd4cf32ed1a41540ee59840c24" title="Determine current position within a PhysicsFS filehandle.">PHYSFS_tell</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#ae562b45b1e1b02505ce1d82ad785f04a" title="Seek to a new position within a PhysicsFS filehandle.">PHYSFS_seek</a> </dd></dl>

</div>
</div>
<a id="a3fd8f9cfdfd09f4fb778a386d8e97e8a" name="a3fd8f9cfdfd09f4fb778a386d8e97e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd8f9cfdfd09f4fb778a386d8e97e8a">&#9670;&#160;</a></span>PHYSFS_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush a buffered PhysicsFS file handle. </p>
<p>For buffered files opened for writing, this will put the current contents of the buffer to disk and flag the buffer as empty if possible.</p>
<p>For buffered files opened for reading or unbuffered files, this is a safe no-op, and will report success.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>handle returned from PHYSFS_open*(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nonzero if successful, zero on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#aede5de47197e1a613d2091802befc886" title="Set up buffering for a PhysicsFS file handle.">PHYSFS_setBuffer</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a6822f8ff10073e855a1c3a6485b882f2" title="Close a PhysicsFS filehandle.">PHYSFS_close</a> </dd></dl>

</div>
</div>
<a id="af6aeb2ffdcee44f02cf380da62462b05" name="af6aeb2ffdcee44f02cf380da62462b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6aeb2ffdcee44f02cf380da62462b05">&#9670;&#160;</a></span>PHYSFS_freeList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> PHYSFS_freeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *&#160;</td>
          <td class="paramname"><em>listVar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate resources of lists returned by PhysicsFS. </p>
<p>Certain PhysicsFS functions return lists of information that are dynamically allocated. Use this function to free those resources.</p>
<p>It is safe to pass a NULL here, but doing so will cause a crash in versions before PhysicsFS 2.1.0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listVar</td><td>List of information specified as freeable by this function. Passing NULL is safe; it is a valid no-op.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#af9a9674a36f7c96ed7813f9db06eefed" title="Get an array of paths to available CD-ROM drives.">PHYSFS_getCdRomDirs</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a0f4ae950c2dae0735a91263ddd20fbf4" title="Get a file listing of a search path&#39;s directory.">PHYSFS_enumerateFiles</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#ac738531e9c7e5ca3797b64985c103cf4" title="Get the current search path.">PHYSFS_getSearchPath</a> </dd></dl>

</div>
</div>
<a id="aaa1ce4636c87fdb6e080b1376fd7b25e" name="aaa1ce4636c87fdb6e080b1376fd7b25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa1ce4636c87fdb6e080b1376fd7b25e">&#9670;&#160;</a></span>PHYSFS_getAllocator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="struct_p_h_y_s_f_s___allocator.html">PHYSFS_Allocator</a> * PHYSFS_getAllocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_discover.html">Discover</a> the current allocator. </p>
<p>(This is for limited, hardcore use. If you don't immediately see a need for it, you can probably ignore this forever.)</p>
<p>This function exposes the function pointers that make up the currently used allocator. This can be useful for apps that want to access PhysicsFS's internal, default allocation routines, as well as for external code that wants to share the same allocator, even if the application specified their own.</p>
<p>This call is only valid between <a class="el" href="physfs_8h.html#a61b94cac8e65267afb8a5f2344e60dd1" title="Initialize the PhysicsFS library.">PHYSFS_init()</a> and <a class="el" href="physfs_8h.html#aa465c9b58e5020f503085d433a413b5b" title="Deinitialize the PhysicsFS library.">PHYSFS_deinit()</a> calls; it will return NULL if the library isn't initialized. As we can't guarantee the state of the internal allocators unless the library is initialized, you shouldn't use any allocator returned here after a call to <a class="el" href="physfs_8h.html#aa465c9b58e5020f503085d433a413b5b" title="Deinitialize the PhysicsFS library.">PHYSFS_deinit()</a>.</p>
<p>Do not call the returned allocator's Init() or Deinit() methods under any circumstances.</p>
<p>If you aren't immediately sure what to do with this function, you can safely ignore it altogether.</p>
<dl class="section return"><dt>Returns</dt><dd>Current allocator, as set by <a class="el" href="physfs_8h.html#ae6297d1ae7755b9236b01950bfbb0ef1" title="Hook your own allocation routines into PhysicsFS.">PHYSFS_setAllocator()</a>, or PhysicsFS's internal, default allocator if no application defined allocator is currently set. Will return NULL if the library is not initialized.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_p_h_y_s_f_s___allocator.html" title="PhysicsFS allocation function pointers.">PHYSFS_Allocator</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#ae6297d1ae7755b9236b01950bfbb0ef1" title="Hook your own allocation routines into PhysicsFS.">PHYSFS_setAllocator</a> </dd></dl>

</div>
</div>
<a id="a0034c327dfb381a1c95deb80878bcede" name="a0034c327dfb381a1c95deb80878bcede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0034c327dfb381a1c95deb80878bcede">&#9670;&#160;</a></span>PHYSFS_getBaseDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char * PHYSFS_getBaseDir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the path where the application resides. </p>
<p>Helper function.</p>
<p>Get the "base dir". This is the directory where the application was run from, which is probably the installation directory, and may or may not be the process's current working directory.</p>
<p>You should probably use the base dir in your search path.</p>
<dl class="section return"><dt>Returns</dt><dd>READ ONLY string of base dir in platform-dependent notation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#acd87392d234d070695303521bb8052a5" title="Get the user-and-app-specific path where files can be written.">PHYSFS_getPrefDir</a> </dd></dl>

</div>
</div>
<a id="af9a9674a36f7c96ed7813f9db06eefed" name="af9a9674a36f7c96ed7813f9db06eefed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a9674a36f7c96ed7813f9db06eefed">&#9670;&#160;</a></span>PHYSFS_getCdRomDirs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ** PHYSFS_getCdRomDirs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an array of paths to available CD-ROM drives. </p>
<p>The dirs returned are platform-dependent ("D:\" on Win32, "/cdrom" or
 whatnot on Unix). Dirs are only returned if there is a disc ready and
 accessible in the drive. So if you've got two drives (D: and E:), and only
 E: has a disc in it, then that's all you get. If the user inserts a disc
 in D: and you call this function again, you get both drives. If, on a
 Unix box, the user unmounts a disc and remounts it elsewhere, the next
 call to this function will reflect that change.

This function refers to "CD-ROM" media, but it really means "inserted disc media," such as DVD-ROM, HD-DVD, CDRW, and Blu-Ray discs. It looks for
 filesystems, and as such won't report an audio CD, unless there's a
 mounted filesystem track on it.

The returned value is an array of strings, with a NULL entry to signify the
 end of the list:

@code 
char **cds = PHYSFS_getCdRomDirs();
char **i;

for (i = cds; *i != NULL; i++)
    printf("cdrom dir [s] is available.<br  />
", *i);</p>
<p>PHYSFS_freeList(cds); </p>
<p>This call may block while drives spin up. Be forewarned.</p>
<p>When you are done with the returned information, you may dispose of the resources by calling <a class="el" href="physfs_8h.html#af6aeb2ffdcee44f02cf380da62462b05" title="Deallocate resources of lists returned by PhysicsFS.">PHYSFS_freeList()</a> with the returned pointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Null-terminated array of null-terminated strings.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#ace04dfd0654ce55a81a85f57f56c7410" title="Enumerate CD-ROM directories, using an application-defined callback.">PHYSFS_getCdRomDirsCallback</a> </dd></dl>

</div>
</div>
<a id="ace04dfd0654ce55a81a85f57f56c7410" name="ace04dfd0654ce55a81a85f57f56c7410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace04dfd0654ce55a81a85f57f56c7410">&#9670;&#160;</a></span>PHYSFS_getCdRomDirsCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> PHYSFS_getCdRomDirsCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a6331ac65f8e0d32288f8597e48188a4f">PHYSFS_StringCallback</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerate CD-ROM directories, using an application-defined callback. </p>
<p>Internally, <a class="el" href="physfs_8h.html#af9a9674a36f7c96ed7813f9db06eefed" title="Get an array of paths to available CD-ROM drives.">PHYSFS_getCdRomDirs()</a> just calls this function and then builds a list before returning to the application, so functionality is identical except for how the information is represented to the application.</p>
<p>Unlike <a class="el" href="physfs_8h.html#af9a9674a36f7c96ed7813f9db06eefed" title="Get an array of paths to available CD-ROM drives.">PHYSFS_getCdRomDirs()</a>, this function does not return an array. Rather, it calls a function specified by the application once per detected disc:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> foundDisc(<span class="keywordtype">void</span> *<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *cddir)</div>
<div class="line">{</div>
<div class="line">    printf(<span class="stringliteral">&quot;cdrom dir [%s] is available.\n&quot;</span>, cddir);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><a class="code hl_function" href="physfs_8h.html#ace04dfd0654ce55a81a85f57f56c7410">PHYSFS_getCdRomDirsCallback</a>(foundDisc, NULL);</div>
<div class="ttc" id="aphysfs_8h_html_ace04dfd0654ce55a81a85f57f56c7410"><div class="ttname"><a href="physfs_8h.html#ace04dfd0654ce55a81a85f57f56c7410">PHYSFS_getCdRomDirsCallback</a></div><div class="ttdeci">PHYSFS_DECL void PHYSFS_getCdRomDirsCallback(PHYSFS_StringCallback c, void *d)</div><div class="ttdoc">Enumerate CD-ROM directories, using an application-defined callback.</div></div>
</div><!-- fragment --><p>This call may block while drives spin up. Be forewarned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Callback function to notify about detected drives. </td></tr>
    <tr><td class="paramname">d</td><td>Application-defined data passed to callback. Can be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a6331ac65f8e0d32288f8597e48188a4f" title="Function signature for callbacks that report strings.">PHYSFS_StringCallback</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#af9a9674a36f7c96ed7813f9db06eefed" title="Get an array of paths to available CD-ROM drives.">PHYSFS_getCdRomDirs</a> </dd></dl>

</div>
</div>
<a id="ad1dc17d387c45e9155d1f0c348a7cbcc" name="ad1dc17d387c45e9155d1f0c348a7cbcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1dc17d387c45e9155d1f0c348a7cbcc">&#9670;&#160;</a></span>PHYSFS_getDirSeparator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char * PHYSFS_getDirSeparator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get platform-dependent dir separator string. </p>
<p>This returns "\\" on win32, "/" on Unix, and ":" on MacOS. It may be more than one character, depending on the platform, and your code should take that into account. Note that this is only useful for setting up the search/write paths, since access into those dirs always use '/' (platform-independent notation) to separate directories. This is also handy for getting platform-independent access when using stdio calls.</p>
<dl class="section return"><dt>Returns</dt><dd>READ ONLY null-terminated string of platform's dir separator. </dd></dl>

</div>
</div>
<a id="a545f6b5ba97faa19441932dffb65c3be" name="a545f6b5ba97faa19441932dffb65c3be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a545f6b5ba97faa19441932dffb65c3be">&#9670;&#160;</a></span>PHYSFS_getErrorByCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char * PHYSFS_getErrorByCode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afed">PHYSFS_ErrorCode</a>&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get human-readable description string for a given error code. </p>
<p>Get a static string, in UTF-8 format, that represents an English description of a given error code.</p>
<p>This string is guaranteed to never change (although we may add new strings for new error codes in later versions of PhysicsFS), so you can use it for keying a localization dictionary.</p>
<p>It is safe to call this function at anytime, even before <a class="el" href="physfs_8h.html#a61b94cac8e65267afb8a5f2344e60dd1" title="Initialize the PhysicsFS library.">PHYSFS_init()</a>.</p>
<p>These strings are meant to be passed on directly to the user. Generally, applications should only concern themselves with whether a given function failed, but not care about the specifics much.</p>
<p>Do not attempt to free the returned strings; they are read-only and you don't own their memory pages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>Error code to convert to a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>READ ONLY string of requested error message, NULL if this is not a valid PhysicsFS error code. Always check for NULL if you might be looking up an error code that didn't exist in an earlier version of PhysicsFS.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode</a> </dd></dl>

</div>
</div>
<a id="a619e0a12b15035f8def90f4ba40ec5d5" name="a619e0a12b15035f8def90f4ba40ec5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619e0a12b15035f8def90f4ba40ec5d5">&#9670;&#160;</a></span>PHYSFS_getLastError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char * PHYSFS_getLastError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get human-readable error information. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Use <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a> and <a class="el" href="physfs_8h.html#a545f6b5ba97faa19441932dffb65c3be" title="Get human-readable description string for a given error code.">PHYSFS_getErrorByCode()</a> instead.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>As of PhysicsFS 2.1, this function has been nerfed. Before PhysicsFS 2.1, this function was the only way to get error details beyond a given function's basic return value. This was meant to be a human-readable string in one of several languages, and was not useful for application parsing. This was a problem, because the developer and not the user chose the language at compile time, and the PhysicsFS maintainers had to (poorly) maintain a significant amount of localization work. The app couldn't parse the strings, even if they counted on a specific language, since some were dynamically generated. In 2.1 and later, this always returns a static string in English; you may use it as a key string for your own localizations if you like, as we'll promise not to change existing error strings. Also, if your application wants to look at specific errors, we now offer a better option: use <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a> instead.</dd></dl>
<p>Get the last PhysicsFS error message as a human-readable, null-terminated string. This will return NULL if there's been no error since the last call to this function. The pointer returned by this call points to an internal buffer. Each thread has a unique error state associated with it, but each time a new error message is set, it will overwrite the previous one associated with that thread. It is safe to call this function at anytime, even before <a class="el" href="physfs_8h.html#a61b94cac8e65267afb8a5f2344e60dd1" title="Initialize the PhysicsFS library.">PHYSFS_init()</a>.</p>
<p><a class="el" href="physfs_8h.html#a619e0a12b15035f8def90f4ba40ec5d5" title="Get human-readable error information.">PHYSFS_getLastError()</a> and <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a> both reset the same thread-specific error state. Calling one will wipe out the other's data. If you need both, call <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>, then pass that value to <a class="el" href="physfs_8h.html#a545f6b5ba97faa19441932dffb65c3be" title="Get human-readable description string for a given error code.">PHYSFS_getErrorByCode()</a>.</p>
<p>As of PhysicsFS 2.1, this function only presents text in the English language, but the strings are static, so you can use them as keys into your own localization dictionary. These strings are meant to be passed on directly to the user.</p>
<p>Generally, applications should only concern themselves with whether a given function failed; however, if your code require more specifics, you should use <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a> instead of this function.</p>
<dl class="section return"><dt>Returns</dt><dd>READ ONLY string of last error message.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a545f6b5ba97faa19441932dffb65c3be" title="Get human-readable description string for a given error code.">PHYSFS_getErrorByCode</a> </dd></dl>

</div>
</div>
<a id="ae916a873aae2cf6b6e09d733cd1b3f4b" name="ae916a873aae2cf6b6e09d733cd1b3f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae916a873aae2cf6b6e09d733cd1b3f4b">&#9670;&#160;</a></span>PHYSFS_getLastErrorCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afed">PHYSFS_ErrorCode</a> PHYSFS_getLastErrorCode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get machine-readable error information. </p>
<p>Get the last PhysicsFS error message as an integer value. This will return PHYSFS_ERR_OK if there's been no error since the last call to this function. Each thread has a unique error state associated with it, but each time a new error message is set, it will overwrite the previous one associated with that thread. It is safe to call this function at anytime, even before <a class="el" href="physfs_8h.html#a61b94cac8e65267afb8a5f2344e60dd1" title="Initialize the PhysicsFS library.">PHYSFS_init()</a>.</p>
<p><a class="el" href="physfs_8h.html#a619e0a12b15035f8def90f4ba40ec5d5" title="Get human-readable error information.">PHYSFS_getLastError()</a> and <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a> both reset the same thread-specific error state. Calling one will wipe out the other's data. If you need both, call <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>, then pass that value to <a class="el" href="physfs_8h.html#a545f6b5ba97faa19441932dffb65c3be" title="Get human-readable description string for a given error code.">PHYSFS_getErrorByCode()</a>.</p>
<p>Generally, applications should only concern themselves with whether a given function failed; however, if you require more specifics, you can try this function to glean information, if there's some specific problem you're expecting and plan to handle. But with most things that involve file systems, the best course of action is usually to give up, report the problem to the user, and let them figure out what should be done about it. For that, you might prefer <a class="el" href="physfs_8h.html#a545f6b5ba97faa19441932dffb65c3be" title="Get human-readable description string for a given error code.">PHYSFS_getErrorByCode()</a> instead.</p>
<dl class="section return"><dt>Returns</dt><dd>Enumeration value that represents last reported error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a545f6b5ba97faa19441932dffb65c3be" title="Get human-readable description string for a given error code.">PHYSFS_getErrorByCode</a> </dd></dl>

</div>
</div>
<a id="ae1023468c3de4be1cf24760b54dd9768" name="ae1023468c3de4be1cf24760b54dd9768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1023468c3de4be1cf24760b54dd9768">&#9670;&#160;</a></span>PHYSFS_getLastModTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a> PHYSFS_getLastModTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the last modification time of a file. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>As of PhysicsFS 2.1, use <a class="el" href="physfs_8h.html#a7f5e23675c50ffe51ad00cceb5a65348" title="Get various information about a directory or a file.">PHYSFS_stat()</a> instead. This function just wraps it anyhow.</dd></dl>
<p>The modtime is returned as a number of seconds since the Unix epoch (midnight, Jan 1, 1970). The exact derivation and accuracy of this time depends on the particular archiver. If there is no reasonable way to obtain this information for a particular archiver, or there was some sort of error, this function returns (-1).</p>
<p>You must use this and not <a class="el" href="physfs_8h.html#a7f5e23675c50ffe51ad00cceb5a65348" title="Get various information about a directory or a file.">PHYSFS_stat()</a> if binary compatibility with PhysicsFS 2.0 is important (which it may not be for many people).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>filename to check, in platform-independent notation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last modified time of the file. -1 if it can't be determined.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a7f5e23675c50ffe51ad00cceb5a65348" title="Get various information about a directory or a file.">PHYSFS_stat</a> </dd></dl>

</div>
</div>
<a id="a8977d0ba0a2301256e823532479f1a05" name="a8977d0ba0a2301256e823532479f1a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8977d0ba0a2301256e823532479f1a05">&#9670;&#160;</a></span>PHYSFS_getLinkedVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> PHYSFS_getLinkedVersion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___version.html">PHYSFS_Version</a> *&#160;</td>
          <td class="paramname"><em>ver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the version of PhysicsFS that is linked against your program. </p>
<p>If you are using a shared library (DLL) version of PhysFS, then it is possible that it will be different than the version you compiled against.</p>
<p>This is a real function; the macro PHYSFS_VERSION tells you what version of PhysFS you compiled against:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="struct_p_h_y_s_f_s___version.html">PHYSFS_Version</a> compiled;</div>
<div class="line"><a class="code hl_struct" href="struct_p_h_y_s_f_s___version.html">PHYSFS_Version</a> linked;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="physfs_8h.html#acb77c1f8f70028add43b9f81eef1ed78">PHYSFS_VERSION</a>(&amp;compiled);</div>
<div class="line"><a class="code hl_function" href="physfs_8h.html#a8977d0ba0a2301256e823532479f1a05">PHYSFS_getLinkedVersion</a>(&amp;linked);</div>
<div class="line">printf(<span class="stringliteral">&quot;We compiled against PhysFS version %d.%d.%d ...\n&quot;</span>,</div>
<div class="line">          compiled.<a class="code hl_variable" href="struct_p_h_y_s_f_s___version.html#ac60a805b6b7c342cb1718356f5be4dc2">major</a>, compiled.<a class="code hl_variable" href="struct_p_h_y_s_f_s___version.html#a753a884de5c4ef33bff3dfb2e0bb1a0c">minor</a>, compiled.<a class="code hl_variable" href="struct_p_h_y_s_f_s___version.html#a565624d6f0785e5cb4c706583c682e20">patch</a>);</div>
<div class="line">printf(<span class="stringliteral">&quot;But we linked against PhysFS version %d.%d.%d.\n&quot;</span>,</div>
<div class="line">          linked.<a class="code hl_variable" href="struct_p_h_y_s_f_s___version.html#ac60a805b6b7c342cb1718356f5be4dc2">major</a>, linked.<a class="code hl_variable" href="struct_p_h_y_s_f_s___version.html#a753a884de5c4ef33bff3dfb2e0bb1a0c">minor</a>, linked.<a class="code hl_variable" href="struct_p_h_y_s_f_s___version.html#a565624d6f0785e5cb4c706583c682e20">patch</a>);</div>
<div class="ttc" id="aphysfs_8h_html_a8977d0ba0a2301256e823532479f1a05"><div class="ttname"><a href="physfs_8h.html#a8977d0ba0a2301256e823532479f1a05">PHYSFS_getLinkedVersion</a></div><div class="ttdeci">PHYSFS_DECL void PHYSFS_getLinkedVersion(PHYSFS_Version *ver)</div><div class="ttdoc">Get the version of PhysicsFS that is linked against your program.</div></div>
<div class="ttc" id="aphysfs_8h_html_acb77c1f8f70028add43b9f81eef1ed78"><div class="ttname"><a href="physfs_8h.html#acb77c1f8f70028add43b9f81eef1ed78">PHYSFS_VERSION</a></div><div class="ttdeci">#define PHYSFS_VERSION(x)</div><div class="ttdoc">Macro to determine PhysicsFS version program was compiled against.</div><div class="ttdef"><b>Definition</b> physfs.h:459</div></div>
<div class="ttc" id="astruct_p_h_y_s_f_s___version_html"><div class="ttname"><a href="struct_p_h_y_s_f_s___version.html">PHYSFS_Version</a></div><div class="ttdoc">Information the version of PhysicsFS in use.</div><div class="ttdef"><b>Definition</b> physfs.h:427</div></div>
<div class="ttc" id="astruct_p_h_y_s_f_s___version_html_a565624d6f0785e5cb4c706583c682e20"><div class="ttname"><a href="struct_p_h_y_s_f_s___version.html#a565624d6f0785e5cb4c706583c682e20">PHYSFS_Version::patch</a></div><div class="ttdeci">PHYSFS_uint8 patch</div><div class="ttdoc">patchlevel</div><div class="ttdef"><b>Definition</b> physfs.h:430</div></div>
<div class="ttc" id="astruct_p_h_y_s_f_s___version_html_a753a884de5c4ef33bff3dfb2e0bb1a0c"><div class="ttname"><a href="struct_p_h_y_s_f_s___version.html#a753a884de5c4ef33bff3dfb2e0bb1a0c">PHYSFS_Version::minor</a></div><div class="ttdeci">PHYSFS_uint8 minor</div><div class="ttdoc">minor revision</div><div class="ttdef"><b>Definition</b> physfs.h:429</div></div>
<div class="ttc" id="astruct_p_h_y_s_f_s___version_html_ac60a805b6b7c342cb1718356f5be4dc2"><div class="ttname"><a href="struct_p_h_y_s_f_s___version.html#ac60a805b6b7c342cb1718356f5be4dc2">PHYSFS_Version::major</a></div><div class="ttdeci">PHYSFS_uint8 major</div><div class="ttdoc">major revision</div><div class="ttdef"><b>Definition</b> physfs.h:428</div></div>
</div><!-- fragment --><p>This function may be called safely at any time, even before <a class="el" href="physfs_8h.html#a61b94cac8e65267afb8a5f2344e60dd1" title="Initialize the PhysicsFS library.">PHYSFS_init()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#acb77c1f8f70028add43b9f81eef1ed78" title="Macro to determine PhysicsFS version program was compiled against.">PHYSFS_VERSION</a> </dd></dl>

</div>
</div>
<a id="a365aee0c326b0e6bfbba5c039f7c4b5b" name="a365aee0c326b0e6bfbba5c039f7c4b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365aee0c326b0e6bfbba5c039f7c4b5b">&#9670;&#160;</a></span>PHYSFS_getMountPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_getMountPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine a mounted archive's mountpoint. </p>
<p>You give this function the name of an archive or dir you successfully added to the search path, and it reports the location in the interpolated tree where it is mounted. Files mounted with a NULL mountpoint or through <a class="el" href="physfs_8h.html#ae9a677c869257742cbe5417dec9b3cee" title="Add an archive or directory to the search path.">PHYSFS_addToSearchPath()</a> will report "/". The return value is READ ONLY and valid until the archive is removed from the search path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>directory or archive previously added to the path, in platform-dependent notation. This must match the string used when adding, even if your string would also reference the same file with a different string of characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>READ-ONLY string of mount point if added to path, NULL on failure (bogus archive, etc). Use <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a> to obtain the specific error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a555ee86816418ed3a99e10243c5db7b8" title="Remove a directory or archive from the search path.">PHYSFS_removeFromSearchPath</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#ac738531e9c7e5ca3797b64985c103cf4" title="Get the current search path.">PHYSFS_getSearchPath</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a365aee0c326b0e6bfbba5c039f7c4b5b" title="Determine a mounted archive&#39;s mountpoint.">PHYSFS_getMountPoint</a> </dd></dl>

</div>
</div>
<a id="acd87392d234d070695303521bb8052a5" name="acd87392d234d070695303521bb8052a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd87392d234d070695303521bb8052a5">&#9670;&#160;</a></span>PHYSFS_getPrefDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char * PHYSFS_getPrefDir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>org</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>app</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the user-and-app-specific path where files can be written. </p>
<p>Helper function.</p>
<p>Get the "pref dir". This is meant to be where users can write personal files (preferences and save games, etc) that are specific to your application. This directory is unique per user, per application.</p>
<p>This function will decide the appropriate location in the native filesystem, create the directory if necessary, and return a string in platform-dependent notation, suitable for passing to <a class="el" href="physfs_8h.html#a36c408d40b3a93c8f9fc02a16c02e430" title="Tell PhysicsFS where it may write files.">PHYSFS_setWriteDir()</a>.</p>
<p>On Windows, this might look like: "C:\\Users\\bob\\AppData\\Roaming\\My Company\\My Program Name"</p>
<p>On Linux, this might look like: "/home/bob/.local/share/My Program Name"</p>
<p>On Mac OS X, this might look like: "/Users/bob/Library/Application Support/My Program Name"</p>
<p>(etc.)</p>
<p>You should probably use the pref dir for your write dir, and also put it near the beginning of your search path. Older versions of PhysicsFS offered only <a class="el" href="physfs_8h.html#a4ea627ea1124ae42ec8e8d60401d86fd" title="Get the path where user&#39;s home directory resides.">PHYSFS_getUserDir()</a> and left you to figure out where the files should go under that tree. This finds the correct location for whatever platform, which not only changes between operating systems, but also versions of the same operating system.</p>
<p>You specify the name of your organization (if it's not a real organization, your name or an Internet domain you own might do) and the name of your application. These should be proper names.</p>
<p>Both the (org) and (app) strings may become part of a directory name, so please follow these rules:</p>
<ul>
<li>Try to use the same org string (including case-sensitivity) for all your applications that use this function.</li>
<li>Always use a unique app string for each one, and make sure it never changes for an app once you've decided on it.</li>
<li>Unicode characters are legal, as long as it's UTF-8 encoded, but...</li>
<li>...only use letters, numbers, and spaces. Avoid punctuation like "Game Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.</li>
</ul>
<p>The pointer returned by this function remains valid until you call this function again, or call <a class="el" href="physfs_8h.html#aa465c9b58e5020f503085d433a413b5b" title="Deinitialize the PhysicsFS library.">PHYSFS_deinit()</a>. This is not necessarily a fast call, though, so you should call this once at startup and copy the string if you need it.</p>
<p>You should assume the path returned by this function is the only safe place to write files (and that <a class="el" href="physfs_8h.html#a4ea627ea1124ae42ec8e8d60401d86fd" title="Get the path where user&#39;s home directory resides.">PHYSFS_getUserDir()</a> and <a class="el" href="physfs_8h.html#a0034c327dfb381a1c95deb80878bcede" title="Get the path where the application resides.">PHYSFS_getBaseDir()</a>, while they might be writable, or even parents of the returned path, aren't where you should be writing things).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">org</td><td>The name of your organization. </td></tr>
    <tr><td class="paramname">app</td><td>The name of your application. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>READ ONLY string of user dir in platform-dependent notation. NULL if there's a problem (creating directory failed, etc).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a0034c327dfb381a1c95deb80878bcede" title="Get the path where the application resides.">PHYSFS_getBaseDir</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a4ea627ea1124ae42ec8e8d60401d86fd" title="Get the path where user&#39;s home directory resides.">PHYSFS_getUserDir</a> </dd></dl>

</div>
</div>
<a id="a539bcf0ebde6271e3e4a90dd287ca975" name="a539bcf0ebde6271e3e4a90dd287ca975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a539bcf0ebde6271e3e4a90dd287ca975">&#9670;&#160;</a></span>PHYSFS_getRealDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char * PHYSFS_getRealDir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Figure out where in the search path a file resides. </p>
<p>The file is specified in platform-independent notation. The returned filename will be the element of the search path where the file was found, which may be a directory, or an archive. Even if there are multiple matches in different parts of the search path, only the first one found is used, just like when opening a file.</p>
<p>So, if you look for "maps/level1.map", and C:\mygame is in your search path and C:\mygame\maps\level1.map exists, then "C:\mygame" is returned.</p>
<p>If a any part of a match is a symbolic link, and you've not explicitly permitted symlinks, then it will be ignored, and the search for a match will continue.</p>
<p>If you specify a fake directory that only exists as a mount point, it'll be associated with the first archive mounted there, even though that directory isn't necessarily contained in a real archive.</p>
<dl class="section warning"><dt>Warning</dt><dd>This will return NULL if there is no real directory associated with (filename). Specifically, <a class="el" href="physfs_8h.html#a7ac107cf895f50f0d2219cdf44b8b758" title="Add an archive, built on a PHYSFS_Io, to the search path.">PHYSFS_mountIo()</a>, <a class="el" href="physfs_8h.html#a0a977d04da585859e132ba4700df5d3a" title="Add an archive, contained in a memory buffer, to the search path.">PHYSFS_mountMemory()</a>, and <a class="el" href="physfs_8h.html#a05407734c567ced1cffce64c6b1f0e93" title="Add an archive, contained in a PHYSFS_File handle, to the search path.">PHYSFS_mountHandle()</a> will return NULL even if the filename is found in the search path. Plan accordingly.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>file to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>READ ONLY string of element of search path containing the the file in question. NULL if not found. </dd></dl>

</div>
</div>
<a id="ac738531e9c7e5ca3797b64985c103cf4" name="ac738531e9c7e5ca3797b64985c103cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac738531e9c7e5ca3797b64985c103cf4">&#9670;&#160;</a></span>PHYSFS_getSearchPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ** PHYSFS_getSearchPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current search path. </p>
<p>The default search path is an empty list.</p>
<p>The returned value is an array of strings, with a NULL entry to signify the end of the list:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> **i;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (i = <a class="code hl_function" href="physfs_8h.html#ac738531e9c7e5ca3797b64985c103cf4">PHYSFS_getSearchPath</a>(); *i != NULL; i++)</div>
<div class="line">    printf(<span class="stringliteral">&quot;[%s] is in the search path.\n&quot;</span>, *i);</div>
<div class="ttc" id="aphysfs_8h_html_ac738531e9c7e5ca3797b64985c103cf4"><div class="ttname"><a href="physfs_8h.html#ac738531e9c7e5ca3797b64985c103cf4">PHYSFS_getSearchPath</a></div><div class="ttdeci">PHYSFS_DECL char ** PHYSFS_getSearchPath(void)</div><div class="ttdoc">Get the current search path.</div></div>
</div><!-- fragment --><p>When you are done with the returned information, you may dispose of the resources by calling <a class="el" href="physfs_8h.html#af6aeb2ffdcee44f02cf380da62462b05" title="Deallocate resources of lists returned by PhysicsFS.">PHYSFS_freeList()</a> with the returned pointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Null-terminated array of null-terminated strings. NULL if there was a problem (read: OUT OF MEMORY).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#abd5f7188ab27722b0651e7503c6a737a" title="Enumerate the search path, using an application-defined callback.">PHYSFS_getSearchPathCallback</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#ae9a677c869257742cbe5417dec9b3cee" title="Add an archive or directory to the search path.">PHYSFS_addToSearchPath</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a555ee86816418ed3a99e10243c5db7b8" title="Remove a directory or archive from the search path.">PHYSFS_removeFromSearchPath</a> </dd></dl>

</div>
</div>
<a id="abd5f7188ab27722b0651e7503c6a737a" name="abd5f7188ab27722b0651e7503c6a737a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5f7188ab27722b0651e7503c6a737a">&#9670;&#160;</a></span>PHYSFS_getSearchPathCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> PHYSFS_getSearchPathCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a6331ac65f8e0d32288f8597e48188a4f">PHYSFS_StringCallback</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerate the search path, using an application-defined callback. </p>
<p>Internally, <a class="el" href="physfs_8h.html#ac738531e9c7e5ca3797b64985c103cf4" title="Get the current search path.">PHYSFS_getSearchPath()</a> just calls this function and then builds a list before returning to the application, so functionality is identical except for how the information is represented to the application.</p>
<p>Unlike <a class="el" href="physfs_8h.html#ac738531e9c7e5ca3797b64985c103cf4" title="Get the current search path.">PHYSFS_getSearchPath()</a>, this function does not return an array. Rather, it calls a function specified by the application once per element of the search path:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> printSearchPath(<span class="keywordtype">void</span> *<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *pathItem)</div>
<div class="line">{</div>
<div class="line">    printf(<span class="stringliteral">&quot;[%s] is in the search path.\n&quot;</span>, pathItem);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><a class="code hl_function" href="physfs_8h.html#abd5f7188ab27722b0651e7503c6a737a">PHYSFS_getSearchPathCallback</a>(printSearchPath, NULL);</div>
<div class="ttc" id="aphysfs_8h_html_abd5f7188ab27722b0651e7503c6a737a"><div class="ttname"><a href="physfs_8h.html#abd5f7188ab27722b0651e7503c6a737a">PHYSFS_getSearchPathCallback</a></div><div class="ttdeci">PHYSFS_DECL void PHYSFS_getSearchPathCallback(PHYSFS_StringCallback c, void *d)</div><div class="ttdoc">Enumerate the search path, using an application-defined callback.</div></div>
</div><!-- fragment --><p>Elements of the search path are reported in order search priority, so the first archive/dir that would be examined when looking for a file is the first element passed through the callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Callback function to notify about search path elements. </td></tr>
    <tr><td class="paramname">d</td><td>Application-defined data passed to callback. Can be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a6331ac65f8e0d32288f8597e48188a4f" title="Function signature for callbacks that report strings.">PHYSFS_StringCallback</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#ac738531e9c7e5ca3797b64985c103cf4" title="Get the current search path.">PHYSFS_getSearchPath</a> </dd></dl>

</div>
</div>
<a id="a4ea627ea1124ae42ec8e8d60401d86fd" name="a4ea627ea1124ae42ec8e8d60401d86fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea627ea1124ae42ec8e8d60401d86fd">&#9670;&#160;</a></span>PHYSFS_getUserDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char * PHYSFS_getUserDir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the path where user's home directory resides. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>As of PhysicsFS 2.1, you probably want <a class="el" href="physfs_8h.html#acd87392d234d070695303521bb8052a5" title="Get the user-and-app-specific path where files can be written.">PHYSFS_getPrefDir()</a>.</dd></dl>
<p>Helper function.</p>
<p>Get the "user dir". This is meant to be a suggestion of where a specific user of the system can store files. On Unix, this is her home directory. On systems with no concept of multiple home directories (MacOS, win95), this will default to something like "C:\mybasedir\users\username" where "username" will either be the login name, or "default" if the platform doesn't support multiple users, either.</p>
<dl class="section return"><dt>Returns</dt><dd>READ ONLY string of user dir in platform-dependent notation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a0034c327dfb381a1c95deb80878bcede" title="Get the path where the application resides.">PHYSFS_getBaseDir</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#acd87392d234d070695303521bb8052a5" title="Get the user-and-app-specific path where files can be written.">PHYSFS_getPrefDir</a> </dd></dl>

</div>
</div>
<a id="a6533ff91180a4c8abfe24d458f6b9915" name="a6533ff91180a4c8abfe24d458f6b9915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6533ff91180a4c8abfe24d458f6b9915">&#9670;&#160;</a></span>PHYSFS_getWriteDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char * PHYSFS_getWriteDir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get path where PhysicsFS will allow file writing. </p>
<p>Get the current write dir. The default write dir is NULL.</p>
<dl class="section return"><dt>Returns</dt><dd>READ ONLY string of write dir in platform-dependent notation, OR NULL IF NO WRITE PATH IS CURRENTLY SET.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a36c408d40b3a93c8f9fc02a16c02e430" title="Tell PhysicsFS where it may write files.">PHYSFS_setWriteDir</a> </dd></dl>

</div>
</div>
<a id="a61b94cac8e65267afb8a5f2344e60dd1" name="a61b94cac8e65267afb8a5f2344e60dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b94cac8e65267afb8a5f2344e60dd1">&#9670;&#160;</a></span>PHYSFS_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>argv0</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the PhysicsFS library. </p>
<p>This must be called before any other PhysicsFS function.</p>
<p>This should be called prior to any attempts to change your process's current working directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argv0</td><td>the argv[0] string passed to your program's mainline. This may be NULL on most platforms (such as ones without a standard <a class="el" href="aliphone_8h.html#aa4e97f3782107649d3e4eb3875090b3a">main()</a> function), but you should always try to pass something in here. Unix-like systems such as Linux <em>need</em> to pass argv[0] from <a class="el" href="aliphone_8h.html#aa4e97f3782107649d3e4eb3875090b3a">main()</a> in here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nonzero on success, zero on error. Specifics of the error can be gleaned from <a class="el" href="physfs_8h.html#a619e0a12b15035f8def90f4ba40ec5d5" title="Get human-readable error information.">PHYSFS_getLastError()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#aa465c9b58e5020f503085d433a413b5b" title="Deinitialize the PhysicsFS library.">PHYSFS_deinit</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a6154be7bfa5d924476356a9fbd0d8223" title="Determine if the PhysicsFS library is initialized.">PHYSFS_isInit</a> </dd></dl>

</div>
</div>
<a id="a50d98fb3544e0c554598d222efa74d4a" name="a50d98fb3544e0c554598d222efa74d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50d98fb3544e0c554598d222efa74d4a">&#9670;&#160;</a></span>PHYSFS_isDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_isDirectory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a file in the search path is really a directory. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>As of PhysicsFS 2.1, use <a class="el" href="physfs_8h.html#a7f5e23675c50ffe51ad00cceb5a65348" title="Get various information about a directory or a file.">PHYSFS_stat()</a> instead. This function just wraps it anyhow.</dd></dl>
<p>Determine if the first occurence of (fname) in the search path is really a directory entry.</p>
<p>Note that entries that are symlinks are ignored if PHYSFS_permitSymbolicLinks(1) hasn't been called, so you might end up further down in the search path than expected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>filename in platform-independent notation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if filename exists and is a directory. zero otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a7f5e23675c50ffe51ad00cceb5a65348" title="Get various information about a directory or a file.">PHYSFS_stat</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#accd31941b636ff153d328aebf72048c7" title="Determine if a file exists in the search path.">PHYSFS_exists</a> </dd></dl>

</div>
</div>
<a id="a6154be7bfa5d924476356a9fbd0d8223" name="a6154be7bfa5d924476356a9fbd0d8223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6154be7bfa5d924476356a9fbd0d8223">&#9670;&#160;</a></span>PHYSFS_isInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_isInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the PhysicsFS library is initialized. </p>
<p>Once <a class="el" href="physfs_8h.html#a61b94cac8e65267afb8a5f2344e60dd1" title="Initialize the PhysicsFS library.">PHYSFS_init()</a> returns successfully, this will return non-zero. Before a successful <a class="el" href="physfs_8h.html#a61b94cac8e65267afb8a5f2344e60dd1" title="Initialize the PhysicsFS library.">PHYSFS_init()</a> and after <a class="el" href="physfs_8h.html#aa465c9b58e5020f503085d433a413b5b" title="Deinitialize the PhysicsFS library.">PHYSFS_deinit()</a> returns successfully, this will return zero. This function is safe to call at any time.</p>
<dl class="section return"><dt>Returns</dt><dd>non-zero if library is initialized, zero if library is not.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a61b94cac8e65267afb8a5f2344e60dd1" title="Initialize the PhysicsFS library.">PHYSFS_init</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#aa465c9b58e5020f503085d433a413b5b" title="Deinitialize the PhysicsFS library.">PHYSFS_deinit</a> </dd></dl>

</div>
</div>
<a id="ae03e201cf5f91645cb5c4fda380295ff" name="ae03e201cf5f91645cb5c4fda380295ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae03e201cf5f91645cb5c4fda380295ff">&#9670;&#160;</a></span>PHYSFS_isSymbolicLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_isSymbolicLink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a file in the search path is really a symbolic link. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>As of PhysicsFS 2.1, use <a class="el" href="physfs_8h.html#a7f5e23675c50ffe51ad00cceb5a65348" title="Get various information about a directory or a file.">PHYSFS_stat()</a> instead. This function just wraps it anyhow.</dd></dl>
<p>Determine if the first occurence of (fname) in the search path is really a symbolic link.</p>
<p>Note that entries that are symlinks are ignored if PHYSFS_permitSymbolicLinks(1) hasn't been called, and as such, this function will always return 0 in that case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>filename in platform-independent notation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if filename exists and is a symlink. zero otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a7f5e23675c50ffe51ad00cceb5a65348" title="Get various information about a directory or a file.">PHYSFS_stat</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#accd31941b636ff153d328aebf72048c7" title="Determine if a file exists in the search path.">PHYSFS_exists</a> </dd></dl>

</div>
</div>
<a id="ae11fb98bf8c08a2e028f52ac9a728aa9" name="ae11fb98bf8c08a2e028f52ac9a728aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11fb98bf8c08a2e028f52ac9a728aa9">&#9670;&#160;</a></span>PHYSFS_mkdir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_mkdir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>dirName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a directory. </p>
<p>This is specified in platform-independent notation in relation to the write dir. All missing parent directories are also created if they don't exist.</p>
<p>So if you've got the write dir set to "C:\mygame\writedir" and call PHYSFS_mkdir("downloads/maps") then the directories "C:\mygame\writedir\downloads" and "C:\mygame\writedir\downloads\maps" will be created if possible. If the creation of "maps" fails after we have successfully created "downloads", then the function leaves the created directory behind and reports failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dirName</td><td>New dir to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nonzero on success, zero on error. Use <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a> to obtain the specific error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a27a939bce4c1132bacdfcb3d3cc29e37" title="Delete a file or directory.">PHYSFS_delete</a> </dd></dl>

</div>
</div>
<a id="a8eb320e9af03dcdb4c05bbff3ea604d4" name="a8eb320e9af03dcdb4c05bbff3ea604d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb320e9af03dcdb4c05bbff3ea604d4">&#9670;&#160;</a></span>PHYSFS_mount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_mount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>newDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>mountPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>appendToPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an archive or directory to the search path. </p>
<p>If this is a duplicate, the entry is not added again, even though the function succeeds. You may not add the same archive to two different mountpoints: duplicate checking is done against the archive and not the mountpoint.</p>
<p>When you mount an archive, it is added to a virtual file system...all files in all of the archives are interpolated into a single hierachical file tree. Two archives mounted at the same place (or an archive with files overlapping another mountpoint) may have overlapping files: in such a case, the file earliest in the search path is selected, and the other files are inaccessible to the application. This allows archives to be used to override previous revisions; you can use the mounting mechanism to place archives at a specific point in the file tree and prevent overlap; this is useful for downloadable mods that might trample over application data or each other, for example.</p>
<p>The mountpoint does not need to exist prior to mounting, which is different than those familiar with the Unix concept of "mounting" may expect. As well, more than one archive can be mounted to the same mountpoint, or mountpoints and archive contents can overlap...the interpolation mechanism still functions as usual.</p>
<p>Specifying a symbolic link to an archive or directory is allowed here, regardless of the state of <a class="el" href="physfs_8h.html#aad451d9b3f46f627a1be8caee2eef9b7" title="Enable or disable following of symbolic links.">PHYSFS_permitSymbolicLinks()</a>. That function only deals with symlinks inside the mounted directory or archive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newDir</td><td>directory or archive to add to the path, in platform-dependent notation. </td></tr>
    <tr><td class="paramname">mountPoint</td><td>Location in the interpolated tree that this archive will be "mounted", in platform-independent notation. NULL or "" is equivalent to "/". </td></tr>
    <tr><td class="paramname">appendToPath</td><td>nonzero to append to search path, zero to prepend. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nonzero if added to path, zero on failure (bogus archive, dir missing, etc). Use <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a> to obtain the specific error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a555ee86816418ed3a99e10243c5db7b8" title="Remove a directory or archive from the search path.">PHYSFS_removeFromSearchPath</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#ac738531e9c7e5ca3797b64985c103cf4" title="Get the current search path.">PHYSFS_getSearchPath</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a365aee0c326b0e6bfbba5c039f7c4b5b" title="Determine a mounted archive&#39;s mountpoint.">PHYSFS_getMountPoint</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a7ac107cf895f50f0d2219cdf44b8b758" title="Add an archive, built on a PHYSFS_Io, to the search path.">PHYSFS_mountIo</a> </dd></dl>

</div>
</div>
<a id="a05407734c567ced1cffce64c6b1f0e93" name="a05407734c567ced1cffce64c6b1f0e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05407734c567ced1cffce64c6b1f0e93">&#9670;&#160;</a></span>PHYSFS_mountHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_mountHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>newDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>mountPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>appendToPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an archive, contained in a <a class="el" href="struct_p_h_y_s_f_s___file.html" title="A PhysicsFS file handle.">PHYSFS_File</a> handle, to the search path. </p>
<dl class="section warning"><dt>Warning</dt><dd>Unless you have some special, low-level need, you should be using <a class="el" href="physfs_8h.html#a8eb320e9af03dcdb4c05bbff3ea604d4" title="Add an archive or directory to the search path.">PHYSFS_mount()</a> instead of this.</dd>
<dd>
Archives-in-archives may be very slow! While a <a class="el" href="struct_p_h_y_s_f_s___file.html" title="A PhysicsFS file handle.">PHYSFS_File</a> can seek even when the data is compressed, it may do so by rewinding to the start and decompressing everything before the seek point. Normal archive usage may do a lot of seeking behind the scenes. As such, you might find normal archive usage extremely painful if mounted this way. Plan accordingly: if you, say, have a self-extracting .zip file, and want to mount something in it, compress the contents of the inner archive and make sure the outer .zip file doesn't compress the inner archive too.</dd></dl>
<p>This function operates just like <a class="el" href="physfs_8h.html#a8eb320e9af03dcdb4c05bbff3ea604d4" title="Add an archive or directory to the search path.">PHYSFS_mount()</a>, but takes a <a class="el" href="struct_p_h_y_s_f_s___file.html" title="A PhysicsFS file handle.">PHYSFS_File</a> handle instead of a pathname. This handle contains all the data of the archive, and is used instead of a real file in the physical filesystem. The <a class="el" href="struct_p_h_y_s_f_s___file.html" title="A PhysicsFS file handle.">PHYSFS_File</a> may be backed by a real file in the physical filesystem, but isn't necessarily. The most popular use for this is likely to mount archives stored inside other archives.</p>
<p>(newDir) must be a unique string to identify this archive. It is used to optimize archiver selection (if you name it XXXXX.zip, we might try the ZIP archiver first, for example, or directly choose an archiver that can only trust the data is valid by filename extension). It doesn't need to refer to a real file at all. If the filename extension isn't helpful, the system will try every archiver until one works or none of them do. This filename must be unique, as the system won't allow you to have two archives with the same name.</p>
<p>(file) must remain until the archive is unmounted. When the archive is unmounted, the system will call PHYSFS_close(file). If you need this handle to survive, you will have to wrap this in a <a class="el" href="struct_p_h_y_s_f_s___io.html" title="An abstract i/o interface.">PHYSFS_Io</a> and use <a class="el" href="physfs_8h.html#a7ac107cf895f50f0d2219cdf44b8b758" title="Add an archive, built on a PHYSFS_Io, to the search path.">PHYSFS_mountIo()</a> instead.</p>
<p>If this function fails, PHYSFS_close(file) is not called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The <a class="el" href="struct_p_h_y_s_f_s___file.html" title="A PhysicsFS file handle.">PHYSFS_File</a> handle containing archive data. </td></tr>
    <tr><td class="paramname">newDir</td><td>Filename that can represent this stream. </td></tr>
    <tr><td class="paramname">mountPoint</td><td>Location in the interpolated tree that this archive will be "mounted", in platform-independent notation. NULL or "" is equivalent to "/". </td></tr>
    <tr><td class="paramname">appendToPath</td><td>nonzero to append to search path, zero to prepend. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nonzero if added to path, zero on failure (bogus archive, etc). Use <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a> to obtain the specific error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#aab0e2ba90aa918b2ee1ed7c40293b442" title="Remove a directory or archive from the search path.">PHYSFS_unmount</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#ac738531e9c7e5ca3797b64985c103cf4" title="Get the current search path.">PHYSFS_getSearchPath</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a365aee0c326b0e6bfbba5c039f7c4b5b" title="Determine a mounted archive&#39;s mountpoint.">PHYSFS_getMountPoint</a> </dd></dl>

</div>
</div>
<a id="a7ac107cf895f50f0d2219cdf44b8b758" name="a7ac107cf895f50f0d2219cdf44b8b758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac107cf895f50f0d2219cdf44b8b758">&#9670;&#160;</a></span>PHYSFS_mountIo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_mountIo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>newDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>mountPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>appendToPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an archive, built on a <a class="el" href="struct_p_h_y_s_f_s___io.html" title="An abstract i/o interface.">PHYSFS_Io</a>, to the search path. </p>
<dl class="section warning"><dt>Warning</dt><dd>Unless you have some special, low-level need, you should be using <a class="el" href="physfs_8h.html#a8eb320e9af03dcdb4c05bbff3ea604d4" title="Add an archive or directory to the search path.">PHYSFS_mount()</a> instead of this.</dd></dl>
<p>This function operates just like <a class="el" href="physfs_8h.html#a8eb320e9af03dcdb4c05bbff3ea604d4" title="Add an archive or directory to the search path.">PHYSFS_mount()</a>, but takes a <a class="el" href="struct_p_h_y_s_f_s___io.html" title="An abstract i/o interface.">PHYSFS_Io</a> instead of a pathname. Behind the scenes, <a class="el" href="physfs_8h.html#a8eb320e9af03dcdb4c05bbff3ea604d4" title="Add an archive or directory to the search path.">PHYSFS_mount()</a> calls this function with a physical-filesystem-based <a class="el" href="struct_p_h_y_s_f_s___io.html" title="An abstract i/o interface.">PHYSFS_Io</a>.</p>
<p>(newDir) must be a unique string to identify this archive. It is used to optimize archiver selection (if you name it XXXXX.zip, we might try the ZIP archiver first, for example, or directly choose an archiver that can only trust the data is valid by filename extension). It doesn't need to refer to a real file at all. If the filename extension isn't helpful, the system will try every archiver until one works or none of them do. This filename must be unique, as the system won't allow you to have two archives with the same name.</p>
<p>(io) must remain until the archive is unmounted. When the archive is unmounted, the system will call (io)-&gt;destroy(io), which will give you a chance to free your resources.</p>
<p>If this function fails, (io)-&gt;destroy(io) is not called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>i/o instance for archive to add to the path. </td></tr>
    <tr><td class="paramname">newDir</td><td>Filename that can represent this stream. </td></tr>
    <tr><td class="paramname">mountPoint</td><td>Location in the interpolated tree that this archive will be "mounted", in platform-independent notation. NULL or "" is equivalent to "/". </td></tr>
    <tr><td class="paramname">appendToPath</td><td>nonzero to append to search path, zero to prepend. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nonzero if added to path, zero on failure (bogus archive, stream i/o issue, etc). Use <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a> to obtain the specific error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#aab0e2ba90aa918b2ee1ed7c40293b442" title="Remove a directory or archive from the search path.">PHYSFS_unmount</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#ac738531e9c7e5ca3797b64985c103cf4" title="Get the current search path.">PHYSFS_getSearchPath</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a365aee0c326b0e6bfbba5c039f7c4b5b" title="Determine a mounted archive&#39;s mountpoint.">PHYSFS_getMountPoint</a> </dd></dl>

</div>
</div>
<a id="a0a977d04da585859e132ba4700df5d3a" name="a0a977d04da585859e132ba4700df5d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a977d04da585859e132ba4700df5d3a">&#9670;&#160;</a></span>PHYSFS_mountMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_mountMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a>&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>(*)(<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *)&#160;</td>
          <td class="paramname"><em>del</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>newDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>mountPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>appendToPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an archive, contained in a memory buffer, to the search path. </p>
<dl class="section warning"><dt>Warning</dt><dd>Unless you have some special, low-level need, you should be using <a class="el" href="physfs_8h.html#a8eb320e9af03dcdb4c05bbff3ea604d4" title="Add an archive or directory to the search path.">PHYSFS_mount()</a> instead of this.</dd></dl>
<p>This function operates just like <a class="el" href="physfs_8h.html#a8eb320e9af03dcdb4c05bbff3ea604d4" title="Add an archive or directory to the search path.">PHYSFS_mount()</a>, but takes a memory buffer instead of a pathname. This buffer contains all the data of the archive, and is used instead of a real file in the physical filesystem.</p>
<p>(newDir) must be a unique string to identify this archive. It is used to optimize archiver selection (if you name it XXXXX.zip, we might try the ZIP archiver first, for example, or directly choose an archiver that can only trust the data is valid by filename extension). It doesn't need to refer to a real file at all. If the filename extension isn't helpful, the system will try every archiver until one works or none of them do. This filename must be unique, as the system won't allow you to have two archives with the same name.</p>
<p>(ptr) must remain until the archive is unmounted. When the archive is unmounted, the system will call (del)(ptr), which will notify you that the system is done with the buffer, and give you a chance to free your resources. (del) can be NULL, in which case the system will make no attempt to free the buffer.</p>
<p>If this function fails, (del) is not called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Address of the memory buffer containing the archive data. </td></tr>
    <tr><td class="paramname">len</td><td>Size of memory buffer, in bytes. </td></tr>
    <tr><td class="paramname">del</td><td>A callback that triggers upon unmount. Can be NULL. </td></tr>
    <tr><td class="paramname">newDir</td><td>Filename that can represent this stream. </td></tr>
    <tr><td class="paramname">mountPoint</td><td>Location in the interpolated tree that this archive will be "mounted", in platform-independent notation. NULL or "" is equivalent to "/". </td></tr>
    <tr><td class="paramname">appendToPath</td><td>nonzero to append to search path, zero to prepend. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nonzero if added to path, zero on failure (bogus archive, etc). Use <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a> to obtain the specific error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#aab0e2ba90aa918b2ee1ed7c40293b442" title="Remove a directory or archive from the search path.">PHYSFS_unmount</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#ac738531e9c7e5ca3797b64985c103cf4" title="Get the current search path.">PHYSFS_getSearchPath</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a365aee0c326b0e6bfbba5c039f7c4b5b" title="Determine a mounted archive&#39;s mountpoint.">PHYSFS_getMountPoint</a> </dd></dl>

</div>
</div>
<a id="abeeca12e2fe7c5f68cbd67e2e5cafa3d" name="abeeca12e2fe7c5f68cbd67e2e5cafa3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeeca12e2fe7c5f68cbd67e2e5cafa3d">&#9670;&#160;</a></span>PHYSFS_openAppend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> * PHYSFS_openAppend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a file for appending. </p>
<p>Open a file for writing, in platform-independent notation and in relation to the write dir as the root of the writable filesystem. The specified file is created if it doesn't exist. If it does exist, the writing offset is set to the end of the file, so the first write will be the byte after the end.</p>
<p>Note that entries that are symlinks are ignored if PHYSFS_permitSymbolicLinks(1) hasn't been called, and opening a symlink with this function will fail in such a case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>File to open. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A valid PhysicsFS filehandle on success, NULL on error. Use <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a> to obtain the specific error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a5e38a425bb0b44c09ec25b105f770c63" title="Open a file for reading.">PHYSFS_openRead</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#abbf92d66c6cb82d0ede969aa2c964fba" title="Open a file for writing.">PHYSFS_openWrite</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#aae7bb76d39dadff2b72f9e4753139a62" title="Write data to a PhysicsFS filehandle.">PHYSFS_write</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a6822f8ff10073e855a1c3a6485b882f2" title="Close a PhysicsFS filehandle.">PHYSFS_close</a> </dd></dl>

</div>
</div>
<a id="a5e38a425bb0b44c09ec25b105f770c63" name="a5e38a425bb0b44c09ec25b105f770c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e38a425bb0b44c09ec25b105f770c63">&#9670;&#160;</a></span>PHYSFS_openRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> * PHYSFS_openRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a file for reading. </p>
<p>Open a file for reading, in platform-independent notation. The search path is checked one at a time until a matching file is found, in which case an abstract filehandle is associated with it, and reading may be done. The reading offset is set to the first byte of the file.</p>
<p>Note that entries that are symlinks are ignored if PHYSFS_permitSymbolicLinks(1) hasn't been called, and opening a symlink with this function will fail in such a case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>File to open. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A valid PhysicsFS filehandle on success, NULL on error. Use <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a> to obtain the specific error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#abbf92d66c6cb82d0ede969aa2c964fba" title="Open a file for writing.">PHYSFS_openWrite</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#abeeca12e2fe7c5f68cbd67e2e5cafa3d" title="Open a file for appending.">PHYSFS_openAppend</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#abde67ddefb36e3b780cfd796d47c253d" title="Read data from a PhysicsFS filehandle.">PHYSFS_read</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a6822f8ff10073e855a1c3a6485b882f2" title="Close a PhysicsFS filehandle.">PHYSFS_close</a> </dd></dl>

</div>
</div>
<a id="abbf92d66c6cb82d0ede969aa2c964fba" name="abbf92d66c6cb82d0ede969aa2c964fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf92d66c6cb82d0ede969aa2c964fba">&#9670;&#160;</a></span>PHYSFS_openWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> * PHYSFS_openWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a file for writing. </p>
<p>Open a file for writing, in platform-independent notation and in relation to the write dir as the root of the writable filesystem. The specified file is created if it doesn't exist. If it does exist, it is truncated to zero bytes, and the writing offset is set to the start.</p>
<p>Note that entries that are symlinks are ignored if PHYSFS_permitSymbolicLinks(1) hasn't been called, and opening a symlink with this function will fail in such a case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>File to open. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A valid PhysicsFS filehandle on success, NULL on error. Use <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a> to obtain the specific error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a5e38a425bb0b44c09ec25b105f770c63" title="Open a file for reading.">PHYSFS_openRead</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#abeeca12e2fe7c5f68cbd67e2e5cafa3d" title="Open a file for appending.">PHYSFS_openAppend</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#aae7bb76d39dadff2b72f9e4753139a62" title="Write data to a PhysicsFS filehandle.">PHYSFS_write</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a6822f8ff10073e855a1c3a6485b882f2" title="Close a PhysicsFS filehandle.">PHYSFS_close</a> </dd></dl>

</div>
</div>
<a id="aad451d9b3f46f627a1be8caee2eef9b7" name="aad451d9b3f46f627a1be8caee2eef9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad451d9b3f46f627a1be8caee2eef9b7">&#9670;&#160;</a></span>PHYSFS_permitSymbolicLinks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> PHYSFS_permitSymbolicLinks </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>allow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable following of symbolic links. </p>
<p>Some physical filesystems and archives contain files that are just pointers to other files. On the physical filesystem, opening such a link will (transparently) open the file that is pointed to.</p>
<p>By default, PhysicsFS will check if a file is really a symlink during open calls and fail if it is. Otherwise, the link could take you outside the write and search paths, and compromise security.</p>
<p>If you want to take that risk, call this function with a non-zero parameter. Note that this is more for sandboxing a program's scripting language, in case untrusted scripts try to compromise the system. Generally speaking, a user could very well have a legitimate reason to set up a symlink, so unless you feel there's a specific danger in allowing them, you should permit them.</p>
<p>Symlinks are only explicitly checked when dealing with filenames in platform-independent notation. That is, when setting up your search and write paths, etc, symlinks are never checked for.</p>
<p>Please note that <a class="el" href="physfs_8h.html#a7f5e23675c50ffe51ad00cceb5a65348" title="Get various information about a directory or a file.">PHYSFS_stat()</a> will always check the path specified; if that path is a symlink, it will not be followed in any case. If symlinks aren't permitted through this function, <a class="el" href="physfs_8h.html#a7f5e23675c50ffe51ad00cceb5a65348" title="Get various information about a directory or a file.">PHYSFS_stat()</a> ignores them, and would treat the query as if the path didn't exist at all.</p>
<p>Symbolic link permission can be enabled or disabled at any time after you've called <a class="el" href="physfs_8h.html#a61b94cac8e65267afb8a5f2344e60dd1" title="Initialize the PhysicsFS library.">PHYSFS_init()</a>, and is disabled by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allow</td><td>nonzero to permit symlinks, zero to deny linking.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a5223ccbe06246dd5379d6a57d6cd0d87" title="Determine if the symbolic links are permitted.">PHYSFS_symbolicLinksPermitted</a> </dd></dl>

</div>
</div>
<a id="abde67ddefb36e3b780cfd796d47c253d" name="abde67ddefb36e3b780cfd796d47c253d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde67ddefb36e3b780cfd796d47c253d">&#9670;&#160;</a></span>PHYSFS_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a> PHYSFS_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a>&#160;</td>
          <td class="paramname"><em>objSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a>&#160;</td>
          <td class="paramname"><em>objCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from a PhysicsFS filehandle. </p>
<p>The file must be opened for reading.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>As of PhysicsFS 2.1, use <a class="el" href="physfs_8h.html#a63ac40ecdb3f9b91e6ee309bdbad0ce8" title="Read bytes from a PhysicsFS filehandle.">PHYSFS_readBytes()</a> instead. This function just wraps it anyhow. This function never clarified what would happen if you managed to read a partial object, so working at the byte level makes this cleaner for everyone, especially now that <a class="el" href="struct_p_h_y_s_f_s___io.html" title="An abstract i/o interface.">PHYSFS_Io</a> interfaces can be supplied by the application.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>handle returned from <a class="el" href="physfs_8h.html#a5e38a425bb0b44c09ec25b105f770c63" title="Open a file for reading.">PHYSFS_openRead()</a>. </td></tr>
    <tr><td class="paramname">buffer</td><td>buffer to store read data into. </td></tr>
    <tr><td class="paramname">objSize</td><td>size in bytes of objects being read from (handle). </td></tr>
    <tr><td class="paramname">objCount</td><td>number of (objSize) objects to read from (handle). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of objects read. <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a> can shed light on the reason this might be &lt; (objCount), as can <a class="el" href="physfs_8h.html#a6d7ac838797951323072060392645dbe" title="Check for end-of-file state on a PhysicsFS filehandle.">PHYSFS_eof()</a>. -1 if complete failure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a63ac40ecdb3f9b91e6ee309bdbad0ce8" title="Read bytes from a PhysicsFS filehandle.">PHYSFS_readBytes</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a6d7ac838797951323072060392645dbe" title="Check for end-of-file state on a PhysicsFS filehandle.">PHYSFS_eof</a> </dd></dl>

</div>
</div>
<a id="a63ac40ecdb3f9b91e6ee309bdbad0ce8" name="a63ac40ecdb3f9b91e6ee309bdbad0ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ac40ecdb3f9b91e6ee309bdbad0ce8">&#9670;&#160;</a></span>PHYSFS_readBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a> PHYSFS_readBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read bytes from a PhysicsFS filehandle. </p>
<p>The file must be opened for reading.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>handle returned from <a class="el" href="physfs_8h.html#a5e38a425bb0b44c09ec25b105f770c63" title="Open a file for reading.">PHYSFS_openRead()</a>. </td></tr>
    <tr><td class="paramname">buffer</td><td>buffer of at least (len) bytes to store read data into. </td></tr>
    <tr><td class="paramname">len</td><td>number of bytes being read from (handle). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read. This may be less than (len); this does not signify an error, necessarily (a short read may mean EOF). <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a> can shed light on the reason this might be &lt; (len), as can <a class="el" href="physfs_8h.html#a6d7ac838797951323072060392645dbe" title="Check for end-of-file state on a PhysicsFS filehandle.">PHYSFS_eof()</a>. -1 if complete failure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a6d7ac838797951323072060392645dbe" title="Check for end-of-file state on a PhysicsFS filehandle.">PHYSFS_eof</a> </dd></dl>

</div>
</div>
<a id="ad524c869540cc428264c318330a89144" name="ad524c869540cc428264c318330a89144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad524c869540cc428264c318330a89144">&#9670;&#160;</a></span>PHYSFS_readSBE16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_readSBE16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#aeed97311e1294c0b42648f99d331e5a0">PHYSFS_sint16</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and convert a signed 16-bit bigendian value. </p>
<p>Convenience function. Read a signed 16-bit bigendian value from a file and convert it to the platform's native byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>PhysicsFS file handle from which to read. </td></tr>
    <tr><td class="paramname">val</td><td>pointer to where value should be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on failure, non-zero on success. If successful, (*val) will store the result. On failure, you can find out what went wrong from <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>. </dd></dl>

</div>
</div>
<a id="aab2bc016ea5dbe2a91479045576e644d" name="aab2bc016ea5dbe2a91479045576e644d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2bc016ea5dbe2a91479045576e644d">&#9670;&#160;</a></span>PHYSFS_readSBE32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_readSBE32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#ae0264996863470a315e29d5a740a0f36">PHYSFS_sint32</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and convert a signed 32-bit bigendian value. </p>
<p>Convenience function. Read a signed 32-bit bigendian value from a file and convert it to the platform's native byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>PhysicsFS file handle from which to read. </td></tr>
    <tr><td class="paramname">val</td><td>pointer to where value should be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on failure, non-zero on success. If successful, (*val) will store the result. On failure, you can find out what went wrong from <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>. </dd></dl>

</div>
</div>
<a id="a04eabd9e8da4265ede4018b24d4a39b1" name="a04eabd9e8da4265ede4018b24d4a39b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04eabd9e8da4265ede4018b24d4a39b1">&#9670;&#160;</a></span>PHYSFS_readSBE64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_readSBE64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and convert a signed 64-bit bigendian value. </p>
<p>Convenience function. Read a signed 64-bit bigendian value from a file and convert it to the platform's native byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>PhysicsFS file handle from which to read. </td></tr>
    <tr><td class="paramname">val</td><td>pointer to where value should be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on failure, non-zero on success. If successful, (*val) will store the result. On failure, you can find out what went wrong from <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Remember, PHYSFS_sint64 is only 32 bits on platforms without any sort of 64-bit support. </dd></dl>

</div>
</div>
<a id="a0959e10405416c139aad78dbc21617a0" name="a0959e10405416c139aad78dbc21617a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0959e10405416c139aad78dbc21617a0">&#9670;&#160;</a></span>PHYSFS_readSLE16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_readSLE16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#aeed97311e1294c0b42648f99d331e5a0">PHYSFS_sint16</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and convert a signed 16-bit littleendian value. </p>
<p>Convenience function. Read a signed 16-bit littleendian value from a file and convert it to the platform's native byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>PhysicsFS file handle from which to read. </td></tr>
    <tr><td class="paramname">val</td><td>pointer to where value should be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on failure, non-zero on success. If successful, (*val) will store the result. On failure, you can find out what went wrong from <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>. </dd></dl>

</div>
</div>
<a id="a2e2bfb4e8204c99f75642c4833e18566" name="a2e2bfb4e8204c99f75642c4833e18566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2bfb4e8204c99f75642c4833e18566">&#9670;&#160;</a></span>PHYSFS_readSLE32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_readSLE32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#ae0264996863470a315e29d5a740a0f36">PHYSFS_sint32</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and convert a signed 32-bit littleendian value. </p>
<p>Convenience function. Read a signed 32-bit littleendian value from a file and convert it to the platform's native byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>PhysicsFS file handle from which to read. </td></tr>
    <tr><td class="paramname">val</td><td>pointer to where value should be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on failure, non-zero on success. If successful, (*val) will store the result. On failure, you can find out what went wrong from <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>. </dd></dl>

</div>
</div>
<a id="ae916644039fad7ae4cb7d81440150d35" name="ae916644039fad7ae4cb7d81440150d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae916644039fad7ae4cb7d81440150d35">&#9670;&#160;</a></span>PHYSFS_readSLE64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_readSLE64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and convert a signed 64-bit littleendian value. </p>
<p>Convenience function. Read a signed 64-bit littleendian value from a file and convert it to the platform's native byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>PhysicsFS file handle from which to read. </td></tr>
    <tr><td class="paramname">val</td><td>pointer to where value should be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on failure, non-zero on success. If successful, (*val) will store the result. On failure, you can find out what went wrong from <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Remember, PHYSFS_sint64 is only 32 bits on platforms without any sort of 64-bit support. </dd></dl>

</div>
</div>
<a id="a083c97d848b89e08f6529c31cd7dba67" name="a083c97d848b89e08f6529c31cd7dba67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a083c97d848b89e08f6529c31cd7dba67">&#9670;&#160;</a></span>PHYSFS_readUBE16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_readUBE16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and convert an unsigned 16-bit bigendian value. </p>
<p>Convenience function. Read an unsigned 16-bit bigendian value from a file and convert it to the platform's native byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>PhysicsFS file handle from which to read. </td></tr>
    <tr><td class="paramname">val</td><td>pointer to where value should be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on failure, non-zero on success. If successful, (*val) will store the result. On failure, you can find out what went wrong from <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>. </dd></dl>

</div>
</div>
<a id="a357b5757a9483ef893977761d7d3fc1e" name="a357b5757a9483ef893977761d7d3fc1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357b5757a9483ef893977761d7d3fc1e">&#9670;&#160;</a></span>PHYSFS_readUBE32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_readUBE32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and convert an unsigned 32-bit bigendian value. </p>
<p>Convenience function. Read an unsigned 32-bit bigendian value from a file and convert it to the platform's native byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>PhysicsFS file handle from which to read. </td></tr>
    <tr><td class="paramname">val</td><td>pointer to where value should be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on failure, non-zero on success. If successful, (*val) will store the result. On failure, you can find out what went wrong from <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>. </dd></dl>

</div>
</div>
<a id="a380430eda70acd8728930a2f1256c071" name="a380430eda70acd8728930a2f1256c071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380430eda70acd8728930a2f1256c071">&#9670;&#160;</a></span>PHYSFS_readUBE64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_readUBE64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and convert an unsigned 64-bit bigendian value. </p>
<p>Convenience function. Read an unsigned 64-bit bigendian value from a file and convert it to the platform's native byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>PhysicsFS file handle from which to read. </td></tr>
    <tr><td class="paramname">val</td><td>pointer to where value should be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on failure, non-zero on success. If successful, (*val) will store the result. On failure, you can find out what went wrong from <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Remember, PHYSFS_uint64 is only 32 bits on platforms without any sort of 64-bit support. </dd></dl>

</div>
</div>
<a id="af13248f4af186eda3983831dd8632da1" name="af13248f4af186eda3983831dd8632da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13248f4af186eda3983831dd8632da1">&#9670;&#160;</a></span>PHYSFS_readULE16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_readULE16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and convert an unsigned 16-bit littleendian value. </p>
<p>Convenience function. Read an unsigned 16-bit littleendian value from a file and convert it to the platform's native byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>PhysicsFS file handle from which to read. </td></tr>
    <tr><td class="paramname">val</td><td>pointer to where value should be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on failure, non-zero on success. If successful, (*val) will store the result. On failure, you can find out what went wrong from <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>. </dd></dl>

</div>
</div>
<a id="adef7cf2fb6311b0bc9d39634b4088545" name="adef7cf2fb6311b0bc9d39634b4088545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef7cf2fb6311b0bc9d39634b4088545">&#9670;&#160;</a></span>PHYSFS_readULE32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_readULE32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and convert an unsigned 32-bit littleendian value. </p>
<p>Convenience function. Read an unsigned 32-bit littleendian value from a file and convert it to the platform's native byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>PhysicsFS file handle from which to read. </td></tr>
    <tr><td class="paramname">val</td><td>pointer to where value should be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on failure, non-zero on success. If successful, (*val) will store the result. On failure, you can find out what went wrong from <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>. </dd></dl>

</div>
</div>
<a id="ae72ad9e14404add23d432838f4e9f35a" name="ae72ad9e14404add23d432838f4e9f35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72ad9e14404add23d432838f4e9f35a">&#9670;&#160;</a></span>PHYSFS_readULE64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_readULE64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and convert an unsigned 64-bit littleendian value. </p>
<p>Convenience function. Read an unsigned 64-bit littleendian value from a file and convert it to the platform's native byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>PhysicsFS file handle from which to read. </td></tr>
    <tr><td class="paramname">val</td><td>pointer to where value should be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on failure, non-zero on success. If successful, (*val) will store the result. On failure, you can find out what went wrong from <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Remember, PHYSFS_uint64 is only 32 bits on platforms without any sort of 64-bit support. </dd></dl>

</div>
</div>
<a id="ace0ecda857dc622e2d005af02972237d" name="ace0ecda857dc622e2d005af02972237d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0ecda857dc622e2d005af02972237d">&#9670;&#160;</a></span>PHYSFS_registerArchiver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_registerArchiver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="struct_p_h_y_s_f_s___archiver.html">PHYSFS_Archiver</a> *&#160;</td>
          <td class="paramname"><em>archiver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new archiver to the system. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is advanced, hardcore stuff. You don't need this unless you really know what you're doing. Most apps will not need this.</dd></dl>
<p>If you want to provide your own archiver (for example, a custom archive file format, or some virtual thing you want to make look like a filesystem that you can access through the usual PhysicsFS APIs), this is where you start. Once an archiver is successfully registered, then you can use <a class="el" href="physfs_8h.html#a8eb320e9af03dcdb4c05bbff3ea604d4" title="Add an archive or directory to the search path.">PHYSFS_mount()</a> to add archives that your archiver supports to the search path, or perhaps use it as the write dir. Internally, PhysicsFS uses this function to register its own built-in archivers, like .zip support, etc.</p>
<p>You may not have two archivers that handle the same extension. If you are going to have a clash, you can deregister the other archiver (including built-in ones) with <a class="el" href="physfs_8h.html#abbc7cce9112c5ddc2f3a9ad5d0edf6e0" title="Remove an archiver from the system.">PHYSFS_deregisterArchiver()</a>.</p>
<p>The data in (archiver) is copied; you may free this pointer when this function returns.</p>
<p>Once this function returns successfully, PhysicsFS will be able to support archives of this type until you deregister the archiver again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">archiver</td><td>The archiver to register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on error, non-zero on success.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_p_h_y_s_f_s___archiver.html" title="Abstract interface to provide support for user-defined archives.">PHYSFS_Archiver</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#abbc7cce9112c5ddc2f3a9ad5d0edf6e0" title="Remove an archiver from the system.">PHYSFS_deregisterArchiver</a> </dd></dl>

</div>
</div>
<a id="a555ee86816418ed3a99e10243c5db7b8" name="a555ee86816418ed3a99e10243c5db7b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a555ee86816418ed3a99e10243c5db7b8">&#9670;&#160;</a></span>PHYSFS_removeFromSearchPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_removeFromSearchPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>oldDir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a directory or archive from the search path. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>As of PhysicsFS 2.1, use <a class="el" href="physfs_8h.html#aab0e2ba90aa918b2ee1ed7c40293b442" title="Remove a directory or archive from the search path.">PHYSFS_unmount()</a> instead. This function just wraps it anyhow. There's no functional difference except the vocabulary changed from "adding to the search path" to "mounting" when that functionality was extended, and thus the preferred way to accomplish this function's work is now called "unmounting."</dd></dl>
<p>This function is equivalent to:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="physfs_8h.html#aab0e2ba90aa918b2ee1ed7c40293b442">PHYSFS_unmount</a>(oldDir);</div>
<div class="ttc" id="aphysfs_8h_html_aab0e2ba90aa918b2ee1ed7c40293b442"><div class="ttname"><a href="physfs_8h.html#aab0e2ba90aa918b2ee1ed7c40293b442">PHYSFS_unmount</a></div><div class="ttdeci">PHYSFS_DECL int PHYSFS_unmount(const char *oldDir)</div><div class="ttdoc">Remove a directory or archive from the search path.</div></div>
</div><!-- fragment --><p>You must use this and not PHYSFS_unmount if binary compatibility with PhysicsFS 1.0 is important (which it may not be for many people).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#ae9a677c869257742cbe5417dec9b3cee" title="Add an archive or directory to the search path.">PHYSFS_addToSearchPath</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#ac738531e9c7e5ca3797b64985c103cf4" title="Get the current search path.">PHYSFS_getSearchPath</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#aab0e2ba90aa918b2ee1ed7c40293b442" title="Remove a directory or archive from the search path.">PHYSFS_unmount</a> </dd></dl>

</div>
</div>
<a id="ae562b45b1e1b02505ce1d82ad785f04a" name="ae562b45b1e1b02505ce1d82ad785f04a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae562b45b1e1b02505ce1d82ad785f04a">&#9670;&#160;</a></span>PHYSFS_seek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_seek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seek to a new position within a PhysicsFS filehandle. </p>
<p>The next read or write will occur at that place. Seeking past the beginning or end of the file is not allowed, and causes an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>handle returned from PHYSFS_open*(). </td></tr>
    <tr><td class="paramname">pos</td><td>number of bytes from start of file to seek to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nonzero on success, zero on error. Use <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a> to obtain the specific error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a0d481bdd4cf32ed1a41540ee59840c24" title="Determine current position within a PhysicsFS filehandle.">PHYSFS_tell</a> </dd></dl>

</div>
</div>
<a id="ae6297d1ae7755b9236b01950bfbb0ef1" name="ae6297d1ae7755b9236b01950bfbb0ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6297d1ae7755b9236b01950bfbb0ef1">&#9670;&#160;</a></span>PHYSFS_setAllocator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_setAllocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="struct_p_h_y_s_f_s___allocator.html">PHYSFS_Allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hook your own allocation routines into PhysicsFS. </p>
<p>(This is for limited, hardcore use. If you don't immediately see a need for it, you can probably ignore this forever.)</p>
<p>By default, PhysicsFS will use whatever is reasonable for a platform to manage dynamic memory (usually ANSI C malloc/realloc/free, but some platforms might use something else), but in some uncommon cases, the app might want more control over the library's memory management. This lets you redirect PhysicsFS to use your own allocation routines instead. You can only call this function before <a class="el" href="physfs_8h.html#a61b94cac8e65267afb8a5f2344e60dd1" title="Initialize the PhysicsFS library.">PHYSFS_init()</a>; if the library is initialized, it'll reject your efforts to change the allocator mid-stream. You may call this function after <a class="el" href="physfs_8h.html#aa465c9b58e5020f503085d433a413b5b" title="Deinitialize the PhysicsFS library.">PHYSFS_deinit()</a> if you are willing to shut down the library and restart it with a new allocator; this is a safe and supported operation. The allocator remains intact between deinit/init calls. If you want to return to the platform's default allocator, pass a NULL in here.</p>
<p>If you aren't immediately sure what to do with this function, you can safely ignore it altogether.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>Structure containing your allocator's entry points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on failure, non-zero on success. This call only fails when used between <a class="el" href="physfs_8h.html#a61b94cac8e65267afb8a5f2344e60dd1" title="Initialize the PhysicsFS library.">PHYSFS_init()</a> and <a class="el" href="physfs_8h.html#aa465c9b58e5020f503085d433a413b5b" title="Deinitialize the PhysicsFS library.">PHYSFS_deinit()</a> calls. </dd></dl>

</div>
</div>
<a id="aede5de47197e1a613d2091802befc886" name="aede5de47197e1a613d2091802befc886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede5de47197e1a613d2091802befc886">&#9670;&#160;</a></span>PHYSFS_setBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_setBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a>&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up buffering for a PhysicsFS file handle. </p>
<p>Define an i/o buffer for a file handle. A memory block of (bufsize) bytes will be allocated and associated with (handle).</p>
<p>For files opened for reading, up to (bufsize) bytes are read from (handle) and stored in the internal buffer. Calls to <a class="el" href="physfs_8h.html#abde67ddefb36e3b780cfd796d47c253d" title="Read data from a PhysicsFS filehandle.">PHYSFS_read()</a> will pull from this buffer until it is empty, and then refill it for more reading. Note that compressed files, like ZIP archives, will decompress while buffering, so this can be handy for offsetting CPU-intensive operations. The buffer isn't filled until you do your next read.</p>
<p>For files opened for writing, data will be buffered to memory until the buffer is full or the buffer is flushed. Closing a handle implicitly causes a flush...check your return values!</p>
<p>Seeking, etc transparently accounts for buffering.</p>
<p>You can resize an existing buffer by calling this function more than once on the same file. Setting the buffer size to zero will free an existing buffer.</p>
<p>PhysicsFS file handles are unbuffered by default.</p>
<p>Please check the return value of this function! Failures can include not being able to seek backwards in a read-only file when removing the buffer, not being able to allocate the buffer, and not being able to flush the buffer to disk, among other unexpected problems.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>handle returned from PHYSFS_open*(). </td></tr>
    <tr><td class="paramname">bufsize</td><td>size, in bytes, of buffer to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nonzero if successful, zero on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a3fd8f9cfdfd09f4fb778a386d8e97e8a" title="Flush a buffered PhysicsFS file handle.">PHYSFS_flush</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#abde67ddefb36e3b780cfd796d47c253d" title="Read data from a PhysicsFS filehandle.">PHYSFS_read</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#aae7bb76d39dadff2b72f9e4753139a62" title="Write data to a PhysicsFS filehandle.">PHYSFS_write</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a6822f8ff10073e855a1c3a6485b882f2" title="Close a PhysicsFS filehandle.">PHYSFS_close</a> </dd></dl>

</div>
</div>
<a id="ade2c854542c68abc2015649fadd3a623" name="ade2c854542c68abc2015649fadd3a623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2c854542c68abc2015649fadd3a623">&#9670;&#160;</a></span>PHYSFS_setErrorCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> PHYSFS_setErrorCode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a50dba13af51214897c867a123f74afed">PHYSFS_ErrorCode</a>&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current thread's error code. </p>
<p>This lets you set the value that will be returned by the next call to <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>. This will replace any existing error code, whether set by your application or internally by PhysicsFS.</p>
<p>Error codes are stored per-thread; what you set here will not be accessible to another thread.</p>
<p>Any call into PhysicsFS may change the current error code, so any code you set here is somewhat fragile, and thus you shouldn't build any serious error reporting framework on this function. The primary goal of this function is to allow <a class="el" href="struct_p_h_y_s_f_s___io.html" title="An abstract i/o interface.">PHYSFS_Io</a> implementations to set the error state, which generally will be passed back to your application when PhysicsFS makes a <a class="el" href="struct_p_h_y_s_f_s___io.html" title="An abstract i/o interface.">PHYSFS_Io</a> call that fails internally.</p>
<p>This function doesn't care if the error code is a value known to PhysicsFS or not (but <a class="el" href="physfs_8h.html#a545f6b5ba97faa19441932dffb65c3be" title="Get human-readable description string for a given error code.">PHYSFS_getErrorByCode()</a> will return NULL for unknown values). The value will be reported unmolested by <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>Error code to become the current thread's new error state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a545f6b5ba97faa19441932dffb65c3be" title="Get human-readable description string for a given error code.">PHYSFS_getErrorByCode</a> </dd></dl>

</div>
</div>
<a id="afef8700f714b6800ff688372c540bfe2" name="afef8700f714b6800ff688372c540bfe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef8700f714b6800ff688372c540bfe2">&#9670;&#160;</a></span>PHYSFS_setSaneConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_setSaneConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>organization</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>appName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>archiveExt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>includeCdRoms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>archivesFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up sane, default paths. </p>
<p>Helper function.</p>
<p>The write dir will be set to the pref dir returned by </p><div class="fragment"><div class="line"><a class="code hl_function" href="physfs_8h.html#acd87392d234d070695303521bb8052a5">PHYSFS_getPrefDir</a>(organization, appName) </div>
<div class="ttc" id="aphysfs_8h_html_acd87392d234d070695303521bb8052a5"><div class="ttname"><a href="physfs_8h.html#acd87392d234d070695303521bb8052a5">PHYSFS_getPrefDir</a></div><div class="ttdeci">PHYSFS_DECL const char * PHYSFS_getPrefDir(const char *org, const char *app)</div><div class="ttdoc">Get the user-and-app-specific path where files can be written.</div></div>
</div><!-- fragment --><p>, which is created if it doesn't exist.</p>
<p>The above is sufficient to make sure your program's configuration directory is separated from other clutter, and platform-independent.</p>
<p>The search path will be:</p>
<ul>
<li>The Write Dir (created if it doesn't exist)</li>
<li>The Base Dir (<a class="el" href="physfs_8h.html#a0034c327dfb381a1c95deb80878bcede" title="Get the path where the application resides.">PHYSFS_getBaseDir()</a>)</li>
<li>All found CD-ROM dirs (optionally)</li>
</ul>
<p>These directories are then searched for files ending with the extension (archiveExt), which, if they are valid and supported archives, will also be added to the search path. If you specified "PKG" for (archiveExt), and there's a file named data.PKG in the base dir, it'll be checked. Archives can either be appended or prepended to the search path in alphabetical order, regardless of which directories they were found in. All archives are mounted in the root of the virtual file system ("/").</p>
<p>All of this can be accomplished from the application, but this just does it all for you. Feel free to add more to the search path manually, too.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">organization</td><td>Name of your company/group/etc to be used as a dirname, so keep it small, and no-frills.</td></tr>
    <tr><td class="paramname">appName</td><td>Program-specific name of your program, to separate it from other programs using PhysicsFS.</td></tr>
    <tr><td class="paramname">archiveExt</td><td>File extension used by your program to specify an archive. For example, Quake 3 uses "pk3", even though they are just zipfiles. Specify NULL to not dig out archives automatically. Do not specify the '.' char; If you want to look for ZIP files, specify "ZIP" and not ".ZIP" ... the archive search is case-insensitive.</td></tr>
    <tr><td class="paramname">includeCdRoms</td><td>Non-zero to include CD-ROMs in the search path, and (if (archiveExt) != NULL) search them for archives. This may cause a significant amount of blocking while discs are accessed, and if there are no discs in the drive (or even not mounted on Unix systems), then they may not be made available anyhow. You may want to specify zero and handle the disc setup yourself.</td></tr>
    <tr><td class="paramname">archivesFirst</td><td>Non-zero to prepend the archives to the search path. Zero to append them. Ignored if !(archiveExt).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nonzero on success, zero on error. Use <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a> to obtain the specific error. </dd></dl>

</div>
</div>
<a id="a36c408d40b3a93c8f9fc02a16c02e430" name="a36c408d40b3a93c8f9fc02a16c02e430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c408d40b3a93c8f9fc02a16c02e430">&#9670;&#160;</a></span>PHYSFS_setWriteDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_setWriteDir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>newDir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell PhysicsFS where it may write files. </p>
<p>Set a new write dir. This will override the previous setting.</p>
<p>This call will fail (and fail to change the write dir) if the current write dir still has files open in it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newDir</td><td>The new directory to be the root of the write dir, specified in platform-dependent notation. Setting to NULL disables the write dir, so no files can be opened for writing via PhysicsFS. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero on success, zero on failure. All attempts to open a file for writing via PhysicsFS will fail until this call succeeds. Use <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a> to obtain the specific error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a6533ff91180a4c8abfe24d458f6b9915" title="Get path where PhysicsFS will allow file writing.">PHYSFS_getWriteDir</a> </dd></dl>

</div>
</div>
<a id="a7f5e23675c50ffe51ad00cceb5a65348" name="a7f5e23675c50ffe51ad00cceb5a65348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5e23675c50ffe51ad00cceb5a65348">&#9670;&#160;</a></span>PHYSFS_stat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_stat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___stat.html">PHYSFS_Stat</a> *&#160;</td>
          <td class="paramname"><em>stat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get various information about a directory or a file. </p>
<p>Obtain various information about a file or directory from the meta data.</p>
<p>This function will never follow symbolic links. If you haven't enabled symlinks with <a class="el" href="physfs_8h.html#aad451d9b3f46f627a1be8caee2eef9b7" title="Enable or disable following of symbolic links.">PHYSFS_permitSymbolicLinks()</a>, stat'ing a symlink will be treated like stat'ing a non-existant file. If symlinks are enabled, stat'ing a symlink will give you information on the link itself and not what it points to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>filename to check, in platform-indepedent notation. </td></tr>
    <tr><td class="paramname">stat</td><td>pointer to structure to fill in with data about (fname). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero on success, zero on failure. On failure, (stat)'s contents are undefined.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_p_h_y_s_f_s___stat.html" title="Meta data for a file or directory.">PHYSFS_Stat</a> </dd></dl>

</div>
</div>
<a id="a4ca65fbaa485d68113912bbbd70bd19e" name="a4ca65fbaa485d68113912bbbd70bd19e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca65fbaa485d68113912bbbd70bd19e">&#9670;&#160;</a></span>PHYSFS_supportedArchiveTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="struct_p_h_y_s_f_s___archive_info.html">PHYSFS_ArchiveInfo</a> ** PHYSFS_supportedArchiveTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of supported archive types. </p>
<p>Get a list of archive types supported by this implementation of PhysicFS. These are the file formats usable for search path entries. This is for informational purposes only. Note that the extension listed is merely convention: if we list "ZIP", you can open a PkZip-compatible archive with an extension of "XYZ", if you like.</p>
<p>The returned value is an array of pointers to <a class="el" href="struct_p_h_y_s_f_s___archive_info.html" title="Information on various PhysicsFS-supported archives.">PHYSFS_ArchiveInfo</a> structures, with a NULL entry to signify the end of the list:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="struct_p_h_y_s_f_s___archive_info.html">PHYSFS_ArchiveInfo</a> **i;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (i = <a class="code hl_function" href="physfs_8h.html#a4ca65fbaa485d68113912bbbd70bd19e">PHYSFS_supportedArchiveTypes</a>(); *i != NULL; i++)</div>
<div class="line">{</div>
<div class="line">    printf(<span class="stringliteral">&quot;Supported archive: [%s], which is [%s].\n&quot;</span>,</div>
<div class="line">             (*i)-&gt;extension, (*i)-&gt;description);</div>
<div class="line">}</div>
<div class="ttc" id="aphysfs_8h_html_a4ca65fbaa485d68113912bbbd70bd19e"><div class="ttname"><a href="physfs_8h.html#a4ca65fbaa485d68113912bbbd70bd19e">PHYSFS_supportedArchiveTypes</a></div><div class="ttdeci">PHYSFS_DECL const PHYSFS_ArchiveInfo ** PHYSFS_supportedArchiveTypes(void)</div><div class="ttdoc">Get a list of supported archive types.</div></div>
<div class="ttc" id="astruct_p_h_y_s_f_s___archive_info_html"><div class="ttname"><a href="struct_p_h_y_s_f_s___archive_info.html">PHYSFS_ArchiveInfo</a></div><div class="ttdoc">Information on various PhysicsFS-supported archives.</div><div class="ttdef"><b>Definition</b> physfs.h:404</div></div>
</div><!-- fragment --><p>The return values are pointers to internal memory, and should be considered READ ONLY, and never freed. The returned values are valid until the next call to <a class="el" href="physfs_8h.html#aa465c9b58e5020f503085d433a413b5b" title="Deinitialize the PhysicsFS library.">PHYSFS_deinit()</a>, <a class="el" href="physfs_8h.html#ace0ecda857dc622e2d005af02972237d" title="Add a new archiver to the system.">PHYSFS_registerArchiver()</a>, or <a class="el" href="physfs_8h.html#abbc7cce9112c5ddc2f3a9ad5d0edf6e0" title="Remove an archiver from the system.">PHYSFS_deregisterArchiver()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>READ ONLY Null-terminated array of READ ONLY structures.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#ace0ecda857dc622e2d005af02972237d" title="Add a new archiver to the system.">PHYSFS_registerArchiver</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#abbc7cce9112c5ddc2f3a9ad5d0edf6e0" title="Remove an archiver from the system.">PHYSFS_deregisterArchiver</a> </dd></dl>

</div>
</div>
<a id="a5fc8e4b9696316e25e3f6422910726c6" name="a5fc8e4b9696316e25e3f6422910726c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc8e4b9696316e25e3f6422910726c6">&#9670;&#160;</a></span>PHYSFS_swapSBE16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#aeed97311e1294c0b42648f99d331e5a0">PHYSFS_sint16</a> PHYSFS_swapSBE16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#aeed97311e1294c0b42648f99d331e5a0">PHYSFS_sint16</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap bigendian signed 16 to platform's native byte order. </p>
<p>Take a 16-bit signed value in bigendian format and convert it to the platform's native byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>converted value. </dd></dl>

</div>
</div>
<a id="a8908fb655aa60f0feb2f1662c93c8a0e" name="a8908fb655aa60f0feb2f1662c93c8a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8908fb655aa60f0feb2f1662c93c8a0e">&#9670;&#160;</a></span>PHYSFS_swapSBE32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#ae0264996863470a315e29d5a740a0f36">PHYSFS_sint32</a> PHYSFS_swapSBE32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#ae0264996863470a315e29d5a740a0f36">PHYSFS_sint32</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap bigendian signed 32 to platform's native byte order. </p>
<p>Take a 32-bit signed value in bigendian format and convert it to the platform's native byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>converted value. </dd></dl>

</div>
</div>
<a id="a974af7dedc1125735efd9b14e23f20e6" name="a974af7dedc1125735efd9b14e23f20e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a974af7dedc1125735efd9b14e23f20e6">&#9670;&#160;</a></span>PHYSFS_swapSBE64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a> PHYSFS_swapSBE64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap bigendian signed 64 to platform's native byte order. </p>
<p>Take a 64-bit signed value in bigendian format and convert it to the platform's native byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>converted value.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Remember, PHYSFS_sint64 is only 32 bits on platforms without any sort of 64-bit support. </dd></dl>

</div>
</div>
<a id="a73f900bb3ed3a2df81cf7c12b83b0fd4" name="a73f900bb3ed3a2df81cf7c12b83b0fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f900bb3ed3a2df81cf7c12b83b0fd4">&#9670;&#160;</a></span>PHYSFS_swapSLE16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#aeed97311e1294c0b42648f99d331e5a0">PHYSFS_sint16</a> PHYSFS_swapSLE16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#aeed97311e1294c0b42648f99d331e5a0">PHYSFS_sint16</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap littleendian signed 16 to platform's native byte order. </p>
<p>Take a 16-bit signed value in littleendian format and convert it to the platform's native byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>converted value. </dd></dl>

</div>
</div>
<a id="a9b59892fb2846084a272c1bfc4aade4e" name="a9b59892fb2846084a272c1bfc4aade4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b59892fb2846084a272c1bfc4aade4e">&#9670;&#160;</a></span>PHYSFS_swapSLE32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#ae0264996863470a315e29d5a740a0f36">PHYSFS_sint32</a> PHYSFS_swapSLE32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#ae0264996863470a315e29d5a740a0f36">PHYSFS_sint32</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap littleendian signed 32 to platform's native byte order. </p>
<p>Take a 32-bit signed value in littleendian format and convert it to the platform's native byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>converted value. </dd></dl>

</div>
</div>
<a id="af032bd8e6116b2b3b6de279cb05b98a8" name="af032bd8e6116b2b3b6de279cb05b98a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af032bd8e6116b2b3b6de279cb05b98a8">&#9670;&#160;</a></span>PHYSFS_swapSLE64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a> PHYSFS_swapSLE64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap littleendian signed 64 to platform's native byte order. </p>
<p>Take a 64-bit signed value in littleendian format and convert it to the platform's native byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>converted value.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Remember, PHYSFS_sint64 is only 32 bits on platforms without any sort of 64-bit support. </dd></dl>

</div>
</div>
<a id="a056321eea71215938431ad4501c2cf9c" name="a056321eea71215938431ad4501c2cf9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056321eea71215938431ad4501c2cf9c">&#9670;&#160;</a></span>PHYSFS_swapUBE16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a> PHYSFS_swapUBE16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap bigendian unsigned 16 to platform's native byte order. </p>
<p>Take a 16-bit unsigned value in bigendian format and convert it to the platform's native byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>converted value. </dd></dl>

</div>
</div>
<a id="a464ba8bc7f121e7f31423ad5d2ec6ed2" name="a464ba8bc7f121e7f31423ad5d2ec6ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464ba8bc7f121e7f31423ad5d2ec6ed2">&#9670;&#160;</a></span>PHYSFS_swapUBE32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a> PHYSFS_swapUBE32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap bigendian unsigned 32 to platform's native byte order. </p>
<p>Take a 32-bit unsigned value in bigendian format and convert it to the platform's native byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>converted value. </dd></dl>

</div>
</div>
<a id="a6c9b62d93cd121039c00554cb627a425" name="a6c9b62d93cd121039c00554cb627a425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9b62d93cd121039c00554cb627a425">&#9670;&#160;</a></span>PHYSFS_swapUBE64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> PHYSFS_swapUBE64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap bigendian unsigned 64 to platform's native byte order. </p>
<p>Take a 64-bit unsigned value in bigendian format and convert it to the platform's native byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>converted value.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Remember, PHYSFS_uint64 is only 32 bits on platforms without any sort of 64-bit support. </dd></dl>

</div>
</div>
<a id="acb9b90e29f097f4feaa4568ec405db01" name="acb9b90e29f097f4feaa4568ec405db01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb9b90e29f097f4feaa4568ec405db01">&#9670;&#160;</a></span>PHYSFS_swapULE16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a> PHYSFS_swapULE16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap littleendian unsigned 16 to platform's native byte order. </p>
<p>Take a 16-bit unsigned value in littleendian format and convert it to the platform's native byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>converted value. </dd></dl>

</div>
</div>
<a id="a6e86a4c1461dc47784e3f68034ad97c9" name="a6e86a4c1461dc47784e3f68034ad97c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e86a4c1461dc47784e3f68034ad97c9">&#9670;&#160;</a></span>PHYSFS_swapULE32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a> PHYSFS_swapULE32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap littleendian unsigned 32 to platform's native byte order. </p>
<p>Take a 32-bit unsigned value in littleendian format and convert it to the platform's native byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>converted value. </dd></dl>

</div>
</div>
<a id="a4b7249bf3cae48f1e04d99505011f280" name="a4b7249bf3cae48f1e04d99505011f280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7249bf3cae48f1e04d99505011f280">&#9670;&#160;</a></span>PHYSFS_swapULE64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a> PHYSFS_swapULE64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap littleendian unsigned 64 to platform's native byte order. </p>
<p>Take a 64-bit unsigned value in littleendian format and convert it to the platform's native byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>converted value.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Remember, PHYSFS_uint64 is only 32 bits on platforms without any sort of 64-bit support. </dd></dl>

</div>
</div>
<a id="a5223ccbe06246dd5379d6a57d6cd0d87" name="a5223ccbe06246dd5379d6a57d6cd0d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5223ccbe06246dd5379d6a57d6cd0d87">&#9670;&#160;</a></span>PHYSFS_symbolicLinksPermitted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_symbolicLinksPermitted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the symbolic links are permitted. </p>
<p>This reports the setting from the last call to <a class="el" href="physfs_8h.html#aad451d9b3f46f627a1be8caee2eef9b7" title="Enable or disable following of symbolic links.">PHYSFS_permitSymbolicLinks()</a>. If <a class="el" href="physfs_8h.html#aad451d9b3f46f627a1be8caee2eef9b7" title="Enable or disable following of symbolic links.">PHYSFS_permitSymbolicLinks()</a> hasn't been called since the library was last initialized, symbolic links are implicitly disabled.</p>
<dl class="section return"><dt>Returns</dt><dd>non-zero if symlinks are permitted, zero if not.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#aad451d9b3f46f627a1be8caee2eef9b7" title="Enable or disable following of symbolic links.">PHYSFS_permitSymbolicLinks</a> </dd></dl>

</div>
</div>
<a id="a0d481bdd4cf32ed1a41540ee59840c24" name="a0d481bdd4cf32ed1a41540ee59840c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d481bdd4cf32ed1a41540ee59840c24">&#9670;&#160;</a></span>PHYSFS_tell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a> PHYSFS_tell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine current position within a PhysicsFS filehandle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>handle returned from PHYSFS_open*(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>offset in bytes from start of file. -1 if error occurred. Use <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a> to obtain the specific error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#ae562b45b1e1b02505ce1d82ad785f04a" title="Seek to a new position within a PhysicsFS filehandle.">PHYSFS_seek</a> </dd></dl>

</div>
</div>
<a id="ad3753f0ac8e6a57ac438912ac68e97aa" name="ad3753f0ac8e6a57ac438912ac68e97aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3753f0ac8e6a57ac438912ac68e97aa">&#9670;&#160;</a></span>PHYSFS_ucs4stricmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_ucs4stricmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a> *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a> *&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Case-insensitive compare of two UCS-4 strings. </p>
<p>This is a strcasecmp/stricmp replacement that expects both strings to be in UCS-4 (aka UTF-32) encoding. It will do "case folding" to decide if the Unicode codepoints in the strings match.</p>
<p>It will report which string is "greater than" the other, but be aware that this doesn't necessarily mean anything: 'a' may be "less than" 'b', but a Japanese kuten has no meaningful alphabetically relationship to a Greek lambda, but being able to assign a reliable "value" makes sorting algorithms possible, if not entirely sane. Most cases should treat the return value as "equal" or "not equal".</p>
<p>Like stricmp, this expects both strings to be NULL-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>First string to compare. </td></tr>
    <tr><td class="paramname">str2</td><td>Second string to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if str1 is "less than" str2, 1 if "greater than", 0 if equal. </dd></dl>

</div>
</div>
<a id="aab0e2ba90aa918b2ee1ed7c40293b442" name="aab0e2ba90aa918b2ee1ed7c40293b442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0e2ba90aa918b2ee1ed7c40293b442">&#9670;&#160;</a></span>PHYSFS_unmount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_unmount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>oldDir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a directory or archive from the search path. </p>
<p>This is functionally equivalent to <a class="el" href="physfs_8h.html#a555ee86816418ed3a99e10243c5db7b8" title="Remove a directory or archive from the search path.">PHYSFS_removeFromSearchPath()</a>, but that function is deprecated to keep the vocabulary paired with <a class="el" href="physfs_8h.html#a8eb320e9af03dcdb4c05bbff3ea604d4" title="Add an archive or directory to the search path.">PHYSFS_mount()</a>.</p>
<p>This must be a (case-sensitive) match to a dir or archive already in the search path, specified in platform-dependent notation.</p>
<p>This call will fail (and fail to remove from the path) if the element still has files open in it.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function wants the path to the archive or directory that was mounted (the same string used for the "newDir" argument of PHYSFS_addToSearchPath or any of the mount functions), not the path where it is mounted in the tree (the "mountPoint" argument to any of the mount functions).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldDir</td><td>dir/archive to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nonzero on success, zero on failure. Use <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a> to obtain the specific error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#ac738531e9c7e5ca3797b64985c103cf4" title="Get the current search path.">PHYSFS_getSearchPath</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a8eb320e9af03dcdb4c05bbff3ea604d4" title="Add an archive or directory to the search path.">PHYSFS_mount</a> </dd></dl>

</div>
</div>
<a id="a103f6e35c87cd635d5082b6cffd7974b" name="a103f6e35c87cd635d5082b6cffd7974b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103f6e35c87cd635d5082b6cffd7974b">&#9670;&#160;</a></span>PHYSFS_utf16stricmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_utf16stricmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a> *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a> *&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Case-insensitive compare of two UTF-16 strings. </p>
<p>This is a strcasecmp/stricmp replacement that expects both strings to be in UTF-16 encoding. It will do "case folding" to decide if the Unicode codepoints in the strings match.</p>
<p>It will report which string is "greater than" the other, but be aware that this doesn't necessarily mean anything: 'a' may be "less than" 'b', but a Japanese kuten has no meaningful alphabetically relationship to a Greek lambda, but being able to assign a reliable "value" makes sorting algorithms possible, if not entirely sane. Most cases should treat the return value as "equal" or "not equal".</p>
<p>Like stricmp, this expects both strings to be NULL-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>First string to compare. </td></tr>
    <tr><td class="paramname">str2</td><td>Second string to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if str1 is "less than" str2, 1 if "greater than", 0 if equal. </dd></dl>

</div>
</div>
<a id="a2838ad1240439afd3a21109ea7138014" name="a2838ad1240439afd3a21109ea7138014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2838ad1240439afd3a21109ea7138014">&#9670;&#160;</a></span>PHYSFS_utf8FromLatin1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> PHYSFS_utf8FromLatin1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a UTF-8 string to a Latin1 string. </p>
<p>Latin1 strings are 8-bits per character: a popular "high ASCII" encoding.</p>
<p>To ensure that the destination buffer is large enough for the conversion, please allocate a buffer that is double the size of the source buffer. UTF-8 expands latin1 codepoints over 127 from 1 to 2 bytes, so the string may grow in some cases.</p>
<p>Strings that don't fit in the destination buffer will be truncated, but will always be null-terminated and never have an incomplete UTF-8 sequence at the end. If the buffer length is 0, this function does nothing.</p>
<p>Please note that we do not supply a UTF-8 to Latin1 converter, since Latin1 can't express most Unicode codepoints. It's a legacy encoding; you should be converting away from it at all times.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Null-terminated source string in Latin1 format. </td></tr>
    <tr><td class="paramname">dst</td><td>Buffer to store converted UTF-8 string. </td></tr>
    <tr><td class="paramname">len</td><td>Size, in bytes, of destination buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4fdac7e09fb03ccdccdeed997f09c1a" name="ac4fdac7e09fb03ccdccdeed997f09c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4fdac7e09fb03ccdccdeed997f09c1a">&#9670;&#160;</a></span>PHYSFS_utf8FromUcs2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> PHYSFS_utf8FromUcs2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a UCS-2 string to a UTF-8 string. </p>
<dl class="section warning"><dt>Warning</dt><dd>you almost certainly should use <a class="el" href="physfs_8h.html#abad1e7ea73fb2108e136fc043d9c4b30" title="Convert a UTF-16 string to a UTF-8 string.">PHYSFS_utf8FromUtf16()</a>, which became available in PhysicsFS 2.1, unless you know what you're doing.</dd>
<dd>
This function will not report an error if there are invalid UCS-2 values in the source string. It will replace them with a '?' character and continue on.</dd></dl>
<p>UCS-2 strings are 16-bits per character: <code>TCHAR</code> on Windows, when building with Unicode support. Please note that modern versions of Windows use UTF-16, which is an extended form of UCS-2, and not UCS-2 itself. You almost certainly want <a class="el" href="physfs_8h.html#abad1e7ea73fb2108e136fc043d9c4b30" title="Convert a UTF-16 string to a UTF-8 string.">PHYSFS_utf8FromUtf16()</a> instead.</p>
<p>To ensure that the destination buffer is large enough for the conversion, please allocate a buffer that is double the size of the source buffer. UTF-8 never uses more than 32-bits per character, so while it may shrink a UCS-2 string, it may also expand it.</p>
<p>Strings that don't fit in the destination buffer will be truncated, but will always be null-terminated and never have an incomplete UTF-8 sequence at the end. If the buffer length is 0, this function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Null-terminated source string in UCS-2 format. </td></tr>
    <tr><td class="paramname">dst</td><td>Buffer to store converted UTF-8 string. </td></tr>
    <tr><td class="paramname">len</td><td>Size, in bytes, of destination buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#abad1e7ea73fb2108e136fc043d9c4b30" title="Convert a UTF-16 string to a UTF-8 string.">PHYSFS_utf8FromUtf16</a> </dd></dl>

</div>
</div>
<a id="ac18c9c45db1be6fd26be19d0f4d25a60" name="ac18c9c45db1be6fd26be19d0f4d25a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18c9c45db1be6fd26be19d0f4d25a60">&#9670;&#160;</a></span>PHYSFS_utf8FromUcs4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> PHYSFS_utf8FromUcs4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a UCS-4 string to a UTF-8 string. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function will not report an error if there are invalid UCS-4 values in the source string. It will replace them with a '?' character and continue on.</dd></dl>
<p>UCS-4 (aka UTF-32) strings are 32-bits per character: <code>wchar_t</code> on Unix.</p>
<p>To ensure that the destination buffer is large enough for the conversion, please allocate a buffer that is the same size as the source buffer. UTF-8 never uses more than 32-bits per character, so while it may shrink a UCS-4 string, it will never expand it.</p>
<p>Strings that don't fit in the destination buffer will be truncated, but will always be null-terminated and never have an incomplete UTF-8 sequence at the end. If the buffer length is 0, this function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Null-terminated source string in UCS-4 format. </td></tr>
    <tr><td class="paramname">dst</td><td>Buffer to store converted UTF-8 string. </td></tr>
    <tr><td class="paramname">len</td><td>Size, in bytes, of destination buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abad1e7ea73fb2108e136fc043d9c4b30" name="abad1e7ea73fb2108e136fc043d9c4b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad1e7ea73fb2108e136fc043d9c4b30">&#9670;&#160;</a></span>PHYSFS_utf8FromUtf16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> PHYSFS_utf8FromUtf16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a UTF-16 string to a UTF-8 string. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function will not report an error if there are invalid UTF-16 sequences in the source string. It will replace them with a '?' character and continue on.</dd></dl>
<p>UTF-16 strings are 16-bits per character (except some chars, which are 32-bits): <code>TCHAR</code> on Windows, when building with Unicode support. Modern Windows releases use UTF-16. Windows releases before 2000 used TCHAR, but only handled UCS-2. UTF-16 <em>is</em> UCS-2, except for the characters that are 4 bytes, which aren't representable in UCS-2 at all anyhow. If you aren't sure, you should be using UTF-16 at this point on Windows.</p>
<p>To ensure that the destination buffer is large enough for the conversion, please allocate a buffer that is double the size of the source buffer. UTF-8 never uses more than 32-bits per character, so while it may shrink a UTF-16 string, it may also expand it.</p>
<p>Strings that don't fit in the destination buffer will be truncated, but will always be null-terminated and never have an incomplete UTF-8 sequence at the end. If the buffer length is 0, this function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Null-terminated source string in UTF-16 format. </td></tr>
    <tr><td class="paramname">dst</td><td>Buffer to store converted UTF-8 string. </td></tr>
    <tr><td class="paramname">len</td><td>Size, in bytes, of destination buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa84e68e54bb3b4df8161ea10d03db182" name="aa84e68e54bb3b4df8161ea10d03db182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84e68e54bb3b4df8161ea10d03db182">&#9670;&#160;</a></span>PHYSFS_utf8stricmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_utf8stricmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Case-insensitive compare of two UTF-8 strings. </p>
<p>This is a strcasecmp/stricmp replacement that expects both strings to be in UTF-8 encoding. It will do "case folding" to decide if the Unicode codepoints in the strings match.</p>
<p>If both strings are exclusively low-ASCII characters, this will do the right thing, as that is also valid UTF-8. If there are any high-ASCII chars, this will not do what you expect!</p>
<p>It will report which string is "greater than" the other, but be aware that this doesn't necessarily mean anything: 'a' may be "less than" 'b', but a Japanese kuten has no meaningful alphabetically relationship to a Greek lambda, but being able to assign a reliable "value" makes sorting algorithms possible, if not entirely sane. Most cases should treat the return value as "equal" or "not equal".</p>
<p>Like stricmp, this expects both strings to be NULL-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>First string to compare. </td></tr>
    <tr><td class="paramname">str2</td><td>Second string to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if str1 is "less than" str2, 1 if "greater than", 0 if equal. </dd></dl>

</div>
</div>
<a id="a0ab51c265f7ca4e8218d6c74b4f43401" name="a0ab51c265f7ca4e8218d6c74b4f43401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab51c265f7ca4e8218d6c74b4f43401">&#9670;&#160;</a></span>PHYSFS_utf8ToUcs2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PHYSFS_utf8ToUcs2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a UTF-8 string to a UCS-2 string. </p>
<dl class="section warning"><dt>Warning</dt><dd>you almost certainly should use <a class="el" href="physfs_8h.html#adebf3f8244318c47e061f780ca8882f9" title="Convert a UTF-8 string to a UTF-16 string.">PHYSFS_utf8ToUtf16()</a>, which became available in PhysicsFS 2.1, unless you know what you're doing.</dd>
<dd>
This function will not report an error if there are invalid UTF-8 sequences in the source string. It will replace them with a '?' character and continue on.</dd></dl>
<p>UCS-2 strings are 16-bits per character: <code>TCHAR</code> on Windows, when building with Unicode support. Please note that modern versions of Windows use UTF-16, which is an extended form of UCS-2, and not UCS-2 itself. You almost certainly want <a class="el" href="physfs_8h.html#adebf3f8244318c47e061f780ca8882f9" title="Convert a UTF-8 string to a UTF-16 string.">PHYSFS_utf8ToUtf16()</a> instead, but you need to understand how that changes things, too.</p>
<p>To ensure that the destination buffer is large enough for the conversion, please allocate a buffer that is double the size of the source buffer. UTF-8 uses from one to four bytes per character, but UCS-2 always uses two, so an entirely low-ASCII string will double in size!</p>
<p>Strings that don't fit in the destination buffer will be truncated, but will always be null-terminated and never have an incomplete UCS-2 sequence at the end. If the buffer length is 0, this function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Null-terminated source string in UTF-8 format. </td></tr>
    <tr><td class="paramname">dst</td><td>Buffer to store converted UCS-2 string. </td></tr>
    <tr><td class="paramname">len</td><td>Size, in bytes, of destination buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#adebf3f8244318c47e061f780ca8882f9" title="Convert a UTF-8 string to a UTF-16 string.">PHYSFS_utf8ToUtf16</a> </dd></dl>

</div>
</div>
<a id="a3ff1045e71cd4c14607973da7bfc41e5" name="a3ff1045e71cd4c14607973da7bfc41e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff1045e71cd4c14607973da7bfc41e5">&#9670;&#160;</a></span>PHYSFS_utf8ToUcs4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> PHYSFS_utf8ToUcs4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a UTF-8 string to a UCS-4 string. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function will not report an error if there are invalid UTF-8 sequences in the source string. It will replace them with a '?' character and continue on.</dd></dl>
<p>UCS-4 (aka UTF-32) strings are 32-bits per character: <code>wchar_t</code> on Unix.</p>
<p>To ensure that the destination buffer is large enough for the conversion, please allocate a buffer that is four times the size of the source buffer. UTF-8 uses from one to four bytes per character, but UCS-4 always uses four, so an entirely low-ASCII string will quadruple in size!</p>
<p>Strings that don't fit in the destination buffer will be truncated, but will always be null-terminated and never have an incomplete UCS-4 sequence at the end. If the buffer length is 0, this function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Null-terminated source string in UTF-8 format. </td></tr>
    <tr><td class="paramname">dst</td><td>Buffer to store converted UCS-4 string. </td></tr>
    <tr><td class="paramname">len</td><td>Size, in bytes, of destination buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adebf3f8244318c47e061f780ca8882f9" name="adebf3f8244318c47e061f780ca8882f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adebf3f8244318c47e061f780ca8882f9">&#9670;&#160;</a></span>PHYSFS_utf8ToUtf16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PHYSFS_utf8ToUtf16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a UTF-8 string to a UTF-16 string. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function will not report an error if there are invalid UTF-8 sequences in the source string. It will replace them with a '?' character and continue on.</dd></dl>
<p>UTF-16 strings are 16-bits per character (except some chars, which are 32-bits): <code>TCHAR</code> on Windows, when building with Unicode support. Modern Windows releases use UTF-16. Windows releases before 2000 used TCHAR, but only handled UCS-2. UTF-16 <em>is</em> UCS-2, except for the characters that are 4 bytes, which aren't representable in UCS-2 at all anyhow. If you aren't sure, you should be using UTF-16 at this point on Windows.</p>
<p>To ensure that the destination buffer is large enough for the conversion, please allocate a buffer that is double the size of the source buffer. UTF-8 uses from one to four bytes per character, but UTF-16 always uses two to four, so an entirely low-ASCII string will double in size! The UTF-16 characters that would take four bytes also take four bytes in UTF-8, so you don't need to allocate 4x the space just in case: double will do.</p>
<p>Strings that don't fit in the destination buffer will be truncated, but will always be null-terminated and never have an incomplete UTF-16 surrogate pair at the end. If the buffer length is 0, this function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Null-terminated source string in UTF-8 format. </td></tr>
    <tr><td class="paramname">dst</td><td>Buffer to store converted UTF-16 string. </td></tr>
    <tr><td class="paramname">len</td><td>Size, in bytes, of destination buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#adebf3f8244318c47e061f780ca8882f9" title="Convert a UTF-8 string to a UTF-16 string.">PHYSFS_utf8ToUtf16</a> </dd></dl>

</div>
</div>
<a id="aae7bb76d39dadff2b72f9e4753139a62" name="aae7bb76d39dadff2b72f9e4753139a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7bb76d39dadff2b72f9e4753139a62">&#9670;&#160;</a></span>PHYSFS_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a> PHYSFS_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a>&#160;</td>
          <td class="paramname"><em>objSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a>&#160;</td>
          <td class="paramname"><em>objCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to a PhysicsFS filehandle. </p>
<p>The file must be opened for writing.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated:</a></b></dt><dd>As of PhysicsFS 2.1, use <a class="el" href="physfs_8h.html#a192ae4f946656ae2aef5e16e438f94e1" title="Write data to a PhysicsFS filehandle.">PHYSFS_writeBytes()</a> instead. This function just wraps it anyhow. This function never clarified what would happen if you managed to write a partial object, so working at the byte level makes this cleaner for everyone, especially now that <a class="el" href="struct_p_h_y_s_f_s___io.html" title="An abstract i/o interface.">PHYSFS_Io</a> interfaces can be supplied by the application.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>retval from <a class="el" href="physfs_8h.html#abbf92d66c6cb82d0ede969aa2c964fba" title="Open a file for writing.">PHYSFS_openWrite()</a> or <a class="el" href="physfs_8h.html#abeeca12e2fe7c5f68cbd67e2e5cafa3d" title="Open a file for appending.">PHYSFS_openAppend()</a>. </td></tr>
    <tr><td class="paramname">buffer</td><td>buffer of bytes to write to (handle). </td></tr>
    <tr><td class="paramname">objSize</td><td>size in bytes of objects being written to (handle). </td></tr>
    <tr><td class="paramname">objCount</td><td>number of (objSize) objects to write to (handle). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of objects written. <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a> can shed light on the reason this might be &lt; (objCount). -1 if complete failure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#a192ae4f946656ae2aef5e16e438f94e1" title="Write data to a PhysicsFS filehandle.">PHYSFS_writeBytes</a> </dd></dl>

</div>
</div>
<a id="a192ae4f946656ae2aef5e16e438f94e1" name="a192ae4f946656ae2aef5e16e438f94e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a192ae4f946656ae2aef5e16e438f94e1">&#9670;&#160;</a></span>PHYSFS_writeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a> PHYSFS_writeBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to a PhysicsFS filehandle. </p>
<p>The file must be opened for writing.</p>
<p>Please note that while (len) is an unsigned 64-bit integer, you are limited to 63 bits (9223372036854775807 bytes), so we can return a negative value on error. If length is greater than 0x7FFFFFFFFFFFFFFF, this function will immediately fail. For systems without a 64-bit datatype, you are limited to 31 bits (0x7FFFFFFF, or 2147483647 bytes). We trust most things won't need to do multiple gigabytes of i/o in one call anyhow, but why limit things?</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>retval from <a class="el" href="physfs_8h.html#abbf92d66c6cb82d0ede969aa2c964fba" title="Open a file for writing.">PHYSFS_openWrite()</a> or <a class="el" href="physfs_8h.html#abeeca12e2fe7c5f68cbd67e2e5cafa3d" title="Open a file for appending.">PHYSFS_openAppend()</a>. </td></tr>
    <tr><td class="paramname">buffer</td><td>buffer of (len) bytes to write to (handle). </td></tr>
    <tr><td class="paramname">len</td><td>number of bytes being written to (handle). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written. This may be less than (len); in the case of an error, the system may try to write as many bytes as possible, so an incomplete write might occur. <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a> can shed light on the reason this might be &lt; (len). -1 if complete failure. </dd></dl>

</div>
</div>
<a id="a621ed6d4cb61f9f31efb58acbe3090e3" name="a621ed6d4cb61f9f31efb58acbe3090e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a621ed6d4cb61f9f31efb58acbe3090e3">&#9670;&#160;</a></span>PHYSFS_writeSBE16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_writeSBE16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#aeed97311e1294c0b42648f99d331e5a0">PHYSFS_sint16</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert and write a signed 16-bit bigendian value. </p>
<p>Convenience function. Convert a signed 16-bit value from the platform's native byte order to bigendian and write it to a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>PhysicsFS file handle to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Value to convert and write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on failure, non-zero on success. On failure, you can find out what went wrong from <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>. </dd></dl>

</div>
</div>
<a id="a065910571b8d1bc82eb6ef8e93936028" name="a065910571b8d1bc82eb6ef8e93936028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a065910571b8d1bc82eb6ef8e93936028">&#9670;&#160;</a></span>PHYSFS_writeSBE32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_writeSBE32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#ae0264996863470a315e29d5a740a0f36">PHYSFS_sint32</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert and write a signed 32-bit bigendian value. </p>
<p>Convenience function. Convert a signed 32-bit value from the platform's native byte order to bigendian and write it to a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>PhysicsFS file handle to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Value to convert and write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on failure, non-zero on success. On failure, you can find out what went wrong from <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>. </dd></dl>

</div>
</div>
<a id="ab5f40bbc37733f52fde58e7a5bc55341" name="ab5f40bbc37733f52fde58e7a5bc55341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f40bbc37733f52fde58e7a5bc55341">&#9670;&#160;</a></span>PHYSFS_writeSBE64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_writeSBE64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert and write a signed 64-bit bigending value. </p>
<p>Convenience function. Convert a signed 64-bit value from the platform's native byte order to bigendian and write it to a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>PhysicsFS file handle to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Value to convert and write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on failure, non-zero on success. On failure, you can find out what went wrong from <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Remember, PHYSFS_sint64 is only 32 bits on platforms without any sort of 64-bit support. </dd></dl>

</div>
</div>
<a id="aeaee4b15c4d683a1996ffc72d1d2a6aa" name="aeaee4b15c4d683a1996ffc72d1d2a6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaee4b15c4d683a1996ffc72d1d2a6aa">&#9670;&#160;</a></span>PHYSFS_writeSLE16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_writeSLE16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#aeed97311e1294c0b42648f99d331e5a0">PHYSFS_sint16</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert and write a signed 16-bit littleendian value. </p>
<p>Convenience function. Convert a signed 16-bit value from the platform's native byte order to littleendian and write it to a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>PhysicsFS file handle to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Value to convert and write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on failure, non-zero on success. On failure, you can find out what went wrong from <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>. </dd></dl>

</div>
</div>
<a id="a3a702d04d16b0fa732905b0e7daab407" name="a3a702d04d16b0fa732905b0e7daab407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a702d04d16b0fa732905b0e7daab407">&#9670;&#160;</a></span>PHYSFS_writeSLE32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_writeSLE32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#ae0264996863470a315e29d5a740a0f36">PHYSFS_sint32</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert and write a signed 32-bit littleendian value. </p>
<p>Convenience function. Convert a signed 32-bit value from the platform's native byte order to littleendian and write it to a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>PhysicsFS file handle to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Value to convert and write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on failure, non-zero on success. On failure, you can find out what went wrong from <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>. </dd></dl>

</div>
</div>
<a id="ab48f7be67e4d68315709e7b3fa48f34b" name="ab48f7be67e4d68315709e7b3fa48f34b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48f7be67e4d68315709e7b3fa48f34b">&#9670;&#160;</a></span>PHYSFS_writeSLE64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_writeSLE64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a88c5f1d7b088888c729b22644651c9f5">PHYSFS_sint64</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert and write a signed 64-bit littleendian value. </p>
<p>Convenience function. Convert a signed 64-bit value from the platform's native byte order to littleendian and write it to a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>PhysicsFS file handle to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Value to convert and write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on failure, non-zero on success. On failure, you can find out what went wrong from <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Remember, PHYSFS_sint64 is only 32 bits on platforms without any sort of 64-bit support. </dd></dl>

</div>
</div>
<a id="a66a392f7637bb2ad4c3e395e1a71c54e" name="a66a392f7637bb2ad4c3e395e1a71c54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a392f7637bb2ad4c3e395e1a71c54e">&#9670;&#160;</a></span>PHYSFS_writeUBE16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_writeUBE16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert and write an unsigned 16-bit bigendian value. </p>
<p>Convenience function. Convert an unsigned 16-bit value from the platform's native byte order to bigendian and write it to a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>PhysicsFS file handle to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Value to convert and write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on failure, non-zero on success. On failure, you can find out what went wrong from <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>. </dd></dl>

</div>
</div>
<a id="a98a497bc47cb177fe1bf835abe28baad" name="a98a497bc47cb177fe1bf835abe28baad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a497bc47cb177fe1bf835abe28baad">&#9670;&#160;</a></span>PHYSFS_writeUBE32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_writeUBE32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert and write an unsigned 32-bit bigendian value. </p>
<p>Convenience function. Convert an unsigned 32-bit value from the platform's native byte order to bigendian and write it to a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>PhysicsFS file handle to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Value to convert and write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on failure, non-zero on success. On failure, you can find out what went wrong from <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>. </dd></dl>

</div>
</div>
<a id="a03fc124e5dfd2801361eeefcee7d1ff7" name="a03fc124e5dfd2801361eeefcee7d1ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03fc124e5dfd2801361eeefcee7d1ff7">&#9670;&#160;</a></span>PHYSFS_writeUBE64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_writeUBE64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert and write an unsigned 64-bit bigendian value. </p>
<p>Convenience function. Convert an unsigned 64-bit value from the platform's native byte order to bigendian and write it to a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>PhysicsFS file handle to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Value to convert and write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on failure, non-zero on success. On failure, you can find out what went wrong from <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Remember, PHYSFS_uint64 is only 32 bits on platforms without any sort of 64-bit support. </dd></dl>

</div>
</div>
<a id="add6bdd5da0e7466b2bace0c914bcf3ac" name="add6bdd5da0e7466b2bace0c914bcf3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6bdd5da0e7466b2bace0c914bcf3ac">&#9670;&#160;</a></span>PHYSFS_writeULE16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_writeULE16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#ac4d1c74e276b04ef993530a405553574">PHYSFS_uint16</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert and write an unsigned 16-bit littleendian value. </p>
<p>Convenience function. Convert an unsigned 16-bit value from the platform's native byte order to littleendian and write it to a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>PhysicsFS file handle to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Value to convert and write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on failure, non-zero on success. On failure, you can find out what went wrong from <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>. </dd></dl>

</div>
</div>
<a id="a9566e5d04e793b851dc7b9c26f3b23cb" name="a9566e5d04e793b851dc7b9c26f3b23cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9566e5d04e793b851dc7b9c26f3b23cb">&#9670;&#160;</a></span>PHYSFS_writeULE32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_writeULE32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert and write an unsigned 32-bit littleendian value. </p>
<p>Convenience function. Convert an unsigned 32-bit value from the platform's native byte order to littleendian and write it to a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>PhysicsFS file handle to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Value to convert and write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on failure, non-zero on success. On failure, you can find out what went wrong from <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>. </dd></dl>

</div>
</div>
<a id="aaeb795dbdde0fb87fbc8b92471fb85ab" name="aaeb795dbdde0fb87fbc8b92471fb85ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb795dbdde0fb87fbc8b92471fb85ab">&#9670;&#160;</a></span>PHYSFS_writeULE64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHYSFS_writeULE64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_h_y_s_f_s___file.html">PHYSFS_File</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="physfs_8h.html#a632ba02500231e5f6f6df2e4cb71c818">PHYSFS_uint64</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert and write an unsigned 64-bit littleendian value. </p>
<p>Convenience function. Convert an unsigned 64-bit value from the platform's native byte order to littleendian and write it to a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>PhysicsFS file handle to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Value to convert and write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on failure, non-zero on success. On failure, you can find out what went wrong from <a class="el" href="physfs_8h.html#ae916a873aae2cf6b6e09d733cd1b3f4b" title="Get machine-readable error information.">PHYSFS_getLastErrorCode()</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Remember, PHYSFS_uint64 is only 32 bits on platforms without any sort of 64-bit support. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_93501a11e921083efbd154e0cdff5f10.html">packages</a></li><li class="navelem"><a class="el" href="dir_5231ec13610cfaac4790c61103e13700.html">AllegroDeps.1.13.0</a></li><li class="navelem"><a class="el" href="dir_d5cc7b0ba1ffdf84f3ec7f501b134cb6.html">build</a></li><li class="navelem"><a class="el" href="dir_f0af660ba7ceb6325064fd9ed5c38fd1.html">native</a></li><li class="navelem"><a class="el" href="dir_5f12c56d3dd723b54e45ed3518b08f15.html">include</a></li><li class="navelem"><a class="el" href="physfs_8h.html">physfs.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
