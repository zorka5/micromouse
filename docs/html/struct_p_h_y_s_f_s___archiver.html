<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>micromouse: PHYSFS_Archiver Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">micromouse
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('struct_p_h_y_s_f_s___archiver.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="struct_p_h_y_s_f_s___archiver-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">PHYSFS_Archiver Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Abstract interface to provide support for user-defined archives.  
 <a href="struct_p_h_y_s_f_s___archiver.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="physfs_8h_source.html">physfs.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aa8b70f3e0cf85eea8b4959a3c6a5f695" id="r_aa8b70f3e0cf85eea8b4959a3c6a5f695"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___archiver.html#aa8b70f3e0cf85eea8b4959a3c6a5f695">version</a></td></tr>
<tr class="memdesc:aa8b70f3e0cf85eea8b4959a3c6a5f695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary compatibility information.  <br /></td></tr>
<tr class="separator:aa8b70f3e0cf85eea8b4959a3c6a5f695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5352f0640f0e2bcb9b8adfd467c8096" id="r_ac5352f0640f0e2bcb9b8adfd467c8096"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_p_h_y_s_f_s___archive_info.html">PHYSFS_ArchiveInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___archiver.html#ac5352f0640f0e2bcb9b8adfd467c8096">info</a></td></tr>
<tr class="memdesc:ac5352f0640f0e2bcb9b8adfd467c8096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic info about this archiver.  <br /></td></tr>
<tr class="separator:ac5352f0640f0e2bcb9b8adfd467c8096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57b1bbbb86a702ef92e9860db0e5d4d" id="r_aa57b1bbbb86a702ef92e9860db0e5d4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___archiver.html#aa57b1bbbb86a702ef92e9860db0e5d4d">openArchive</a> )(<a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *io, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *name, int forWrite, int *claimed)</td></tr>
<tr class="memdesc:aa57b1bbbb86a702ef92e9860db0e5d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open an archive provided by (io).  <br /></td></tr>
<tr class="separator:aa57b1bbbb86a702ef92e9860db0e5d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae4a30fb4095aa90259da021ebc3ff6" id="r_a9ae4a30fb4095aa90259da021ebc3ff6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="physfs_8h.html#aa11a2522c5f699b00d19802b721e73d4">PHYSFS_EnumerateCallbackResult</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___archiver.html#a9ae4a30fb4095aa90259da021ebc3ff6">enumerate</a> )(<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *opaque, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *dirname, <a class="el" href="physfs_8h.html#a1e72dbc92c0decdca218c8a9a658e788">PHYSFS_EnumerateCallback</a> cb, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *origdir, <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *callbackdata)</td></tr>
<tr class="memdesc:a9ae4a30fb4095aa90259da021ebc3ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">List all files in (dirname).  <br /></td></tr>
<tr class="separator:a9ae4a30fb4095aa90259da021ebc3ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638732f1c40dd6187a9c42e3b742df0d" id="r_a638732f1c40dd6187a9c42e3b742df0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___archiver.html#a638732f1c40dd6187a9c42e3b742df0d">openRead</a> )(<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *opaque, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *fnm)</td></tr>
<tr class="memdesc:a638732f1c40dd6187a9c42e3b742df0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file in this archive for reading.  <br /></td></tr>
<tr class="separator:a638732f1c40dd6187a9c42e3b742df0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6b77edf16d8e2636313c822a95fe06" id="r_ace6b77edf16d8e2636313c822a95fe06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___archiver.html#ace6b77edf16d8e2636313c822a95fe06">openWrite</a> )(<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *opaque, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *filename)</td></tr>
<tr class="memdesc:ace6b77edf16d8e2636313c822a95fe06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file in this archive for writing.  <br /></td></tr>
<tr class="separator:ace6b77edf16d8e2636313c822a95fe06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdec9ceb3835db020c8a11341c4a83a" id="r_aebdec9ceb3835db020c8a11341c4a83a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___archiver.html#aebdec9ceb3835db020c8a11341c4a83a">openAppend</a> )(<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *opaque, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *filename)</td></tr>
<tr class="memdesc:aebdec9ceb3835db020c8a11341c4a83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file in this archive for appending.  <br /></td></tr>
<tr class="separator:aebdec9ceb3835db020c8a11341c4a83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add84976a1713102f38fde19a8ee8a5c7" id="r_add84976a1713102f38fde19a8ee8a5c7"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___archiver.html#add84976a1713102f38fde19a8ee8a5c7">remove</a> )(<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *opaque, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *filename)</td></tr>
<tr class="memdesc:add84976a1713102f38fde19a8ee8a5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a file or directory in the archive.  <br /></td></tr>
<tr class="separator:add84976a1713102f38fde19a8ee8a5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd95b2a3afb0f94025c486b514d72189" id="r_abd95b2a3afb0f94025c486b514d72189"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___archiver.html#abd95b2a3afb0f94025c486b514d72189">mkdir</a> )(<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *opaque, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *filename)</td></tr>
<tr class="memdesc:abd95b2a3afb0f94025c486b514d72189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a directory in the archive.  <br /></td></tr>
<tr class="separator:abd95b2a3afb0f94025c486b514d72189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328a2e28430dfab9abe53678b29d0dbb" id="r_a328a2e28430dfab9abe53678b29d0dbb"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___archiver.html#a328a2e28430dfab9abe53678b29d0dbb">stat</a> )(<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *opaque, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *fn, <a class="el" href="struct_p_h_y_s_f_s___stat.html">PHYSFS_Stat</a> *stat)</td></tr>
<tr class="memdesc:a328a2e28430dfab9abe53678b29d0dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain basic file metadata.  <br /></td></tr>
<tr class="separator:a328a2e28430dfab9abe53678b29d0dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a949a909f8ee4688077d3339b2f3f9" id="r_a28a949a909f8ee4688077d3339b2f3f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_y_s_f_s___archiver.html#a28a949a909f8ee4688077d3339b2f3f9">closeArchive</a> )(<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *opaque)</td></tr>
<tr class="memdesc:a28a949a909f8ee4688077d3339b2f3f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct a previously-opened archive.  <br /></td></tr>
<tr class="separator:a28a949a909f8ee4688077d3339b2f3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract interface to provide support for user-defined archives. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is advanced, hardcore stuff. You don't need this unless you really know what you're doing. Most apps will not need this.</dd></dl>
<p>Historically, PhysicsFS provided a means to mount various archive file formats, and physical directories in the native filesystem. However, applications have been limited to the file formats provided by the library. This interface allows an application to provide their own archive file types.</p>
<p>Conceptually, a <a class="el" href="struct_p_h_y_s_f_s___archiver.html" title="Abstract interface to provide support for user-defined archives.">PHYSFS_Archiver</a> provides directory entries, while <a class="el" href="struct_p_h_y_s_f_s___io.html" title="An abstract i/o interface.">PHYSFS_Io</a> provides data streams for those directory entries. The most obvious use of <a class="el" href="struct_p_h_y_s_f_s___archiver.html" title="Abstract interface to provide support for user-defined archives.">PHYSFS_Archiver</a> is to provide support for an archive file type that isn't provided by PhysicsFS directly: perhaps some proprietary format that only your application needs to understand.</p>
<p>Internally, all the built-in archive support uses this interface, so the best examples for building a <a class="el" href="struct_p_h_y_s_f_s___archiver.html" title="Abstract interface to provide support for user-defined archives.">PHYSFS_Archiver</a> is the source code to PhysicsFS itself.</p>
<p>An archiver is added to the system with <a class="el" href="physfs_8h.html#ace0ecda857dc622e2d005af02972237d" title="Add a new archiver to the system.">PHYSFS_registerArchiver()</a>, and then it will be available for use automatically with <a class="el" href="physfs_8h.html#a8eb320e9af03dcdb4c05bbff3ea604d4" title="Add an archive or directory to the search path.">PHYSFS_mount()</a>; if a given archive can be handled with your archiver, it will be given control as appropriate.</p>
<p>These methods deal with dir handles. You have one instance of your archiver, and it generates a unique, opaque handle for each opened archive in its <a class="el" href="struct_p_h_y_s_f_s___archiver.html#aa57b1bbbb86a702ef92e9860db0e5d4d" title="Open an archive provided by (io).">openArchive()</a> method. Since the lifetime of an Archiver (not an archive) is generally the entire lifetime of the process, and it's assumed to be a singleton, we do not provide any instance data for the archiver itself; the app can just use some static variables if necessary.</p>
<p>Symlinks should always be followed (except in <a class="el" href="struct_p_h_y_s_f_s___archiver.html#a328a2e28430dfab9abe53678b29d0dbb" title="Obtain basic file metadata.">stat()</a>); PhysicsFS will use the <a class="el" href="struct_p_h_y_s_f_s___archiver.html#a328a2e28430dfab9abe53678b29d0dbb" title="Obtain basic file metadata.">stat()</a> method to check for symlinks and make a judgement on whether to continue to call other methods based on that.</p>
<p>Archivers, when necessary, should set the PhysicsFS error state with <a class="el" href="physfs_8h.html#ade2c854542c68abc2015649fadd3a623" title="Set the current thread&#39;s error code.">PHYSFS_setErrorCode()</a> before returning. PhysicsFS will pass these errors back to the application unmolested in most cases.</p>
<p>Thread safety: <a class="el" href="struct_p_h_y_s_f_s___archiver.html" title="Abstract interface to provide support for user-defined archives.">PHYSFS_Archiver</a> implementations are not guaranteed to be thread safe in themselves. PhysicsFS provides thread safety when it calls into a given archiver inside the library, but it does not promise that using the same <a class="el" href="struct_p_h_y_s_f_s___file.html" title="A PhysicsFS file handle.">PHYSFS_File</a> from two threads at once is thread-safe; as such, your <a class="el" href="struct_p_h_y_s_f_s___archiver.html" title="Abstract interface to provide support for user-defined archives.">PHYSFS_Archiver</a> can assume that locking is handled for you so long as the <a class="el" href="struct_p_h_y_s_f_s___io.html" title="An abstract i/o interface.">PHYSFS_Io</a> you return from PHYSFS_open* doesn't change any of your Archiver state, as the <a class="el" href="struct_p_h_y_s_f_s___io.html" title="An abstract i/o interface.">PHYSFS_Io</a> won't be as aggressively protected.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="physfs_8h.html#ace0ecda857dc622e2d005af02972237d" title="Add a new archiver to the system.">PHYSFS_registerArchiver</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#abbc7cce9112c5ddc2f3a9ad5d0edf6e0" title="Remove an archiver from the system.">PHYSFS_deregisterArchiver</a> </dd>
<dd>
<a class="el" href="physfs_8h.html#a4ca65fbaa485d68113912bbbd70bd19e" title="Get a list of supported archive types.">PHYSFS_supportedArchiveTypes</a> </dd></dl>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a id="a28a949a909f8ee4688077d3339b2f3f9" name="a28a949a909f8ee4688077d3339b2f3f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a949a909f8ee4688077d3339b2f3f9">&#9670;&#160;</a></span>closeArchive</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>(* PHYSFS_Archiver::closeArchive) (<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *opaque)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destruct a previously-opened archive. </p>
<p>Close this archive, and free any associated memory, including the original <a class="el" href="struct_p_h_y_s_f_s___io.html" title="An abstract i/o interface.">PHYSFS_Io</a> and (opaque) itself, if applicable. Implementation can assume that it won't be called if there are still files open from this archive. </p>

</div>
</div>
<a id="a9ae4a30fb4095aa90259da021ebc3ff6" name="a9ae4a30fb4095aa90259da021ebc3ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae4a30fb4095aa90259da021ebc3ff6">&#9670;&#160;</a></span>enumerate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#aa11a2522c5f699b00d19802b721e73d4">PHYSFS_EnumerateCallbackResult</a>(* PHYSFS_Archiver::enumerate) (<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *opaque, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *dirname, <a class="el" href="physfs_8h.html#a1e72dbc92c0decdca218c8a9a658e788">PHYSFS_EnumerateCallback</a> cb, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *origdir, <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *callbackdata)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List all files in (dirname). </p>
<p>Each file is passed to (cb), where a copy is made if appropriate, so you can dispose of it upon return from the callback. (dirname) is in platform-independent notation. If you have a failure, call PHYSFS_SetErrorCode() with whatever code seem appropriate and return PHYSFS_ENUM_ERROR. If the callback returns PHYSFS_ENUM_ERROR, please call PHYSFS_SetErrorCode(PHYSFS_ERR_APP_CALLBACK) and then return PHYSFS_ENUM_ERROR as well. Don't call the callback again in any circumstances. If the callback returns PHYSFS_ENUM_STOP, stop enumerating and return PHYSFS_ENUM_STOP as well. Don't call the callback again in any circumstances. Don't set an error code in this case. Callbacks are only supposed to return a value from PHYSFS_EnumerateCallbackResult. Any other result has undefined behavior. As long as the callback returned PHYSFS_ENUM_OK and you haven't experienced any errors of your own, keep enumerating until you're done and then return PHYSFS_ENUM_OK without setting an error code.</p>
<dl class="section warning"><dt>Warning</dt><dd>PHYSFS_enumerate returns zero or non-zero (success or failure), so be aware this function pointer returns different values! </dd></dl>

</div>
</div>
<a id="ac5352f0640f0e2bcb9b8adfd467c8096" name="ac5352f0640f0e2bcb9b8adfd467c8096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5352f0640f0e2bcb9b8adfd467c8096">&#9670;&#160;</a></span>info</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_p_h_y_s_f_s___archive_info.html">PHYSFS_ArchiveInfo</a> PHYSFS_Archiver::info</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Basic info about this archiver. </p>
<p>This is used to identify your archive, and is returned in <a class="el" href="physfs_8h.html#a4ca65fbaa485d68113912bbbd70bd19e" title="Get a list of supported archive types.">PHYSFS_supportedArchiveTypes()</a>. </p>

</div>
</div>
<a id="abd95b2a3afb0f94025c486b514d72189" name="abd95b2a3afb0f94025c486b514d72189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd95b2a3afb0f94025c486b514d72189">&#9670;&#160;</a></span>mkdir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* PHYSFS_Archiver::mkdir) (<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *opaque, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *filename)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a directory in the archive. </p>
<p>If the application is trying to make multiple dirs, PhysicsFS will split them up into multiple calls before passing them to your driver. If the archive is read-only, this operation should fail. Return non-zero on success, zero on failure. This filename is in platform-independent notation. On failure, call <a class="el" href="physfs_8h.html#ade2c854542c68abc2015649fadd3a623" title="Set the current thread&#39;s error code.">PHYSFS_setErrorCode()</a>. </p>

</div>
</div>
<a id="aebdec9ceb3835db020c8a11341c4a83a" name="aebdec9ceb3835db020c8a11341c4a83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebdec9ceb3835db020c8a11341c4a83a">&#9670;&#160;</a></span>openAppend</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *(* PHYSFS_Archiver::openAppend) (<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *opaque, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *filename)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a file in this archive for appending. </p>
<p>If the file does not exist, it should be created. The writing offset should be the end of the file. If the archive is read-only, this operation should fail. This filename is in platform-independent notation. Returns NULL on failure, and calls <a class="el" href="physfs_8h.html#ade2c854542c68abc2015649fadd3a623" title="Set the current thread&#39;s error code.">PHYSFS_setErrorCode()</a>. Returns non-NULL on success. The pointer returned will be passed as the "opaque" parameter for later file calls. </p>

</div>
</div>
<a id="aa57b1bbbb86a702ef92e9860db0e5d4d" name="aa57b1bbbb86a702ef92e9860db0e5d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57b1bbbb86a702ef92e9860db0e5d4d">&#9670;&#160;</a></span>openArchive</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *(* PHYSFS_Archiver::openArchive) (<a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *io, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *name, int forWrite, int *claimed)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open an archive provided by (io). </p>
<p>This is where resources are allocated and data is parsed when mounting an archive. (name) is a filename associated with (io), but doesn't necessarily map to anything, let alone a real filename. This possibly- meaningless name is in platform-dependent notation. (forWrite) is non-zero if this is to be used for the write directory, and zero if this is to be used for an element of the search path. (claimed) should be set to 1 if this is definitely an archive your archiver implementation can handle, even if it fails. We use to decide if we should stop trying other archivers if you fail to open it. For example: the .zip archiver will set this to 1 for something that's got a .zip file signature, even if it failed because the file was also truncated. No sense in trying other archivers here, we already tried to handle it with the appropriate implementation!. Return NULL on failure and set (claimed) appropriately. If no archiver opened the archive or set (claimed), <a class="el" href="physfs_8h.html#a8eb320e9af03dcdb4c05bbff3ea604d4" title="Add an archive or directory to the search path.">PHYSFS_mount()</a> will report PHYSFS_ERR_UNSUPPORTED. Otherwise, it will report the error from the archiver that claimed the data through (claimed). Return non-NULL on success. The pointer returned will be passed as the "opaque" parameter for later calls. </p>

</div>
</div>
<a id="a638732f1c40dd6187a9c42e3b742df0d" name="a638732f1c40dd6187a9c42e3b742df0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a638732f1c40dd6187a9c42e3b742df0d">&#9670;&#160;</a></span>openRead</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *(* PHYSFS_Archiver::openRead) (<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *opaque, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *fnm)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a file in this archive for reading. </p>
<p>This filename, (fnm), is in platform-independent notation. Fail if the file does not exist. Returns NULL on failure, and calls <a class="el" href="physfs_8h.html#ade2c854542c68abc2015649fadd3a623" title="Set the current thread&#39;s error code.">PHYSFS_setErrorCode()</a>. Returns non-NULL on success. The pointer returned will be passed as the "opaque" parameter for later file calls. </p>

</div>
</div>
<a id="ace6b77edf16d8e2636313c822a95fe06" name="ace6b77edf16d8e2636313c822a95fe06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6b77edf16d8e2636313c822a95fe06">&#9670;&#160;</a></span>openWrite</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_p_h_y_s_f_s___io.html">PHYSFS_Io</a> *(* PHYSFS_Archiver::openWrite) (<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *opaque, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *filename)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a file in this archive for writing. </p>
<p>If the file does not exist, it should be created. If it exists, it should be truncated to zero bytes. The writing offset should be the start of the file. If the archive is read-only, this operation should fail. This filename is in platform-independent notation. Returns NULL on failure, and calls <a class="el" href="physfs_8h.html#ade2c854542c68abc2015649fadd3a623" title="Set the current thread&#39;s error code.">PHYSFS_setErrorCode()</a>. Returns non-NULL on success. The pointer returned will be passed as the "opaque" parameter for later file calls. </p>

</div>
</div>
<a id="add84976a1713102f38fde19a8ee8a5c7" name="add84976a1713102f38fde19a8ee8a5c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add84976a1713102f38fde19a8ee8a5c7">&#9670;&#160;</a></span>remove</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* PHYSFS_Archiver::remove) (<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *opaque, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *filename)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a file or directory in the archive. </p>
<p>This same call is used for both files and directories; there is not a separate rmdir() call. Directories are only meant to be removed if they are empty. If the archive is read-only, this operation should fail.</p>
<p>Return non-zero on success, zero on failure. This filename is in platform-independent notation. On failure, call <a class="el" href="physfs_8h.html#ade2c854542c68abc2015649fadd3a623" title="Set the current thread&#39;s error code.">PHYSFS_setErrorCode()</a>. </p>

</div>
</div>
<a id="a328a2e28430dfab9abe53678b29d0dbb" name="a328a2e28430dfab9abe53678b29d0dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328a2e28430dfab9abe53678b29d0dbb">&#9670;&#160;</a></span>stat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* PHYSFS_Archiver::stat) (<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *opaque, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *fn, <a class="el" href="struct_p_h_y_s_f_s___stat.html">PHYSFS_Stat</a> *stat)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain basic file metadata. </p>
<p>On success, fill in all the fields in (stat), using reasonable defaults for fields that apply to your archive.</p>
<p>Returns non-zero on success, zero on failure. This filename is in platform-independent notation. On failure, call <a class="el" href="physfs_8h.html#ade2c854542c68abc2015649fadd3a623" title="Set the current thread&#39;s error code.">PHYSFS_setErrorCode()</a>. </p>

</div>
</div>
<a id="aa8b70f3e0cf85eea8b4959a3c6a5f695" name="aa8b70f3e0cf85eea8b4959a3c6a5f695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b70f3e0cf85eea8b4959a3c6a5f695">&#9670;&#160;</a></span>version</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="physfs_8h.html#aae011b45ebd619edb193fe196e1f5f74">PHYSFS_uint32</a> PHYSFS_Archiver::version</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary compatibility information. </p>
<p>This must be set to zero at this time. Future versions of this struct will increment this field, so we know what a given implementation supports. We'll presumably keep supporting older versions as we offer new features, though. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="struct_p_h_y_s_f_s___archiver.html">PHYSFS_Archiver</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
