<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>micromouse: Design choices and concepts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">micromouse
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_scope__guard_2docs_2design.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Design choices and concepts</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a> This section tries to clarify concepts used in the interface and discusses the rationale for some design decisions. The outline is:</p>
<ul>
<li>No exceptions</li>
<li>Implications of requiring `noexcept` callbacks at compile time</li>
<li>No return</li>
<li>Conditional `noexcept`</li>
<li>No extra arguments</li>
<li>Private constructor</li>
<li>Unspecified type</li>
<li>No default constructor or assignment operator</li>
<li>SFINAE friendliness</li>
</ul>
<h2><a class="anchor" id="autotoc_md1"></a>
No exceptions</h2>
<p>Scope guards rely on the destructor to execute the client's operation. That elicits special consideration regarding possible callback exceptions. Possible options to deal with potential exceptions arising from a callback (or a callback's destruction) are:</p>
<ol type="1">
<li>Allowing exceptions and...<ol type="a">
<li>... always ignoring (silently, with logging...)</li>
<li>... always aborting (with std::terminate)</li>
<li>... relegating handling to the caller (rethrowing).</li>
<li>... providing a way for the client to convey a handling policy to the scope guard (1, 2, 3, or some custom operation)</li>
</ol>
</li>
<li>Forbidding exceptions in the first place.</li>
</ol>
<h5>Options 1.1 and 1.2 - uniform handling</h5>
<p>Exceptions permit custom handling of distinct errors by higher level callers, so they can make use of higher level information that is only available to them. Uniform default handling methods would contradict that purpose and should in principle be avoided. That advises against options 1.1 and 1.2. Specifically, ignoring errors in a systematic manner is hardly a reasonable option. Idem for allowing exceptions only to abort when they arise, which would transmit conflicting ideas to the user.</p>
<h5>Option 1.3 (and 1.2 fallback) - rethrowing</h5>
<p>A crucial property of exceptions is that they propagate automatically, freeing intermediaries from boilerplate code. Option 1.3 exploits that property and is usually the ideal default. To the point that no special code needs to be written for it (rethrowing happens automatically). Destructors are special though. Alas, <em>exceptions do not always propagate</em>. In particular, they do not propagate when the stack is already unwinding. To put it another way, exception propagation is really only achievable from code that is not already being executed in the context of exception propagation. Which is one of the circumstances where scope guards are most useful. In those cases, the program aborts, meaning that option 1.3 implies falling back on 1.2.</p>
<p>Still, option 1.3 (with 1.2 fallback) is appealling. It can be implemented simply with a destructor that a) is not <code>noexcept</code> when the callback isn't either; and b) leaves exceptions to behave as they do by default. In other words, by just declaring the destructor <code>noexcept(noexcept(callback()))</code> and otherwise leaving exceptions alone. This would allow using scope guards for exception throwing in regular cases (non-stack-unwinding). It is the path followed by other implementations, including <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4189.pdf">N4189</a> (section 7.3). One I considered seriously.</p>
<p>However, I ended up deciding against it. It would create a false sense of safety and lead to hidden <em>crashes</em>. It is easy to imagine situations with callbacks happily throwing under regular test conditions, only to cause crashes in production. Better <em>fail-fast</em> to discourage the client from relying on, or otherwise using, throwing callbacks. After all, throwing destructors are considered bad practice for a reason.</p>
<h5>Option 1.4 - policy</h5>
<p>Option 1.4 could be achieved with some additional policy parameter for the client's choice, but that would complicate an interface that is desirably simple. If there was no default, the client would have to choose a policy even if no exceptions were involved. With a default, the client would need to remember considering it in each case. And, critically, choosing a default means recurring into the present problem &ndash; of how to deal with exceptions in the first place &ndash; which does not have a satisfactory answer so far.</p>
<h5>Option 2 - forbidding exceptions</h5>
<p>That leaves option 2, which is the one I went for. It still allows throwing operations to be used indirectly, if they are <em>converted</em> to non-throwing. That can be achieved <a href="precond.md#nothrow-invocable">easily</a> with a try-catch wrapping that ignores (as in 1.1), aborts (as in 1.2) or chooses a custom way of handling the exception (as in 1.4), as long as it does not require throwing. Nothing like 1.3 is possible within option 2 as, by definition, it precludes uses involving throwing. But that is perhaps a sensible target, taking into account the arguments above.</p>
<p>An <a href="interface.md/#compilation-option-sg_require_noexcept_in_cpp17">option</a> to enforce this at compilation is available, but requires C++17 and has other implications. In the absence of compile-time checking, if a callback happens to throw <em>by mistake</em>, the program aborts via a call to <code>std::terminate</code> (the dtor is declared <code>noexcept</code>).</p>
<p>The distinction between option 2 and 1.2 is important, even if subtle: here the specification expressly places a burden of ensuring non-throwing callbacks on the client, making it clear they cannot be expected to work. This follows the same approach as custom deleters in such standard library types as <code>unique_ptr</code> and <code>shared_ptr</code> (see <code>[unique.ptr.single.ctor]</code> and <code>[unique.ptr.single.dtor]</code> in the C++ standard).</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Implications of requiring &lt;tt&gt;noexcept&lt;/tt&gt; callbacks at compile time</h2>
<p>In C++17 the exception specification becomes part of a function's type. That enables requiring <code>noexcept</code> callbacks for scope guards, something that was not possible <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0012r1.html">until then</a>.</p>
<p>Unfortunately, even in C++17 things are not ideal, and information on exception specification is not propagated to types like <code>std::function</code> or the result of <code>std::bind</code> and <code>std::ref</code>. For instance, the following code does not compile in C++17, at least in <em>gcc</em> and <em>clang</em>:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> f() noexcept { }</div>
<div class="line"><span class="keyword">auto</span> stdf_noexc = std::function&lt;<a class="code hl_variable" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>(&amp;)()<span class="keyword">noexcept</span>&gt;{f}; <span class="comment">// ERROR</span></div>
<div class="line"><span class="keyword">auto</span> stdf_declt = std::function&lt;<span class="keyword">decltype</span>(f)&gt;{f};       <span class="comment">// ERROR</span></div>
<div class="line"><span class="keyword">auto</span> stdf = std::function&lt;<a class="code hl_variable" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>()&gt;{f};                  <span class="comment">/* fine, but drops</span></div>
<div class="line"><span class="comment">                                                          noexcept info */</span></div>
<div class="ttc" id="alibpng16_2png_8h_html_a05f08be336491be77cd4dfa98f747c69"><div class="ttname"><a href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a></div><div class="ttdeci">void</div><div class="ttdef"><b>Definition</b> png.h:1080</div></div>
</div><!-- fragment --><p>Therefore, such types cannot be used directly to create scope guards when <code>noexcept</code> is <a href="interface.md/#compilation-option-sg_require_noexcept_in_cpp17">enforced</a>. In other words, that option's additional safety sacrifices generality. Of course, clients can still use compliant alternatives to wrap anything else (e.g. a <code>noexcept</code> lambda).</p>
<p>In order to maintain the same behavior accross C++ standard versions, this option is disabled by default. I personally favor enabling it, if possible (in &ge;C++17).</p>
<h2><a class="anchor" id="autotoc_md3"></a>
No return</h2>
<p>A scope guard cannot know what to do with any callback returns. It can only ignore and discard them. But returns express information that is usually important. They are often employed for error handling and even to transfer resource ownership. Forgetting to check returns is a familiar cause of bugs. Linters look for them and compilers provide special attributes to warn against them (e.g <a href="https://gcc.gnu.org/onlinedocs/gcc-4.7.2/gcc/Function-Attributes.html">warn_unused_result</a>). The attribute [[nodiscard]] was even added to C++17 to help addressing such issues.</p>
<p>The situation is still suboptimal, in my opinion. The decision of whether to ignore a return should belong to the caller, not the provider. But it should be an explicit decision (just like casts for conversions). In an ideal world, ignored returns should never have been possible without a conscious request from the programmer that communicated intent to both the compiler and the reader.</p>
<p>Unfortunately that is not how things evolved and existing code relies on existing rules. It is not so for new code, which is free to make improvements. That is the intention behind the "void return" requirement here. It forces the client to confirm their intention, by explicitly writing code to <a href="precond.md#void-return">ignore a return</a>, if that really is what they want. It catches unintentional cases and highlights intentional ones for the reader.</p>
<p>Downsides have to be weighter too, but in this case I see only two and I don't think they are determinant:</p>
<ol type="1">
<li>consistency</li>
<li>performance</li>
</ol>
<p>Regarding 1, one could argue that the normal programmer expectation is that returns can be ignored, taking into account not only language rules but also existing APIs. For instance, I realize that the option in <code>std::thread</code> and <code>std::function</code> is to allow returns:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">bool</span> f() { <span class="keywordflow">return</span> <span class="keyword">false</span>; }</div>
<div class="line">...</div>
<div class="line">std::thread t{f}; <span class="comment">// Accepted, return is lost</span></div>
<div class="line"><span class="keyword">auto</span> r2 = t.join(); <span class="comment">// ERROR, no good, returns void</span></div>
<div class="line">std::function&lt;<a class="code hl_variable" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>()&gt; wrap{f}; <span class="comment">// Accepted, return is lost</span></div>
<div class="line"><span class="keyword">auto</span> r1 = wrap(); <span class="comment">// ERROR, wrap does not return anything</span></div>
</div><!-- fragment --><p>However, while consistency is a desirable property, it is hardly a critical one for new undertakings. And it is frequently incompatible with improvement &ndash; preventing change also stalls advance. Asking the reader not to take offense at the title and headings, I suggest a look at <a href="http://slashslash.info/2018/02/a-foolish-consistency/">Jon Kalb's post</a> on the matter, which guides my own perspective and is much more eloquent that I could hope to be.</p>
<p>Notice that since it is enforced at compile-time, the user is quickly alerted to the approach taken here, so he cannot commit to unintentional mistakes or be surprised by runtime problems, which compile time errors mean to avoid.</p>
<p>Concerning 2, it is true that the scope guards will require some returning operations to be wrapped in an additional indirection. Function casts can't help and the only way to use a returning function is to wrap it in a non-returning callable. There are no guarantees that the compiler will inline or optimize the wrapping away, so there may be a non-null performance penalty, even if a tiny one.</p>
<p>That is the price to pay. I view it as analogous to the price that is payed when using std::string rather than char[], vector instead of plain arrays, or lambdas instead of functions. As in those cases, it is negligible and almost always worth it. In the rare occasions where measuring shows that price to be significant, a scope guard is not the right tool. The concept of scope guard always proposes wrapping as a means of avoiding repetition and corner-case pitfalls. If you can't pay the price of a function wrapping, you should probably take the care to ensure manual function calls in every scope exit path rather than using a scope guard to begin with.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Conditional &lt;tt&gt;noexcept&lt;/tt&gt;</h2>
<p>Conditional <code>noexcept</code>'s are essential for correct exception specifications in modern C++ and could not be neglected by a construct that is particularly useful to achieve exception safety. Taking into account that they are a relatively recent feature that many programmers are not used to, <code>noexcept</code>'s make the code more verbose and arguably harder to read, especially when the condition uses type traits. But they could not be discarded by an interface that has strong non-throwing requirements on input. Hopefully, the way the code separates function declarations and definitions compensates on readability.</p>
<p>The exception specification of <code>make_scope_guard</code> is such that making a scope guard is often a <em>nothrow</em> operation. Notice in particular that <code>make_scope_guard</code> is <code>noexcept</code> in the following cases:</p>
<ol type="1">
<li>when <code>callback</code> is an lvalue or lvalue reference (<code>Callback</code> deduced to be a reference)</li>
<li>when <code>callback</code> is an rvalue or rvalue reference of a type with a <code>noexcept</code> move constructor (and a <code>noexcept</code> destructor, but that is already <a href="precond.md#nothrow-destructible-if-non-reference-template-argument">required</a> in such cases)</li>
</ol>
<p>You can look for <code>noexcept</code> in <a href="../compile_time_tests.cpp">compilation tests</a> for examples of <code>make_scope_guard</code> instantiations with and without <code>noexcept</code> guarantee.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
No extra arguments</h2>
<p>As the signature shows, <code>make_scope_guard</code> accepts no arguments beyond the callback (see the <a href="precond.md#invocable-with-no-arguments">related precondition</a>). This makes the interface (and implementation) simpler and pure and I could not see any other compelling case for them.</p>
<p>When lambdas and binds are available, the scope guard is better off keeping the <em>single responsibility</em> of guarding the scope, leaving the complementary responsibility of closure, with all intricacies it involves (think lambda captures), to those other types.</p>
<p>So, operations that require arguments can be used indirectly, with some form of closure. As with the decision to forbid returns, the potential performance impacts of an additional wrapping level are hardly significant and I don't think they are a decisive factor.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Private constructor</h2>
<p>The form of construction that is used by <code>make_scope_guard</code> to create scope guards is not part of the public interface. The purpose is to guide the user to type deduction with universal references and make unintentional misuse difficult. For instance, scope guards are not meant for dynamic allocation, or they would not be guarding any scope. Making the callback-taking constructor private does not make dynamic allocation impossible (because of the move constructor, which remains public), but it makes it harder.</p>
<p>The same is true with other misuses, namely when bypassing type deduction. If the callback-taking constructor was public, the user might be tempted to use it in place of the maker function. He would then have to manually specify a template instantiation that would be easy to get wrong. For example:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">scope_guard&lt;A&amp;&amp;&gt;{std::move(a)}; <span class="comment">/* oops, nothing is moved, may end up with</span></div>
<div class="line"><span class="comment">dangling ref (should be scope_guard&lt;A&gt;, which the compiler deduces when</span></div>
<div class="line"><span class="comment">using maker) */</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md7"></a>
Unspecified type</h2>
<p>I confess the decision not to specify the type of scope guards and keep it as an implementation detail is one I am less sure of. The intention is the same as with the private constructor: to make misuse hard. It discourages composition into other types and other cases where the notion of scope is unclear. And it is one less detail for the client to depend on. It is an approach I have seen on occasion, but the main inspiration comes from lambdas. I am open to strong arguments to the contrary.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
No default constructor or move assignment operator</h2>
<p>As they stand, inactive scope guards exist for only two purposes:</p>
<ul>
<li>to allow <a href="interface.md#member-function-dismiss">dismissal</a></li>
<li>to allow <a href="interface.md#member-move-constructor">moving</a></li>
</ul>
<p>Both intents are valid, and they justify supporting a special state that is otherwise artificial and purely a technical matter. But this state exists only because of the way C++ works. If those operations ended up with no scope guard at all, their purpose would be equally fulfilled.</p>
<p>In other words, the inactive state represents nothing useful from any problem domain. It would not be required in a hypothetical programming language where local variables could be deleted early and moved without leaving <em>ghosts</em> behind. So, we use the inactive state here only to enable valid programming approaches that would otherwise not be possible in C++. But then, should we take it one step further and use this state to provide another common C++ operation &ndash; default construction?</p>
<p>Without any meaningful default callback, a potential default constructor could only create inactive scope guards (or active no-op, which would be equivalent). If they represent nothing useful from the problem domain, the only reason to create them directly in such a state would be to provide placeholders to allow modification. That is, to artificially <em>defer initialization</em>, which would then have to be achieved with assignment, since no other meaningful scope guard modifier is supported.</p>
<p>But having constructed objects that are not initialized is a practice that goes against a very important principle! The one that corresponds to the literal meaning of a well-known overloaded expression &ndash; <em>Resourse Acquisition Is Initialization</em>. Constructors are meant to prevent uninitialized variables, not facilitate them.</p>
<p>Additionally, unlike in the case of the move constructor, I see no technical reason to provide the default constructor plus assignment operator combo. True, it could enable the following:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">{</div>
<div class="line">  Foo callback;</div>
<div class="line">  <span class="keyword">decltype</span>(make_scope_guard(std::move(callback))) g;</div>
<div class="line">  <span class="keywordflow">if</span>(condition)</div>
<div class="line">    g = make_scope_guard(std::move(callback));</div>
<div class="line">  <span class="comment">// g still alive</span></div>
<div class="line">} <span class="comment">// callback executed if condition held</span></div>
</div><!-- fragment --><p>But there are better alternatives to achieve the same thing without so many pitfalls. Namely, using <code>std::optional</code>:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">{</div>
<div class="line">  Foo callback;</div>
<div class="line">  std::optional&lt;<span class="keyword">decltype</span>(make_scope_guard(std::move(callback)))&gt; g;</div>
<div class="line">  <span class="keywordflow">if</span>(condition)</div>
<div class="line">    g.emplace(make_scope_guard(std::move(callback)));</div>
<div class="line">  <span class="comment">// g still alive</span></div>
<div class="line">} <span class="comment">// callback executed if condition held</span></div>
</div><!-- fragment --><p>Or moving the condition into the callback (if it does not change until then):</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">{</div>
<div class="line">  Foo callback;</div>
<div class="line">  <span class="keyword">auto</span> g =</div>
<div class="line">    make_scope_guard([&amp;callback](){ <span class="keywordflow">if</span>(condition) callback(); });</div>
<div class="line">} <span class="comment">// callback executed if condition holds (different moment)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md9"></a>
SFINAE friendliness</h2>
<p>The function <code>make_scope_guard</code> is <em>SFINAE-friendly</em>. In other words, when the compiler tries to deduce a template argument, an invalid application of <code>make_scope_guard</code> that is caused by a failure to substitute a candidate type (e.g. because the argument is not callable) does not cause a compilation error if any other substitution is still possible. You can look for "sfinae" in <a href="../catch_tests.cpp">catch tests</a> for examples.</p>
<p>Making the scope guard SFINAE-friendly is the decision I am less sure of. It <em>felt right</em>, but it makes error output unclear. I welcome justified opinions and improvement suggestions (on this topic as in others). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
