<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>micromouse: packages/AllegroDeps.1.13.0/build/native/include/theora/theora.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">micromouse
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('theora_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle"><div class="title">theora.h File Reference<div class="ingroups"><a class="el" href="group__oldfuncs.html">Legacy pre-1.0 C API</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>The libtheora pre-1.0 legacy C API.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;<a class="el" href="ogg_8h_source.html">ogg/ogg.h</a>&gt;</code><br />
</div>
<p><a href="theora_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyuv__buffer.html">yuv_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A YUV buffer for passing uncompressed frames to and from the codec.  <a href="structyuv__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtheora__info.html">theora_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Theora bitstream info.  <a href="structtheora__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtheora__state.html">theora_state</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Codec internal state and context.  <a href="structtheora__state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtheora__comment.html">theora_comment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comment header metadata.  <a href="structtheora__comment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:acaae73fc38efbc2ef0b0fb61dbbda3fc" id="r_acaae73fc38efbc2ef0b0fb61dbbda3fc"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structtheora__comment.html">theora_comment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#acaae73fc38efbc2ef0b0fb61dbbda3fc">theora_comment</a></td></tr>
<tr class="memdesc:acaae73fc38efbc2ef0b0fb61dbbda3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comment header metadata.  <br /></td></tr>
<tr class="separator:acaae73fc38efbc2ef0b0fb61dbbda3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa567da4ce591f7373149ce3ef3acdac9" id="r_aa567da4ce591f7373149ce3ef3acdac9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#aa567da4ce591f7373149ce3ef3acdac9">theora_colorspace</a> { <a class="el" href="theora_8h.html#aa567da4ce591f7373149ce3ef3acdac9abf217cf83d7d7cbf73295e6689f5cf5f">OC_CS_UNSPECIFIED</a>
, <a class="el" href="theora_8h.html#aa567da4ce591f7373149ce3ef3acdac9ab20c9851a21ab148fef0bf2c00c0a294">OC_CS_ITU_REC_470M</a>
, <a class="el" href="theora_8h.html#aa567da4ce591f7373149ce3ef3acdac9a04f8fa2da26f9ec513f514163705666a">OC_CS_ITU_REC_470BG</a>
, <a class="el" href="theora_8h.html#aa567da4ce591f7373149ce3ef3acdac9a640b572f11fa7102d434e1c605aaa186">OC_CS_NSPACES</a>
 }</td></tr>
<tr class="memdesc:aa567da4ce591f7373149ce3ef3acdac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Colorspace.  <a href="theora_8h.html#aa567da4ce591f7373149ce3ef3acdac9">More...</a><br /></td></tr>
<tr class="separator:aa567da4ce591f7373149ce3ef3acdac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae169da05bfaaf4e964a6866552d45079" id="r_ae169da05bfaaf4e964a6866552d45079"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#ae169da05bfaaf4e964a6866552d45079">theora_pixelformat</a> { <a class="el" href="theora_8h.html#ae169da05bfaaf4e964a6866552d45079a4e451af01be2645511b0e431f5225d2b">OC_PF_420</a>
, <a class="el" href="theora_8h.html#ae169da05bfaaf4e964a6866552d45079a7d21c63341ad299766839c83ed1216eb">OC_PF_RSVD</a>
, <a class="el" href="theora_8h.html#ae169da05bfaaf4e964a6866552d45079a36a88c55b7ddd5aedeac2d61d57fee5b">OC_PF_422</a>
, <a class="el" href="theora_8h.html#ae169da05bfaaf4e964a6866552d45079a1d5c6d1b0365e06b4a87880b7825f044">OC_PF_444</a>
 }</td></tr>
<tr class="memdesc:ae169da05bfaaf4e964a6866552d45079"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Chroma subsampling.  <a href="theora_8h.html#ae169da05bfaaf4e964a6866552d45079">More...</a><br /></td></tr>
<tr class="separator:ae169da05bfaaf4e964a6866552d45079"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">theora_control() codes</h2></td></tr>
<tr class="memitem:ab31f251c9319f2140d247585d30b3d07" id="r_ab31f251c9319f2140d247585d30b3d07"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#ab31f251c9319f2140d247585d30b3d07">TH_DECCTL_GET_PPLEVEL_MAX</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ab31f251c9319f2140d247585d30b3d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum post-processing level.  <br /></td></tr>
<tr class="separator:ab31f251c9319f2140d247585d30b3d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87774c35e1a755a84e2d705b38ebef0d" id="r_a87774c35e1a755a84e2d705b38ebef0d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a87774c35e1a755a84e2d705b38ebef0d">TH_DECCTL_SET_PPLEVEL</a>&#160;&#160;&#160;(3)</td></tr>
<tr class="memdesc:a87774c35e1a755a84e2d705b38ebef0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the post-processing level.  <br /></td></tr>
<tr class="separator:a87774c35e1a755a84e2d705b38ebef0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e755e15b4b5604c54974b304037a49" id="r_a27e755e15b4b5604c54974b304037a49"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a27e755e15b4b5604c54974b304037a49">TH_ENCCTL_SET_KEYFRAME_FREQUENCY_FORCE</a>&#160;&#160;&#160;(4)</td></tr>
<tr class="memdesc:a27e755e15b4b5604c54974b304037a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum distance between key frames.  <br /></td></tr>
<tr class="separator:a27e755e15b4b5604c54974b304037a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e870c654d35394f0d490045df04e0f5" id="r_a1e870c654d35394f0d490045df04e0f5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a1e870c654d35394f0d490045df04e0f5">TH_DECCTL_SET_GRANPOS</a>&#160;&#160;&#160;(5)</td></tr>
<tr class="memdesc:a1e870c654d35394f0d490045df04e0f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the granule position.  <br /></td></tr>
<tr class="separator:a1e870c654d35394f0d490045df04e0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3befcdd66678f8d27034f9c4b16d1b9c" id="r_a3befcdd66678f8d27034f9c4b16d1b9c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a3befcdd66678f8d27034f9c4b16d1b9c">TH_ENCCTL_SET_QUANT_PARAMS</a>&#160;&#160;&#160;(2)</td></tr>
<tr class="memdesc:a3befcdd66678f8d27034f9c4b16d1b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="encctlcodes_old"></a> <br /></td></tr>
<tr class="separator:a3befcdd66678f8d27034f9c4b16d1b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382d685a39a34d8e6ba76b00d804efd8" id="r_a382d685a39a34d8e6ba76b00d804efd8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a382d685a39a34d8e6ba76b00d804efd8">TH_ENCCTL_SET_VP3_COMPATIBLE</a>&#160;&#160;&#160;(10)</td></tr>
<tr class="memdesc:a382d685a39a34d8e6ba76b00d804efd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables any encoder features that would prevent lossless transcoding back to VP3.  <br /></td></tr>
<tr class="separator:a382d685a39a34d8e6ba76b00d804efd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9baf5bdd206e80c78a8fd44687e89783" id="r_a9baf5bdd206e80c78a8fd44687e89783"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a9baf5bdd206e80c78a8fd44687e89783">TH_ENCCTL_GET_SPLEVEL_MAX</a>&#160;&#160;&#160;(12)</td></tr>
<tr class="memdesc:a9baf5bdd206e80c78a8fd44687e89783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum speed level.  <br /></td></tr>
<tr class="separator:a9baf5bdd206e80c78a8fd44687e89783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9fbcb6a25a77d991d3620164fe59d6" id="r_abd9fbcb6a25a77d991d3620164fe59d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#abd9fbcb6a25a77d991d3620164fe59d6">TH_ENCCTL_SET_SPLEVEL</a>&#160;&#160;&#160;(14)</td></tr>
<tr class="memdesc:abd9fbcb6a25a77d991d3620164fe59d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the speed level.  <br /></td></tr>
<tr class="separator:abd9fbcb6a25a77d991d3620164fe59d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4370e13ed3aea6441ccf69dcab2506e" id="r_aa4370e13ed3aea6441ccf69dcab2506e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#aa4370e13ed3aea6441ccf69dcab2506e">OC_FAULT</a>&#160;&#160;&#160;-1</td></tr>
<tr class="memdesc:aa4370e13ed3aea6441ccf69dcab2506e"><td class="mdescLeft">&#160;</td><td class="mdescRight">General failure.  <br /></td></tr>
<tr class="separator:aa4370e13ed3aea6441ccf69dcab2506e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d15091b1a03a734a124e9a04d3be55" id="r_a43d15091b1a03a734a124e9a04d3be55"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a43d15091b1a03a734a124e9a04d3be55">OC_EINVAL</a>&#160;&#160;&#160;-10</td></tr>
<tr class="memdesc:a43d15091b1a03a734a124e9a04d3be55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Library encountered invalid internal data.  <br /></td></tr>
<tr class="separator:a43d15091b1a03a734a124e9a04d3be55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b9fa0af856d5930c534db26e2ac2d1" id="r_a38b9fa0af856d5930c534db26e2ac2d1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a38b9fa0af856d5930c534db26e2ac2d1">OC_DISABLED</a>&#160;&#160;&#160;-11</td></tr>
<tr class="memdesc:a38b9fa0af856d5930c534db26e2ac2d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requested action is disabled.  <br /></td></tr>
<tr class="separator:a38b9fa0af856d5930c534db26e2ac2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809cbad2eb36be17a235a3cadfb737ba" id="r_a809cbad2eb36be17a235a3cadfb737ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a809cbad2eb36be17a235a3cadfb737ba">OC_BADHEADER</a>&#160;&#160;&#160;-20</td></tr>
<tr class="memdesc:a809cbad2eb36be17a235a3cadfb737ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Header packet was corrupt/invalid.  <br /></td></tr>
<tr class="separator:a809cbad2eb36be17a235a3cadfb737ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9558d6d9eacd2273c8da27f945d725ad" id="r_a9558d6d9eacd2273c8da27f945d725ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a9558d6d9eacd2273c8da27f945d725ad">OC_NOTFORMAT</a>&#160;&#160;&#160;-21</td></tr>
<tr class="memdesc:a9558d6d9eacd2273c8da27f945d725ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packet is not a theora packet.  <br /></td></tr>
<tr class="separator:a9558d6d9eacd2273c8da27f945d725ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4611cfd61160405721d1e2ab0ec2564b" id="r_a4611cfd61160405721d1e2ab0ec2564b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a4611cfd61160405721d1e2ab0ec2564b">OC_VERSION</a>&#160;&#160;&#160;-22</td></tr>
<tr class="memdesc:a4611cfd61160405721d1e2ab0ec2564b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitstream version is not handled.  <br /></td></tr>
<tr class="separator:a4611cfd61160405721d1e2ab0ec2564b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895dc2597b3bf9c97bf7701c6eff5b0c" id="r_a895dc2597b3bf9c97bf7701c6eff5b0c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a895dc2597b3bf9c97bf7701c6eff5b0c">OC_IMPL</a>&#160;&#160;&#160;-23</td></tr>
<tr class="memdesc:a895dc2597b3bf9c97bf7701c6eff5b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Feature or action not implemented.  <br /></td></tr>
<tr class="separator:a895dc2597b3bf9c97bf7701c6eff5b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117774c062a63dfad2a5b4d092fa2bb1" id="r_a117774c062a63dfad2a5b4d092fa2bb1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a117774c062a63dfad2a5b4d092fa2bb1">OC_BADPACKET</a>&#160;&#160;&#160;-24</td></tr>
<tr class="memdesc:a117774c062a63dfad2a5b4d092fa2bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packet is corrupt.  <br /></td></tr>
<tr class="separator:a117774c062a63dfad2a5b4d092fa2bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60be4dc92c933eac3542bce3ce076496" id="r_a60be4dc92c933eac3542bce3ce076496"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a60be4dc92c933eac3542bce3ce076496">OC_NEWPACKET</a>&#160;&#160;&#160;-25</td></tr>
<tr class="memdesc:a60be4dc92c933eac3542bce3ce076496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packet is an (ignorable) unhandled extension.  <br /></td></tr>
<tr class="separator:a60be4dc92c933eac3542bce3ce076496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a8d2f5080ad62b415a4e7551941cbb" id="r_a84a8d2f5080ad62b415a4e7551941cbb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a84a8d2f5080ad62b415a4e7551941cbb">OC_DUPFRAME</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a84a8d2f5080ad62b415a4e7551941cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packet is a dropped frame.  <br /></td></tr>
<tr class="separator:a84a8d2f5080ad62b415a4e7551941cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52e77d5dab481f2181c8162549c0cb9" id="r_ac52e77d5dab481f2181c8162549c0cb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#ac52e77d5dab481f2181c8162549c0cb9">theora_version_string</a> (<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>)</td></tr>
<tr class="memdesc:ac52e77d5dab481f2181c8162549c0cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a human-readable string to identify the encoder vendor and version.  <br /></td></tr>
<tr class="separator:ac52e77d5dab481f2181c8162549c0cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad181f4b19d455dcc2bef2533530b84c8" id="r_ad181f4b19d455dcc2bef2533530b84c8"><td class="memItemLeft" align="right" valign="top">ogg_uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#ad181f4b19d455dcc2bef2533530b84c8">theora_version_number</a> (<a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>)</td></tr>
<tr class="memdesc:ad181f4b19d455dcc2bef2533530b84c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a 32-bit version number.  <br /></td></tr>
<tr class="separator:ad181f4b19d455dcc2bef2533530b84c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7ad4d4b2343278cb4ba8fb2bd5109a" id="r_a0f7ad4d4b2343278cb4ba8fb2bd5109a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a0f7ad4d4b2343278cb4ba8fb2bd5109a">theora_encode_init</a> (<a class="el" href="structtheora__state.html">theora_state</a> *th, <a class="el" href="structtheora__info.html">theora_info</a> *ti)</td></tr>
<tr class="memdesc:a0f7ad4d4b2343278cb4ba8fb2bd5109a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the theora encoder.  <br /></td></tr>
<tr class="separator:a0f7ad4d4b2343278cb4ba8fb2bd5109a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d33d896ca70cedfc94c5986d947078" id="r_ac0d33d896ca70cedfc94c5986d947078"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#ac0d33d896ca70cedfc94c5986d947078">theora_encode_YUVin</a> (<a class="el" href="structtheora__state.html">theora_state</a> *t, <a class="el" href="structyuv__buffer.html">yuv_buffer</a> *yuv)</td></tr>
<tr class="memdesc:ac0d33d896ca70cedfc94c5986d947078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a YUV buffer to the theora encoder.  <br /></td></tr>
<tr class="separator:ac0d33d896ca70cedfc94c5986d947078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4929677a735bc2198c2309d235f1b3" id="r_a5f4929677a735bc2198c2309d235f1b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a5f4929677a735bc2198c2309d235f1b3">theora_encode_packetout</a> (<a class="el" href="structtheora__state.html">theora_state</a> *t, int last_p, <a class="el" href="structogg__packet.html">ogg_packet</a> *op)</td></tr>
<tr class="memdesc:a5f4929677a735bc2198c2309d235f1b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the next packet of encoded video.  <br /></td></tr>
<tr class="separator:a5f4929677a735bc2198c2309d235f1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451feb58d6bde726edbae193689887be" id="r_a451feb58d6bde726edbae193689887be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a451feb58d6bde726edbae193689887be">theora_encode_header</a> (<a class="el" href="structtheora__state.html">theora_state</a> *t, <a class="el" href="structogg__packet.html">ogg_packet</a> *op)</td></tr>
<tr class="memdesc:a451feb58d6bde726edbae193689887be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a packet containing the initial header.  <br /></td></tr>
<tr class="separator:a451feb58d6bde726edbae193689887be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e8db0713eaaca0f1144f3724cb834a" id="r_a45e8db0713eaaca0f1144f3724cb834a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a45e8db0713eaaca0f1144f3724cb834a">theora_encode_comment</a> (<a class="el" href="structtheora__comment.html">theora_comment</a> *tc, <a class="el" href="structogg__packet.html">ogg_packet</a> *op)</td></tr>
<tr class="memdesc:a45e8db0713eaaca0f1144f3724cb834a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a comment header packet from provided metadata.  <br /></td></tr>
<tr class="separator:a45e8db0713eaaca0f1144f3724cb834a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5085baf20855b283fa01fc948505d9d2" id="r_a5085baf20855b283fa01fc948505d9d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a5085baf20855b283fa01fc948505d9d2">theora_encode_tables</a> (<a class="el" href="structtheora__state.html">theora_state</a> *t, <a class="el" href="structogg__packet.html">ogg_packet</a> *op)</td></tr>
<tr class="memdesc:a5085baf20855b283fa01fc948505d9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a packet containing the codebook tables for the stream.  <br /></td></tr>
<tr class="separator:a5085baf20855b283fa01fc948505d9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02915e63c1bd733ee291f577a8b75a82" id="r_a02915e63c1bd733ee291f577a8b75a82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a02915e63c1bd733ee291f577a8b75a82">theora_decode_header</a> (<a class="el" href="structtheora__info.html">theora_info</a> *ci, <a class="el" href="structtheora__comment.html">theora_comment</a> *cc, <a class="el" href="structogg__packet.html">ogg_packet</a> *op)</td></tr>
<tr class="memdesc:a02915e63c1bd733ee291f577a8b75a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode an Ogg packet, with the expectation that the packet contains an initial header, comment data or codebook tables.  <br /></td></tr>
<tr class="separator:a02915e63c1bd733ee291f577a8b75a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264907c66003799ff77ecbd09eb33d2c" id="r_a264907c66003799ff77ecbd09eb33d2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a264907c66003799ff77ecbd09eb33d2c">theora_decode_init</a> (<a class="el" href="structtheora__state.html">theora_state</a> *th, <a class="el" href="structtheora__info.html">theora_info</a> *c)</td></tr>
<tr class="memdesc:a264907c66003799ff77ecbd09eb33d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="structtheora__state.html" title="Codec internal state and context.">theora_state</a> handle for decoding.  <br /></td></tr>
<tr class="separator:a264907c66003799ff77ecbd09eb33d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65a9e53b46fd54ab344bd599fa96975" id="r_aa65a9e53b46fd54ab344bd599fa96975"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#aa65a9e53b46fd54ab344bd599fa96975">theora_decode_packetin</a> (<a class="el" href="structtheora__state.html">theora_state</a> *th, <a class="el" href="structogg__packet.html">ogg_packet</a> *op)</td></tr>
<tr class="memdesc:aa65a9e53b46fd54ab344bd599fa96975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input a packet containing encoded data into the theora decoder.  <br /></td></tr>
<tr class="separator:aa65a9e53b46fd54ab344bd599fa96975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d47c80e1e94bff0a46a496816b8daa" id="r_a09d47c80e1e94bff0a46a496816b8daa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a09d47c80e1e94bff0a46a496816b8daa">theora_decode_YUVout</a> (<a class="el" href="structtheora__state.html">theora_state</a> *th, <a class="el" href="structyuv__buffer.html">yuv_buffer</a> *yuv)</td></tr>
<tr class="memdesc:a09d47c80e1e94bff0a46a496816b8daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the next available frame of decoded YUV data.  <br /></td></tr>
<tr class="separator:a09d47c80e1e94bff0a46a496816b8daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab969f9d0407683f0e5abe73d0839a25b" id="r_ab969f9d0407683f0e5abe73d0839a25b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#ab969f9d0407683f0e5abe73d0839a25b">theora_packet_isheader</a> (<a class="el" href="structogg__packet.html">ogg_packet</a> *op)</td></tr>
<tr class="memdesc:ab969f9d0407683f0e5abe73d0839a25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report whether a theora packet is a header or not This function does no verification beyond checking the header flag bit so it should not be used for bitstream identification; use <a class="el" href="theora_8h.html#a02915e63c1bd733ee291f577a8b75a82" title="Decode an Ogg packet, with the expectation that the packet contains an initial header,...">theora_decode_header()</a> for that.  <br /></td></tr>
<tr class="separator:ab969f9d0407683f0e5abe73d0839a25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ccc8f847a748d7074c926b4fdd12b2" id="r_a39ccc8f847a748d7074c926b4fdd12b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a39ccc8f847a748d7074c926b4fdd12b2">theora_packet_iskeyframe</a> (<a class="el" href="structogg__packet.html">ogg_packet</a> *op)</td></tr>
<tr class="memdesc:a39ccc8f847a748d7074c926b4fdd12b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report whether a theora packet is a keyframe or not.  <br /></td></tr>
<tr class="separator:a39ccc8f847a748d7074c926b4fdd12b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9360e6a47139c761002410af457a02" id="r_acd9360e6a47139c761002410af457a02"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#acd9360e6a47139c761002410af457a02">theora_granule_shift</a> (<a class="el" href="structtheora__info.html">theora_info</a> *ti)</td></tr>
<tr class="memdesc:acd9360e6a47139c761002410af457a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the granulepos shift radix.  <br /></td></tr>
<tr class="separator:acd9360e6a47139c761002410af457a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfa3ceb2fb4b41a282456c56e1dd269" id="r_a7bfa3ceb2fb4b41a282456c56e1dd269"><td class="memItemLeft" align="right" valign="top">ogg_int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a7bfa3ceb2fb4b41a282456c56e1dd269">theora_granule_frame</a> (<a class="el" href="structtheora__state.html">theora_state</a> *th, ogg_int64_t granulepos)</td></tr>
<tr class="memdesc:a7bfa3ceb2fb4b41a282456c56e1dd269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a granulepos to an absolute frame index, starting at 0.  <br /></td></tr>
<tr class="separator:a7bfa3ceb2fb4b41a282456c56e1dd269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4376358b12b9fa23ce6fe21cb5c65ac6" id="r_a4376358b12b9fa23ce6fe21cb5c65ac6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a4376358b12b9fa23ce6fe21cb5c65ac6">theora_granule_time</a> (<a class="el" href="structtheora__state.html">theora_state</a> *th, ogg_int64_t granulepos)</td></tr>
<tr class="memdesc:a4376358b12b9fa23ce6fe21cb5c65ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a granulepos to absolute time in seconds.  <br /></td></tr>
<tr class="separator:a4376358b12b9fa23ce6fe21cb5c65ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3091c87d48f1faba018c5956379a6d90" id="r_a3091c87d48f1faba018c5956379a6d90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a3091c87d48f1faba018c5956379a6d90">theora_info_init</a> (<a class="el" href="structtheora__info.html">theora_info</a> *c)</td></tr>
<tr class="memdesc:a3091c87d48f1faba018c5956379a6d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="structtheora__info.html" title="Theora bitstream info.">theora_info</a> structure.  <br /></td></tr>
<tr class="separator:a3091c87d48f1faba018c5956379a6d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7022d58edbc4825cacad03f68b3e0d" id="r_aba7022d58edbc4825cacad03f68b3e0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#aba7022d58edbc4825cacad03f68b3e0d">theora_info_clear</a> (<a class="el" href="structtheora__info.html">theora_info</a> *c)</td></tr>
<tr class="memdesc:aba7022d58edbc4825cacad03f68b3e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a <a class="el" href="structtheora__info.html" title="Theora bitstream info.">theora_info</a> structure.  <br /></td></tr>
<tr class="separator:aba7022d58edbc4825cacad03f68b3e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab252d5d81b925136dda72e8f1c09c5eb" id="r_ab252d5d81b925136dda72e8f1c09c5eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#ab252d5d81b925136dda72e8f1c09c5eb">theora_clear</a> (<a class="el" href="structtheora__state.html">theora_state</a> *t)</td></tr>
<tr class="memdesc:ab252d5d81b925136dda72e8f1c09c5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all internal data associated with a <a class="el" href="structtheora__state.html" title="Codec internal state and context.">theora_state</a> handle.  <br /></td></tr>
<tr class="separator:ab252d5d81b925136dda72e8f1c09c5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811b92785df3bdbbebb3de612d9d6ce0" id="r_a811b92785df3bdbbebb3de612d9d6ce0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a811b92785df3bdbbebb3de612d9d6ce0">theora_comment_init</a> (<a class="el" href="structtheora__comment.html">theora_comment</a> *tc)</td></tr>
<tr class="memdesc:a811b92785df3bdbbebb3de612d9d6ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an allocated <a class="el" href="structtheora__comment.html" title="Comment header metadata.">theora_comment</a> structure.  <br /></td></tr>
<tr class="separator:a811b92785df3bdbbebb3de612d9d6ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650642ed23894e41109bbc42ec393ed4" id="r_a650642ed23894e41109bbc42ec393ed4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a650642ed23894e41109bbc42ec393ed4">theora_comment_add</a> (<a class="el" href="structtheora__comment.html">theora_comment</a> *tc, char *comment)</td></tr>
<tr class="memdesc:a650642ed23894e41109bbc42ec393ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a comment to an initialized <a class="el" href="structtheora__comment.html" title="Comment header metadata.">theora_comment</a> structure.  <br /></td></tr>
<tr class="separator:a650642ed23894e41109bbc42ec393ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339bd80b5bf4bb168b7052d8ec0b5a92" id="r_a339bd80b5bf4bb168b7052d8ec0b5a92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a339bd80b5bf4bb168b7052d8ec0b5a92">theora_comment_add_tag</a> (<a class="el" href="structtheora__comment.html">theora_comment</a> *tc, char *tag, char *value)</td></tr>
<tr class="memdesc:a339bd80b5bf4bb168b7052d8ec0b5a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a comment to an initialized <a class="el" href="structtheora__comment.html" title="Comment header metadata.">theora_comment</a> structure.  <br /></td></tr>
<tr class="separator:a339bd80b5bf4bb168b7052d8ec0b5a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e0e9ad7e6d3b76129f9660bcad5ebd" id="r_ac9e0e9ad7e6d3b76129f9660bcad5ebd"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#ac9e0e9ad7e6d3b76129f9660bcad5ebd">theora_comment_query</a> (<a class="el" href="structtheora__comment.html">theora_comment</a> *tc, char *tag, int count)</td></tr>
<tr class="memdesc:ac9e0e9ad7e6d3b76129f9660bcad5ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up a comment value by tag.  <br /></td></tr>
<tr class="separator:ac9e0e9ad7e6d3b76129f9660bcad5ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f66a3c752442a3e0c0098e0f88df8b" id="r_a10f66a3c752442a3e0c0098e0f88df8b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a10f66a3c752442a3e0c0098e0f88df8b">theora_comment_query_count</a> (<a class="el" href="structtheora__comment.html">theora_comment</a> *tc, char *tag)</td></tr>
<tr class="memdesc:a10f66a3c752442a3e0c0098e0f88df8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the number of instances of a tag.  <br /></td></tr>
<tr class="separator:a10f66a3c752442a3e0c0098e0f88df8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c07c2eefba3a433e43f9fbde14719f" id="r_a04c07c2eefba3a433e43f9fbde14719f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a04c07c2eefba3a433e43f9fbde14719f">theora_comment_clear</a> (<a class="el" href="structtheora__comment.html">theora_comment</a> *tc)</td></tr>
<tr class="memdesc:a04c07c2eefba3a433e43f9fbde14719f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear an allocated <a class="el" href="structtheora__comment.html" title="Comment header metadata.">theora_comment</a> struct so that it can be freed.  <br /></td></tr>
<tr class="separator:a04c07c2eefba3a433e43f9fbde14719f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186773db3bc8cd550047e7df1b2ba2c9" id="r_a186773db3bc8cd550047e7df1b2ba2c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a186773db3bc8cd550047e7df1b2ba2c9">theora_control</a> (<a class="el" href="structtheora__state.html">theora_state</a> *th, int req, <a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *buf, size_t buf_sz)</td></tr>
<tr class="memdesc:a186773db3bc8cd550047e7df1b2ba2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encoder control function.  <br /></td></tr>
<tr class="separator:a186773db3bc8cd550047e7df1b2ba2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The libtheora pre-1.0 legacy C API. </p>
<h1><a class="anchor" id="intro"></a>
Introduction</h1>
<p>This is the documentation for the libtheora legacy C API, declared in the <a class="el" href="theora_8h.html" title="The libtheora pre-1.0 legacy C API.">theora.h</a> header, which describes the old interface used before the 1.0 release. This API was widely deployed for several years and remains supported, but for new code we recommend the cleaner API declared in <a class="el" href="theoradec_8h.html" title="The libtheoradec C decoding API.">theoradec.h</a> and theoraenc.h.</p>
<p>libtheora is the reference implementation for <a href="http://www.theora.org/">Theora</a>, a free video codec. Theora is derived from On2's VP3 codec with improved integration with Ogg multimedia formats by <a href="http://www.xiph.org/">Xiph.Org</a>.</p>
<h1><a class="anchor" id="overview"></a>
Overview</h1>
<p>This library will both decode and encode theora packets to/from raw YUV frames. In either case, the packets will most likely either come from or need to be embedded in an Ogg stream. Use <a href="http://xiph.org/ogg/">libogg</a> or <a href="http://www.annodex.net/software/liboggz/index.html">liboggz</a> to extract/package these packets.</p>
<h1><a class="anchor" id="decoding"></a>
Decoding Process</h1>
<p>Decoding can be separated into the following steps:</p><ol type="1">
<li>initialise <a class="el" href="structtheora__info.html" title="Theora bitstream info.">theora_info</a> and <a class="el" href="structtheora__comment.html" title="Comment header metadata.">theora_comment</a> structures using <a class="el" href="theora_8h.html#a3091c87d48f1faba018c5956379a6d90" title="Initialize a theora_info structure.">theora_info_init()</a> and <a class="el" href="theora_8h.html#a811b92785df3bdbbebb3de612d9d6ce0" title="Initialize an allocated theora_comment structure.">theora_comment_init()</a>: <pre class="fragment">theora_info     info;
theora_comment  comment;
  
theora_info_init(&amp;info);
theora_comment_init(&amp;comment);
</pre></li>
<li>retrieve header packets from Ogg stream (there should be 3) and decode into <a class="el" href="structtheora__info.html" title="Theora bitstream info.">theora_info</a> and <a class="el" href="structtheora__comment.html" title="Comment header metadata.">theora_comment</a> structures using <a class="el" href="theora_8h.html#a02915e63c1bd733ee291f577a8b75a82" title="Decode an Ogg packet, with the expectation that the packet contains an initial header,...">theora_decode_header()</a>. See <a class="el" href="theora_8h.html#identification">Identifying Theora Packets</a> for more information on identifying which packets are theora packets. <pre class="fragment">int i;
for (i = 0; i &lt; 3; i++)
{
  (get a theora packet "op" from the Ogg stream)
  theora_decode_header(&amp;info, &amp;comment, op);
}
</pre></li>
<li>initialise the decoder based on the information retrieved into the <a class="el" href="structtheora__info.html" title="Theora bitstream info.">theora_info</a> struct by <a class="el" href="theora_8h.html#a02915e63c1bd733ee291f577a8b75a82" title="Decode an Ogg packet, with the expectation that the packet contains an initial header,...">theora_decode_header()</a>. You will need a <a class="el" href="structtheora__state.html" title="Codec internal state and context.">theora_state</a> struct. <pre class="fragment">theora_state state;

theora_decode_init(&amp;state, &amp;info);
</pre></li>
<li>pass in packets and retrieve decoded frames! See the <a class="el" href="structyuv__buffer.html" title="A YUV buffer for passing uncompressed frames to and from the codec.">yuv_buffer</a> documentation for information on how to retrieve raw YUV data. <pre class="fragment">yuf_buffer buffer;
while (last packet was not e_o_s) {
  (get a theora packet "op" from the Ogg stream)
  theora_decode_packetin(&amp;state, op);
  theora_decode_YUVout(&amp;state, &amp;buffer);
}
</pre></li>
</ol>
<h2><a class="anchor" id="identification"></a>
Identifying Theora Packets</h2>
<p>All streams inside an Ogg file have a unique serial_no attached to the stream. Typically, you will want to</p><ul>
<li>retrieve the serial_no for each b_o_s (beginning of stream) page encountered within the Ogg file;</li>
<li>test the first (only) packet on that page to determine if it is a theora packet;</li>
<li>once you have found a theora b_o_s page then use the retrieved serial_no to identify future packets belonging to the same theora stream.</li>
</ul>
<p>Note that you <em>cannot</em> use <a class="el" href="theora_8h.html#ab969f9d0407683f0e5abe73d0839a25b" title="Report whether a theora packet is a header or not This function does no verification beyond checking ...">theora_packet_isheader()</a> to determine if a packet is a theora packet or not, as this function does not perform any checking beyond whether a header bit is present. Instead, use the <a class="el" href="theora_8h.html#a02915e63c1bd733ee291f577a8b75a82" title="Decode an Ogg packet, with the expectation that the packet contains an initial header,...">theora_decode_header()</a> function and check the return value; or examine the header bytes at the beginning of the Ogg page. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a809cbad2eb36be17a235a3cadfb737ba" name="a809cbad2eb36be17a235a3cadfb737ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a809cbad2eb36be17a235a3cadfb737ba">&#9670;&#160;</a></span>OC_BADHEADER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OC_BADHEADER&#160;&#160;&#160;-20</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Header packet was corrupt/invalid. </p>

</div>
</div>
<a id="a117774c062a63dfad2a5b4d092fa2bb1" name="a117774c062a63dfad2a5b4d092fa2bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a117774c062a63dfad2a5b4d092fa2bb1">&#9670;&#160;</a></span>OC_BADPACKET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OC_BADPACKET&#160;&#160;&#160;-24</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packet is corrupt. </p>

</div>
</div>
<a id="a38b9fa0af856d5930c534db26e2ac2d1" name="a38b9fa0af856d5930c534db26e2ac2d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b9fa0af856d5930c534db26e2ac2d1">&#9670;&#160;</a></span>OC_DISABLED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OC_DISABLED&#160;&#160;&#160;-11</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requested action is disabled. </p>

</div>
</div>
<a id="a84a8d2f5080ad62b415a4e7551941cbb" name="a84a8d2f5080ad62b415a4e7551941cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a8d2f5080ad62b415a4e7551941cbb">&#9670;&#160;</a></span>OC_DUPFRAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OC_DUPFRAME&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packet is a dropped frame. </p>

</div>
</div>
<a id="a43d15091b1a03a734a124e9a04d3be55" name="a43d15091b1a03a734a124e9a04d3be55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d15091b1a03a734a124e9a04d3be55">&#9670;&#160;</a></span>OC_EINVAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OC_EINVAL&#160;&#160;&#160;-10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Library encountered invalid internal data. </p>

</div>
</div>
<a id="aa4370e13ed3aea6441ccf69dcab2506e" name="aa4370e13ed3aea6441ccf69dcab2506e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4370e13ed3aea6441ccf69dcab2506e">&#9670;&#160;</a></span>OC_FAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OC_FAULT&#160;&#160;&#160;-1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General failure. </p>

</div>
</div>
<a id="a895dc2597b3bf9c97bf7701c6eff5b0c" name="a895dc2597b3bf9c97bf7701c6eff5b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a895dc2597b3bf9c97bf7701c6eff5b0c">&#9670;&#160;</a></span>OC_IMPL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OC_IMPL&#160;&#160;&#160;-23</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Feature or action not implemented. </p>

</div>
</div>
<a id="a60be4dc92c933eac3542bce3ce076496" name="a60be4dc92c933eac3542bce3ce076496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60be4dc92c933eac3542bce3ce076496">&#9670;&#160;</a></span>OC_NEWPACKET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OC_NEWPACKET&#160;&#160;&#160;-25</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packet is an (ignorable) unhandled extension. </p>

</div>
</div>
<a id="a9558d6d9eacd2273c8da27f945d725ad" name="a9558d6d9eacd2273c8da27f945d725ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9558d6d9eacd2273c8da27f945d725ad">&#9670;&#160;</a></span>OC_NOTFORMAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OC_NOTFORMAT&#160;&#160;&#160;-21</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packet is not a theora packet. </p>

</div>
</div>
<a id="a4611cfd61160405721d1e2ab0ec2564b" name="a4611cfd61160405721d1e2ab0ec2564b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4611cfd61160405721d1e2ab0ec2564b">&#9670;&#160;</a></span>OC_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OC_VERSION&#160;&#160;&#160;-22</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitstream version is not handled. </p>

</div>
</div>
<a id="ab31f251c9319f2140d247585d30b3d07" name="ab31f251c9319f2140d247585d30b3d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab31f251c9319f2140d247585d30b3d07">&#9670;&#160;</a></span>TH_DECCTL_GET_PPLEVEL_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TH_DECCTL_GET_PPLEVEL_MAX&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum post-processing level. </p>
<p>The decoder supports a post-processing filter that can improve the appearance of the decoded images. This returns the highest level setting for this post-processor, corresponding to maximum improvement and computational expense. </p>

</div>
</div>
<a id="a1e870c654d35394f0d490045df04e0f5" name="a1e870c654d35394f0d490045df04e0f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e870c654d35394f0d490045df04e0f5">&#9670;&#160;</a></span>TH_DECCTL_SET_GRANPOS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TH_DECCTL_SET_GRANPOS&#160;&#160;&#160;(5)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the granule position. </p>
<p>Call this after a seek, to update the internal granulepos in the decoder, to insure that subsequent frames are marked properly. If you track timestamps yourself and do not use the granule postion returned by the decoder, then you do not need to use this control. </p>

</div>
</div>
<a id="a87774c35e1a755a84e2d705b38ebef0d" name="a87774c35e1a755a84e2d705b38ebef0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87774c35e1a755a84e2d705b38ebef0d">&#9670;&#160;</a></span>TH_DECCTL_SET_PPLEVEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TH_DECCTL_SET_PPLEVEL&#160;&#160;&#160;(3)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the post-processing level. </p>
<p>Sets the level of post-processing to use when decoding the compressed stream. This must be a value between zero (off) and the maximum returned by TH_DECCTL_GET_PPLEVEL_MAX. </p>

</div>
</div>
<a id="a9baf5bdd206e80c78a8fd44687e89783" name="a9baf5bdd206e80c78a8fd44687e89783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9baf5bdd206e80c78a8fd44687e89783">&#9670;&#160;</a></span>TH_ENCCTL_GET_SPLEVEL_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TH_ENCCTL_GET_SPLEVEL_MAX&#160;&#160;&#160;(12)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the maximum speed level. </p>
<p>Higher speed levels favor quicker encoding over better quality per bit. Depending on the encoding mode, and the internal algorithms used, quality may actually improve, but in this case bitrate will also likely increase. In any case, overall rate/distortion performance will probably decrease. The maximum value, and the meaning of each value, may change depending on the current encoding mode (VBR vs. CQI, etc.).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>int: The maximum encoding speed level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">OC_FAULT</td><td><em><a class="el" href="structtheora__state.html" title="Codec internal state and context.">theora_state</a></em> or <em>buf</em> is <code>NULL</code>. </td></tr>
    <tr><td class="paramname">OC_EINVAL</td><td><em>buf_sz</em> is not <code>sizeof(int)</code>. </td></tr>
    <tr><td class="paramname">OC_IMPL</td><td>Not supported by this implementation in the current encoding mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27e755e15b4b5604c54974b304037a49" name="a27e755e15b4b5604c54974b304037a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e755e15b4b5604c54974b304037a49">&#9670;&#160;</a></span>TH_ENCCTL_SET_KEYFRAME_FREQUENCY_FORCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TH_ENCCTL_SET_KEYFRAME_FREQUENCY_FORCE&#160;&#160;&#160;(4)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum distance between key frames. </p>
<p>This can be changed during an encode, but will be bounded by <code>1&lt;&lt;<a class="el" href="structth__info.html#a693ca4ab11fbc0c3f32594b4bb8766ed" title="The amount to shift to extract the last keyframe number from the granule position.">th_info::keyframe_granule_shift</a></code>. If it is set before encoding begins, <a class="el" href="structth__info.html#a693ca4ab11fbc0c3f32594b4bb8766ed" title="The amount to shift to extract the last keyframe number from the granule position.">th_info::keyframe_granule_shift</a> will be enlarged appropriately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td><code>ogg_uint32_t</code>: The maximum distance between key frames. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td><code>ogg_uint32_t</code>: The actual maximum distance set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">OC_FAULT</td><td><em><a class="el" href="structtheora__state.html" title="Codec internal state and context.">theora_state</a></em> or <em>buf</em> is <code>NULL</code>. </td></tr>
    <tr><td class="paramname">OC_EINVAL</td><td><em>buf_sz</em> is not <code>sizeof(ogg_uint32_t)</code>. </td></tr>
    <tr><td class="paramname">OC_IMPL</td><td>Not supported by this implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3befcdd66678f8d27034f9c4b16d1b9c" name="a3befcdd66678f8d27034f9c4b16d1b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3befcdd66678f8d27034f9c4b16d1b9c">&#9670;&#160;</a></span>TH_ENCCTL_SET_QUANT_PARAMS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TH_ENCCTL_SET_QUANT_PARAMS&#160;&#160;&#160;(2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="encctlcodes_old"></a></p>
<p>Sets the quantization parameters to use. The parameters are copied, not stored by reference, so they can be freed after this call. <code>NULL</code> may be specified to revert to the default parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td><a class="el" href="structth__quant__info.html" title="A complete set of quantization parameters.">th_quant_info</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">OC_FAULT</td><td><em><a class="el" href="structtheora__state.html" title="Codec internal state and context.">theora_state</a></em> is <code>NULL</code>. </td></tr>
    <tr><td class="paramname">OC_EINVAL</td><td>Encoding has already begun, the quantization parameters are not acceptable to this version of the encoder, <em>buf</em> is <code>NULL</code> and <em>buf_sz</em> is not zero, or <em>buf</em> is non-<code>NULL</code> and <em>buf_sz</em> is not <code>sizeof(<a class="el" href="structth__quant__info.html" title="A complete set of quantization parameters.">th_quant_info</a>)</code>. </td></tr>
    <tr><td class="paramname">OC_IMPL</td><td>Not supported by this implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd9fbcb6a25a77d991d3620164fe59d6" name="abd9fbcb6a25a77d991d3620164fe59d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd9fbcb6a25a77d991d3620164fe59d6">&#9670;&#160;</a></span>TH_ENCCTL_SET_SPLEVEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TH_ENCCTL_SET_SPLEVEL&#160;&#160;&#160;(14)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the speed level. </p>
<p>By default a speed value of 1 is used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>int: The new encoding speed level. 0 is slowest, larger values use less CPU. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">OC_FAULT</td><td><em><a class="el" href="structtheora__state.html" title="Codec internal state and context.">theora_state</a></em> or <em>buf</em> is <code>NULL</code>. </td></tr>
    <tr><td class="paramname">OC_EINVAL</td><td><em>buf_sz</em> is not <code>sizeof(int)</code>, or the encoding speed level is out of bounds. The maximum encoding speed level may be implementation- and encoding mode-specific, and can be obtained via <a class="el" href="theora_8h.html#a9baf5bdd206e80c78a8fd44687e89783" title="Gets the maximum speed level.">TH_ENCCTL_GET_SPLEVEL_MAX</a>. </td></tr>
    <tr><td class="paramname">OC_IMPL</td><td>Not supported by this implementation in the current encoding mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a382d685a39a34d8e6ba76b00d804efd8" name="a382d685a39a34d8e6ba76b00d804efd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382d685a39a34d8e6ba76b00d804efd8">&#9670;&#160;</a></span>TH_ENCCTL_SET_VP3_COMPATIBLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TH_ENCCTL_SET_VP3_COMPATIBLE&#160;&#160;&#160;(10)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables any encoder features that would prevent lossless transcoding back to VP3. </p>
<p>This primarily means disabling block-level QI values and not using 4MV mode when any of the luma blocks in a macro block are not coded. It also includes using the VP3 quantization tables and Huffman codes; if you set them explicitly after calling this function, the resulting stream will not be VP3-compatible. If you enable VP3-compatibility when encoding 4:2:2 or 4:4:4 source material, or when using a picture region smaller than the full frame (e.g. a non-multiple-of-16 width or height), then non-VP3 bitstream features will still be disabled, but the stream will still not be VP3-compatible, as VP3 was not capable of encoding such formats. If you call this after encoding has already begun, then the quantization tables and codebooks cannot be changed, but the frame-level features will be enabled or disabled as requested.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td><code>int</code>: a non-zero value to enable VP3 compatibility, or 0 to disable it (the default). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td><code>int</code>: 1 if all bitstream features required for VP3-compatibility could be set, and 0 otherwise. The latter will be returned if the pixel format is not 4:2:0, the picture region is smaller than the full frame, or if encoding has begun, preventing the quantization tables and codebooks from being set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">OC_FAULT</td><td><em><a class="el" href="structtheora__state.html" title="Codec internal state and context.">theora_state</a></em> or <em>buf</em> is <code>NULL</code>. </td></tr>
    <tr><td class="paramname">OC_EINVAL</td><td><em>buf_sz</em> is not <code>sizeof(int)</code>. </td></tr>
    <tr><td class="paramname">OC_IMPL</td><td>Not supported by this implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="acaae73fc38efbc2ef0b0fb61dbbda3fc" name="acaae73fc38efbc2ef0b0fb61dbbda3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaae73fc38efbc2ef0b0fb61dbbda3fc">&#9670;&#160;</a></span>theora_comment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structtheora__comment.html">theora_comment</a> <a class="el" href="structtheora__comment.html">theora_comment</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comment header metadata. </p>
<p>This structure holds the in-stream metadata corresponding to the 'comment' header packet.</p>
<p>Meta data is stored as a series of (tag, value) pairs, in length-encoded string vectors. The first occurence of the '=' character delimits the tag and value. A particular tag may occur more than once. The character set encoding for the strings is always UTF-8, but the tag names are limited to case-insensitive ASCII. See the spec for details.</p>
<p>In filling in this structure, <a class="el" href="theora_8h.html#a02915e63c1bd733ee291f577a8b75a82" title="Decode an Ogg packet, with the expectation that the packet contains an initial header,...">theora_decode_header()</a> will null-terminate the user_comment strings for safety. However, the bitstream format itself treats them as 8-bit clean, and so the length array should be treated as authoritative for their length. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa567da4ce591f7373149ce3ef3acdac9" name="aa567da4ce591f7373149ce3ef3acdac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa567da4ce591f7373149ce3ef3acdac9">&#9670;&#160;</a></span>theora_colorspace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="theora_8h.html#aa567da4ce591f7373149ce3ef3acdac9">theora_colorspace</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A Colorspace. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa567da4ce591f7373149ce3ef3acdac9abf217cf83d7d7cbf73295e6689f5cf5f" name="aa567da4ce591f7373149ce3ef3acdac9abf217cf83d7d7cbf73295e6689f5cf5f"></a>OC_CS_UNSPECIFIED&#160;</td><td class="fielddoc"><p>The colorspace is unknown or unspecified. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa567da4ce591f7373149ce3ef3acdac9ab20c9851a21ab148fef0bf2c00c0a294" name="aa567da4ce591f7373149ce3ef3acdac9ab20c9851a21ab148fef0bf2c00c0a294"></a>OC_CS_ITU_REC_470M&#160;</td><td class="fielddoc"><p>This is the best option for 'NTSC' content. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa567da4ce591f7373149ce3ef3acdac9a04f8fa2da26f9ec513f514163705666a" name="aa567da4ce591f7373149ce3ef3acdac9a04f8fa2da26f9ec513f514163705666a"></a>OC_CS_ITU_REC_470BG&#160;</td><td class="fielddoc"><p>This is the best option for 'PAL' content. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa567da4ce591f7373149ce3ef3acdac9a640b572f11fa7102d434e1c605aaa186" name="aa567da4ce591f7373149ce3ef3acdac9a640b572f11fa7102d434e1c605aaa186"></a>OC_CS_NSPACES&#160;</td><td class="fielddoc"><p>This marks the end of the defined colorspaces. </p>
</td></tr>
</table>

</div>
</div>
<a id="ae169da05bfaaf4e964a6866552d45079" name="ae169da05bfaaf4e964a6866552d45079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae169da05bfaaf4e964a6866552d45079">&#9670;&#160;</a></span>theora_pixelformat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="theora_8h.html#ae169da05bfaaf4e964a6866552d45079">theora_pixelformat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A Chroma subsampling. </p>
<p>These enumerate the available chroma subsampling options supported by the theora format. See Section 4.4 of the specification for exact definitions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae169da05bfaaf4e964a6866552d45079a4e451af01be2645511b0e431f5225d2b" name="ae169da05bfaaf4e964a6866552d45079a4e451af01be2645511b0e431f5225d2b"></a>OC_PF_420&#160;</td><td class="fielddoc"><p>Chroma subsampling by 2 in each direction (4:2:0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ae169da05bfaaf4e964a6866552d45079a7d21c63341ad299766839c83ed1216eb" name="ae169da05bfaaf4e964a6866552d45079a7d21c63341ad299766839c83ed1216eb"></a>OC_PF_RSVD&#160;</td><td class="fielddoc"><p>Reserved value. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae169da05bfaaf4e964a6866552d45079a36a88c55b7ddd5aedeac2d61d57fee5b" name="ae169da05bfaaf4e964a6866552d45079a36a88c55b7ddd5aedeac2d61d57fee5b"></a>OC_PF_422&#160;</td><td class="fielddoc"><p>Horizonatal chroma subsampling by 2 (4:2:2) </p>
</td></tr>
<tr><td class="fieldname"><a id="ae169da05bfaaf4e964a6866552d45079a1d5c6d1b0365e06b4a87880b7825f044" name="ae169da05bfaaf4e964a6866552d45079a1d5c6d1b0365e06b4a87880b7825f044"></a>OC_PF_444&#160;</td><td class="fielddoc"><p>No chroma subsampling at all (4:4:4) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab252d5d81b925136dda72e8f1c09c5eb" name="ab252d5d81b925136dda72e8f1c09c5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab252d5d81b925136dda72e8f1c09c5eb">&#9670;&#160;</a></span>theora_clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> theora_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtheora__state.html">theora_state</a> *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free all internal data associated with a <a class="el" href="structtheora__state.html" title="Codec internal state and context.">theora_state</a> handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A <a class="el" href="structtheora__state.html" title="Codec internal state and context.">theora_state</a> handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a650642ed23894e41109bbc42ec393ed4" name="a650642ed23894e41109bbc42ec393ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a650642ed23894e41109bbc42ec393ed4">&#9670;&#160;</a></span>theora_comment_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> theora_comment_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtheora__comment.html">theora_comment</a> *&#160;</td>
          <td class="paramname"><em>tc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>comment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a comment to an initialized <a class="el" href="structtheora__comment.html" title="Comment header metadata.">theora_comment</a> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tc</td><td>A previously initialized theora comment structure </td></tr>
    <tr><td class="paramname">comment</td><td>A null-terminated string encoding the comment in the form "TAG=the value"</td></tr>
  </table>
  </dd>
</dl>
<p>Neither <a class="el" href="theora_8h.html#a650642ed23894e41109bbc42ec393ed4" title="Add a comment to an initialized theora_comment structure.">theora_comment_add()</a> nor <a class="el" href="theora_8h.html#a339bd80b5bf4bb168b7052d8ec0b5a92" title="Add a comment to an initialized theora_comment structure.">theora_comment_add_tag()</a> support comments containing null values, although the bitstream format supports this. To add such comments you will need to manipulate the <a class="el" href="structtheora__comment.html" title="Comment header metadata.">theora_comment</a> structure directly. </p>

</div>
</div>
<a id="a339bd80b5bf4bb168b7052d8ec0b5a92" name="a339bd80b5bf4bb168b7052d8ec0b5a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a339bd80b5bf4bb168b7052d8ec0b5a92">&#9670;&#160;</a></span>theora_comment_add_tag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> theora_comment_add_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtheora__comment.html">theora_comment</a> *&#160;</td>
          <td class="paramname"><em>tc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a comment to an initialized <a class="el" href="structtheora__comment.html" title="Comment header metadata.">theora_comment</a> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tc</td><td>A previously initialized theora comment structure </td></tr>
    <tr><td class="paramname">tag</td><td>A null-terminated string containing the tag associated with the comment. </td></tr>
    <tr><td class="paramname">value</td><td>The corresponding value as a null-terminated string</td></tr>
  </table>
  </dd>
</dl>
<p>Neither <a class="el" href="theora_8h.html#a650642ed23894e41109bbc42ec393ed4" title="Add a comment to an initialized theora_comment structure.">theora_comment_add()</a> nor <a class="el" href="theora_8h.html#a339bd80b5bf4bb168b7052d8ec0b5a92" title="Add a comment to an initialized theora_comment structure.">theora_comment_add_tag()</a> support comments containing null values, although the bitstream format supports this. To add such comments you will need to manipulate the <a class="el" href="structtheora__comment.html" title="Comment header metadata.">theora_comment</a> structure directly. </p>

</div>
</div>
<a id="a04c07c2eefba3a433e43f9fbde14719f" name="a04c07c2eefba3a433e43f9fbde14719f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c07c2eefba3a433e43f9fbde14719f">&#9670;&#160;</a></span>theora_comment_clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> theora_comment_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtheora__comment.html">theora_comment</a> *&#160;</td>
          <td class="paramname"><em>tc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear an allocated <a class="el" href="structtheora__comment.html" title="Comment header metadata.">theora_comment</a> struct so that it can be freed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tc</td><td>An allocated <a class="el" href="structtheora__comment.html" title="Comment header metadata.">theora_comment</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a811b92785df3bdbbebb3de612d9d6ce0" name="a811b92785df3bdbbebb3de612d9d6ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a811b92785df3bdbbebb3de612d9d6ce0">&#9670;&#160;</a></span>theora_comment_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> theora_comment_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtheora__comment.html">theora_comment</a> *&#160;</td>
          <td class="paramname"><em>tc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an allocated <a class="el" href="structtheora__comment.html" title="Comment header metadata.">theora_comment</a> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tc</td><td>An allocated <a class="el" href="structtheora__comment.html" title="Comment header metadata.">theora_comment</a> structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9e0e9ad7e6d3b76129f9660bcad5ebd" name="ac9e0e9ad7e6d3b76129f9660bcad5ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e0e9ad7e6d3b76129f9660bcad5ebd">&#9670;&#160;</a></span>theora_comment_query()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * theora_comment_query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtheora__comment.html">theora_comment</a> *&#160;</td>
          <td class="paramname"><em>tc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up a comment value by tag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tc</td><td>Tn initialized <a class="el" href="structtheora__comment.html" title="Comment header metadata.">theora_comment</a> structure </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to look up </td></tr>
    <tr><td class="paramname">count</td><td>The instance of the tag. The same tag can appear multiple times, each with a distinct and ordered value, so an index is required to retrieve them all. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the queried tag's value </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>No matching tag is found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Use <a class="el" href="theora_8h.html#a10f66a3c752442a3e0c0098e0f88df8b" title="Look up the number of instances of a tag.">theora_comment_query_count()</a> to get the legal range for the count parameter. </dd></dl>

</div>
</div>
<a id="a10f66a3c752442a3e0c0098e0f88df8b" name="a10f66a3c752442a3e0c0098e0f88df8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f66a3c752442a3e0c0098e0f88df8b">&#9670;&#160;</a></span>theora_comment_query_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int theora_comment_query_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtheora__comment.html">theora_comment</a> *&#160;</td>
          <td class="paramname"><em>tc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up the number of instances of a tag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tc</td><td>An initialized <a class="el" href="structtheora__comment.html" title="Comment header metadata.">theora_comment</a> structure </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to look up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number on instances of a particular tag.</dd></dl>
<p>Call this first when querying for a specific tag and then interate over the number of instances with separate calls to <a class="el" href="theora_8h.html#ac9e0e9ad7e6d3b76129f9660bcad5ebd" title="Look up a comment value by tag.">theora_comment_query()</a> to retrieve all instances in order. </p>

</div>
</div>
<a id="a186773db3bc8cd550047e7df1b2ba2c9" name="a186773db3bc8cd550047e7df1b2ba2c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186773db3bc8cd550047e7df1b2ba2c9">&#9670;&#160;</a></span>theora_control()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int theora_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtheora__state.html">theora_state</a> *&#160;</td>
          <td class="paramname"><em>th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encoder control function. </p>
<p>This is used to provide advanced control the encoding process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">th</td><td>A <a class="el" href="structtheora__state.html" title="Codec internal state and context.">theora_state</a> handle. </td></tr>
    <tr><td class="paramname">req</td><td>The control code to process. See <a class="el" href="theora_8h.html#encctlcodes_old">the list of available </a> control codes" for details. </td></tr>
    <tr><td class="paramname">buf</td><td>The parameters for this control code. </td></tr>
    <tr><td class="paramname">buf_sz</td><td>The size of the parameter buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02915e63c1bd733ee291f577a8b75a82" name="a02915e63c1bd733ee291f577a8b75a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02915e63c1bd733ee291f577a8b75a82">&#9670;&#160;</a></span>theora_decode_header()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int theora_decode_header </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtheora__info.html">theora_info</a> *&#160;</td>
          <td class="paramname"><em>ci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheora__comment.html">theora_comment</a> *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structogg__packet.html">ogg_packet</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode an Ogg packet, with the expectation that the packet contains an initial header, comment data or codebook tables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ci</td><td>A <a class="el" href="structtheora__info.html" title="Theora bitstream info.">theora_info</a> structure to fill. This must have been previously initialized with <a class="el" href="theora_8h.html#a3091c87d48f1faba018c5956379a6d90" title="Initialize a theora_info structure.">theora_info_init()</a>. If <em>op</em> contains an initial header, <a class="el" href="theora_8h.html#a02915e63c1bd733ee291f577a8b75a82" title="Decode an Ogg packet, with the expectation that the packet contains an initial header,...">theora_decode_header()</a> will fill <em>ci</em> with the parsed header values. If <em>op</em> contains codebook tables, <a class="el" href="theora_8h.html#a02915e63c1bd733ee291f577a8b75a82" title="Decode an Ogg packet, with the expectation that the packet contains an initial header,...">theora_decode_header()</a> will parse these and attach an internal representation to <em>ci-&gt;codec_setup</em>. </td></tr>
    <tr><td class="paramname">cc</td><td>A <a class="el" href="structtheora__comment.html" title="Comment header metadata.">theora_comment</a> structure to fill. If <em>op</em> contains comment data, <a class="el" href="theora_8h.html#a02915e63c1bd733ee291f577a8b75a82" title="Decode an Ogg packet, with the expectation that the packet contains an initial header,...">theora_decode_header()</a> will fill <em>cc</em> with the parsed comments. </td></tr>
    <tr><td class="paramname">op</td><td>An <a class="el" href="structogg__packet.html">ogg_packet</a> structure which you expect contains an initial header, comment data or codebook tables.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">OC_BADHEADER</td><td><em>op</em> is NULL; OR the first byte of <em>op-&gt;packet</em> has the signature of an initial packet, but op is not a b_o_s packet; OR this packet has the signature of an initial header packet, but an initial header packet has already been seen; OR this packet has the signature of a comment packet, but the initial header has not yet been seen; OR this packet has the signature of a comment packet, but contains invalid data; OR this packet has the signature of codebook tables, but the initial header or comments have not yet been seen; OR this packet has the signature of codebook tables, but contains invalid data; OR the stream being decoded has a compatible version but this packet does not have the signature of a theora initial header, comments, or codebook packet </td></tr>
    <tr><td class="paramname">OC_VERSION</td><td>The packet data of <em>op</em> is an initial header with a version which is incompatible with this version of libtheora. </td></tr>
    <tr><td class="paramname">OC_NEWPACKET</td><td>the stream being decoded has an incompatible (future) version and contains an unknown signature. </td></tr>
    <tr><td class="paramname">0</td><td>Success</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The normal usage is that <a class="el" href="theora_8h.html#a02915e63c1bd733ee291f577a8b75a82" title="Decode an Ogg packet, with the expectation that the packet contains an initial header,...">theora_decode_header()</a> be called on the first three packets of a theora logical bitstream in succession. </dd></dl>

</div>
</div>
<a id="a264907c66003799ff77ecbd09eb33d2c" name="a264907c66003799ff77ecbd09eb33d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264907c66003799ff77ecbd09eb33d2c">&#9670;&#160;</a></span>theora_decode_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int theora_decode_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtheora__state.html">theora_state</a> *&#160;</td>
          <td class="paramname"><em>th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheora__info.html">theora_info</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="structtheora__state.html" title="Codec internal state and context.">theora_state</a> handle for decoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">th</td><td>The <a class="el" href="structtheora__state.html" title="Codec internal state and context.">theora_state</a> handle to initialize. </td></tr>
    <tr><td class="paramname">c</td><td>A <a class="el" href="structtheora__info.html" title="Theora bitstream info.">theora_info</a> struct filled with the desired decoding parameters. This is of course usually obtained from a previous call to <a class="el" href="theora_8h.html#a02915e63c1bd733ee291f577a8b75a82" title="Decode an Ogg packet, with the expectation that the packet contains an initial header,...">theora_decode_header()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa65a9e53b46fd54ab344bd599fa96975" name="aa65a9e53b46fd54ab344bd599fa96975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa65a9e53b46fd54ab344bd599fa96975">&#9670;&#160;</a></span>theora_decode_packetin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int theora_decode_packetin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtheora__state.html">theora_state</a> *&#160;</td>
          <td class="paramname"><em>th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structogg__packet.html">ogg_packet</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Input a packet containing encoded data into the theora decoder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">th</td><td>A <a class="el" href="structtheora__state.html" title="Codec internal state and context.">theora_state</a> handle previously initialized for decoding. </td></tr>
    <tr><td class="paramname">op</td><td>An <a class="el" href="structogg__packet.html">ogg_packet</a> containing encoded theora data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">OC_BADPACKET</td><td><em>op</em> does not contain encoded video data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09d47c80e1e94bff0a46a496816b8daa" name="a09d47c80e1e94bff0a46a496816b8daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d47c80e1e94bff0a46a496816b8daa">&#9670;&#160;</a></span>theora_decode_YUVout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int theora_decode_YUVout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtheora__state.html">theora_state</a> *&#160;</td>
          <td class="paramname"><em>th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structyuv__buffer.html">yuv_buffer</a> *&#160;</td>
          <td class="paramname"><em>yuv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output the next available frame of decoded YUV data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">th</td><td>A <a class="el" href="structtheora__state.html" title="Codec internal state and context.">theora_state</a> handle previously initialized for decoding. </td></tr>
    <tr><td class="paramname">yuv</td><td>A <a class="el" href="structyuv__buffer.html" title="A YUV buffer for passing uncompressed frames to and from the codec.">yuv_buffer</a> in which libtheora should place the decoded data. Note that the buffer struct itself is allocated by the user, but that the luma and chroma pointers will be filled in by the library. Also note that these luma and chroma regions should be considered read-only by the user. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45e8db0713eaaca0f1144f3724cb834a" name="a45e8db0713eaaca0f1144f3724cb834a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e8db0713eaaca0f1144f3724cb834a">&#9670;&#160;</a></span>theora_encode_comment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int theora_encode_comment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtheora__comment.html">theora_comment</a> *&#160;</td>
          <td class="paramname"><em>tc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structogg__packet.html">ogg_packet</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request a comment header packet from provided metadata. </p>
<p>A pointer to the comment data is placed in a user-provided <a class="el" href="structogg__packet.html">ogg_packet</a> structure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tc</td><td>A <a class="el" href="structtheora__comment.html" title="Comment header metadata.">theora_comment</a> structure filled with the desired metadata </td></tr>
    <tr><td class="paramname">op</td><td>An <a class="el" href="structogg__packet.html">ogg_packet</a> structure to fill. libtheora will set all elements of this structure, including a pointer to the encoded comment data. The memory for the comment data is owned by libtheora. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a451feb58d6bde726edbae193689887be" name="a451feb58d6bde726edbae193689887be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451feb58d6bde726edbae193689887be">&#9670;&#160;</a></span>theora_encode_header()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int theora_encode_header </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtheora__state.html">theora_state</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structogg__packet.html">ogg_packet</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request a packet containing the initial header. </p>
<p>A pointer to the header data is placed in a user-provided <a class="el" href="structogg__packet.html">ogg_packet</a> structure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A <a class="el" href="structtheora__state.html" title="Codec internal state and context.">theora_state</a> handle previously initialized for encoding. </td></tr>
    <tr><td class="paramname">op</td><td>An <a class="el" href="structogg__packet.html">ogg_packet</a> structure to fill. libtheora will set all elements of this structure, including a pointer to the header data. The memory for the header data is owned by libtheora. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f7ad4d4b2343278cb4ba8fb2bd5109a" name="a0f7ad4d4b2343278cb4ba8fb2bd5109a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7ad4d4b2343278cb4ba8fb2bd5109a">&#9670;&#160;</a></span>theora_encode_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int theora_encode_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtheora__state.html">theora_state</a> *&#160;</td>
          <td class="paramname"><em>th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheora__info.html">theora_info</a> *&#160;</td>
          <td class="paramname"><em>ti</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the theora encoder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">th</td><td>The <a class="el" href="structtheora__state.html" title="Codec internal state and context.">theora_state</a> handle to initialize for encoding. </td></tr>
    <tr><td class="paramname">ti</td><td>A <a class="el" href="structtheora__info.html" title="Theora bitstream info.">theora_info</a> struct filled with the desired encoding parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f4929677a735bc2198c2309d235f1b3" name="a5f4929677a735bc2198c2309d235f1b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4929677a735bc2198c2309d235f1b3">&#9670;&#160;</a></span>theora_encode_packetout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int theora_encode_packetout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtheora__state.html">theora_state</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>last_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structogg__packet.html">ogg_packet</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request the next packet of encoded video. </p>
<p>The encoded data is placed in a user-provided <a class="el" href="structogg__packet.html">ogg_packet</a> structure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A <a class="el" href="structtheora__state.html" title="Codec internal state and context.">theora_state</a> handle previously initialized for encoding. </td></tr>
    <tr><td class="paramname">last_p</td><td>whether this is the last packet the encoder should produce. </td></tr>
    <tr><td class="paramname">op</td><td>An <a class="el" href="structogg__packet.html">ogg_packet</a> structure to fill. libtheora will set all elements of this structure, including a pointer to encoded data. The memory for the encoded data is owned by libtheora. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>No internal storage exists OR no packet is ready </td></tr>
    <tr><td class="paramname">-1</td><td>The encoding process has completed </td></tr>
    <tr><td class="paramname">1</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5085baf20855b283fa01fc948505d9d2" name="a5085baf20855b283fa01fc948505d9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5085baf20855b283fa01fc948505d9d2">&#9670;&#160;</a></span>theora_encode_tables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int theora_encode_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtheora__state.html">theora_state</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structogg__packet.html">ogg_packet</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request a packet containing the codebook tables for the stream. </p>
<p>A pointer to the codebook data is placed in a user-provided <a class="el" href="structogg__packet.html">ogg_packet</a> structure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A <a class="el" href="structtheora__state.html" title="Codec internal state and context.">theora_state</a> handle previously initialized for encoding. </td></tr>
    <tr><td class="paramname">op</td><td>An <a class="el" href="structogg__packet.html">ogg_packet</a> structure to fill. libtheora will set all elements of this structure, including a pointer to the codebook data. The memory for the header data is owned by libtheora. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0d33d896ca70cedfc94c5986d947078" name="ac0d33d896ca70cedfc94c5986d947078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d33d896ca70cedfc94c5986d947078">&#9670;&#160;</a></span>theora_encode_YUVin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int theora_encode_YUVin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtheora__state.html">theora_state</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structyuv__buffer.html">yuv_buffer</a> *&#160;</td>
          <td class="paramname"><em>yuv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit a YUV buffer to the theora encoder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A <a class="el" href="structtheora__state.html" title="Codec internal state and context.">theora_state</a> handle previously initialized for encoding. </td></tr>
    <tr><td class="paramname">yuv</td><td>A buffer of YUV data to encode. Note that both the <a class="el" href="structyuv__buffer.html" title="A YUV buffer for passing uncompressed frames to and from the codec.">yuv_buffer</a> struct and the luma/chroma buffers within should be allocated by the user. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">OC_EINVAL</td><td>Encoder is not ready, or is finished. </td></tr>
    <tr><td class="paramname">-1</td><td>The size of the given frame differs from those previously input </td></tr>
    <tr><td class="paramname">0</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7bfa3ceb2fb4b41a282456c56e1dd269" name="a7bfa3ceb2fb4b41a282456c56e1dd269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bfa3ceb2fb4b41a282456c56e1dd269">&#9670;&#160;</a></span>theora_granule_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ogg_int64_t theora_granule_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtheora__state.html">theora_state</a> *&#160;</td>
          <td class="paramname"><em>th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ogg_int64_t&#160;</td>
          <td class="paramname"><em>granulepos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a granulepos to an absolute frame index, starting at 0. </p>
<p>The granulepos is interpreted in the context of a given <a class="el" href="structtheora__state.html" title="Codec internal state and context.">theora_state</a> handle.</p>
<p>Note that while the granulepos encodes the frame count (i.e. starting from 1) this call returns the frame index, starting from zero. Thus One can calculate the presentation time by multiplying the index by the rate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">th</td><td>A previously initialized <a class="el" href="structtheora__state.html" title="Codec internal state and context.">theora_state</a> handle (encode or decode) </td></tr>
    <tr><td class="paramname">granulepos</td><td>The granulepos to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The frame index corresponding to <em>granulepos</em>. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>The given granulepos is undefined (i.e. negative)</td></tr>
  </table>
  </dd>
</dl>
<p>Thus function was added in the 1.0alpha4 release. </p>

</div>
</div>
<a id="acd9360e6a47139c761002410af457a02" name="acd9360e6a47139c761002410af457a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9360e6a47139c761002410af457a02">&#9670;&#160;</a></span>theora_granule_shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int theora_granule_shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtheora__info.html">theora_info</a> *&#160;</td>
          <td class="paramname"><em>ti</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report the granulepos shift radix. </p>
<p>When embedded in Ogg, Theora uses a two-part granulepos, splitting the 64-bit field into two pieces. The more-significant section represents the frame count at the last keyframe, and the less-significant section represents the count of frames since the last keyframe. In this way the overall field is still non-decreasing with time, but usefully encodes a pointer to the last keyframe, which is necessary for correctly restarting decode after a seek.</p>
<p>This function reports the number of bits used to represent the distance to the last keyframe, and thus how the granulepos field must be shifted or masked to obtain the two parts.</p>
<p>Since libtheora returns compressed data in an <a class="el" href="structogg__packet.html">ogg_packet</a> structure, this may be generally useful even if the Theora packets are not being used in an Ogg container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ti</td><td>A previously initialized <a class="el" href="structtheora__info.html" title="Theora bitstream info.">theora_info</a> struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bit shift dividing the two granulepos fields</dd></dl>
<p>This function was added in the 1.0alpha5 release. </p>

</div>
</div>
<a id="a4376358b12b9fa23ce6fe21cb5c65ac6" name="a4376358b12b9fa23ce6fe21cb5c65ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4376358b12b9fa23ce6fe21cb5c65ac6">&#9670;&#160;</a></span>theora_granule_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double theora_granule_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtheora__state.html">theora_state</a> *&#160;</td>
          <td class="paramname"><em>th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ogg_int64_t&#160;</td>
          <td class="paramname"><em>granulepos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a granulepos to absolute time in seconds. </p>
<p>The granulepos is interpreted in the context of a given <a class="el" href="structtheora__state.html" title="Codec internal state and context.">theora_state</a> handle, and gives the end time of a frame's presentation as used in Ogg mux ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">th</td><td>A previously initialized <a class="el" href="structtheora__state.html" title="Codec internal state and context.">theora_state</a> handle (encode or decode) </td></tr>
    <tr><td class="paramname">granulepos</td><td>The granulepos to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The absolute time in seconds corresponding to <em>granulepos</em>. This is the "end time" for the frame, or the latest time it should be displayed. It is not the presentation time. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1.</td><td>The given granulepos is undefined (i.e. negative), or </td></tr>
    <tr><td class="paramname">-1.</td><td>The function has been disabled because floating point support is not available. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba7022d58edbc4825cacad03f68b3e0d" name="aba7022d58edbc4825cacad03f68b3e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba7022d58edbc4825cacad03f68b3e0d">&#9670;&#160;</a></span>theora_info_clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> theora_info_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtheora__info.html">theora_info</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear a <a class="el" href="structtheora__info.html" title="Theora bitstream info.">theora_info</a> structure. </p>
<p>All values within the given <a class="el" href="structtheora__info.html" title="Theora bitstream info.">theora_info</a> structure are cleared, and associated internal codec setup data is freed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>A <a class="el" href="structtheora__info.html" title="Theora bitstream info.">theora_info</a> struct to initialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3091c87d48f1faba018c5956379a6d90" name="a3091c87d48f1faba018c5956379a6d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3091c87d48f1faba018c5956379a6d90">&#9670;&#160;</a></span>theora_info_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a> theora_info_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtheora__info.html">theora_info</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="structtheora__info.html" title="Theora bitstream info.">theora_info</a> structure. </p>
<p>All values within the given <a class="el" href="structtheora__info.html" title="Theora bitstream info.">theora_info</a> structure are initialized, and space is allocated within libtheora for internal codec setup data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>A <a class="el" href="structtheora__info.html" title="Theora bitstream info.">theora_info</a> struct to initialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab969f9d0407683f0e5abe73d0839a25b" name="ab969f9d0407683f0e5abe73d0839a25b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab969f9d0407683f0e5abe73d0839a25b">&#9670;&#160;</a></span>theora_packet_isheader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int theora_packet_isheader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structogg__packet.html">ogg_packet</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report whether a theora packet is a header or not This function does no verification beyond checking the header flag bit so it should not be used for bitstream identification; use <a class="el" href="theora_8h.html#a02915e63c1bd733ee291f577a8b75a82" title="Decode an Ogg packet, with the expectation that the packet contains an initial header,...">theora_decode_header()</a> for that. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>An <a class="el" href="structogg__packet.html">ogg_packet</a> containing encoded theora data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>The packet is a header packet </td></tr>
    <tr><td class="paramname">0</td><td>The packet is not a header packet (and so contains frame data)</td></tr>
  </table>
  </dd>
</dl>
<p>Thus function was added in the 1.0alpha4 release. </p>

</div>
</div>
<a id="a39ccc8f847a748d7074c926b4fdd12b2" name="a39ccc8f847a748d7074c926b4fdd12b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ccc8f847a748d7074c926b4fdd12b2">&#9670;&#160;</a></span>theora_packet_iskeyframe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int theora_packet_iskeyframe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structogg__packet.html">ogg_packet</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report whether a theora packet is a keyframe or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>An <a class="el" href="structogg__packet.html">ogg_packet</a> containing encoded theora data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>The packet contains a keyframe image </td></tr>
    <tr><td class="paramname">0</td><td>The packet is contains an interframe delta </td></tr>
    <tr><td class="paramname">-1</td><td>The packet is not an image data packet at all</td></tr>
  </table>
  </dd>
</dl>
<p>Thus function was added in the 1.0alpha4 release. </p>

</div>
</div>
<a id="ad181f4b19d455dcc2bef2533530b84c8" name="ad181f4b19d455dcc2bef2533530b84c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad181f4b19d455dcc2bef2533530b84c8">&#9670;&#160;</a></span>theora_version_number()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ogg_uint32_t theora_version_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a 32-bit version number. </p>
<p>This number is composed of a 16-bit major version, 8-bit minor version and 8 bit sub-version, composed as follows: </p><pre>
   (VERSION_MAJOR&lt;&lt;16) + (VERSION_MINOR&lt;&lt;8) + (VERSION_SUB)
</pre> <dl class="section return"><dt>Returns</dt><dd>The version number. </dd></dl>

</div>
</div>
<a id="ac52e77d5dab481f2181c8162549c0cb9" name="ac52e77d5dab481f2181c8162549c0cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac52e77d5dab481f2181c8162549c0cb9">&#9670;&#160;</a></span>theora_version_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char * theora_version_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libpng16_2png_8h.html#a05f08be336491be77cd4dfa98f747c69">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a human-readable string to identify the encoder vendor and version. </p>
<dl class="section return"><dt>Returns</dt><dd>A version string. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_93501a11e921083efbd154e0cdff5f10.html">packages</a></li><li class="navelem"><a class="el" href="dir_5231ec13610cfaac4790c61103e13700.html">AllegroDeps.1.13.0</a></li><li class="navelem"><a class="el" href="dir_d5cc7b0ba1ffdf84f3ec7f501b134cb6.html">build</a></li><li class="navelem"><a class="el" href="dir_f0af660ba7ceb6325064fd9ed5c38fd1.html">native</a></li><li class="navelem"><a class="el" href="dir_5f12c56d3dd723b54e45ed3518b08f15.html">include</a></li><li class="navelem"><a class="el" href="dir_7a28f8a07287dcbebf94b7ee38b0bdd7.html">theora</a></li><li class="navelem"><a class="el" href="theora_8h.html">theora.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
